<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Document</title><script defer="defer" src="../../../main.712a0d0e9568940a7d0c.js"></script><link href="../../../main.css" rel="stylesheet"></head><body><div class="wrap"><header><nav class="global_wrap sub"><ul class="line"></ul></nav></header><main><div class="global_wrap"><section class="conts"><h2>Network</h2><div class="depth_2"><strong>HTTP Header - 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보 전달</strong><div class="item_wrap"><dl class="item"><dt><button>General <span>Header</span></button></dt><dd>공통 헤더</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
General Header(공통 헤더)
-  요청과 응답 모두에 적용되지만 바디에서 최종적으로 전송되는 데이터와는 관련이 없는 헤더

# Date : 
현재시간

# Pragma : 
캐시제어 , HTTP/1.0에서 쓰던 것으로 HTTP/1.1에서는 Cache-Control이 쓰인다.

# Cache-Control : 
캐시를 제어할 때 사용

# Upgrade : 
프로토콜 변경시 사용

# Via : 
중계(프록시)서버의 이름, 버전, 호스트명

# Connection : 
네트워크 접속을 유지할지 말지 제어. HTTP/1.1은 kepp-alive 로 연결 유지하는게 default 값

# Transfer-Encoding : 
사용자에게 entity를 안전하게 전송하기 위해 사용하는 인코딩 형식을 지정
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>Request <span>Header</span></button></dt><dd>요청 헤더</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
Request Header(요청 헤더)
- HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 패치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더


# Host : 
요청하려는 서버 호스트 이름과 포트번호

# User-agent : 
클라이언트 프로그램 정보 ex) Mozilla/4.0, Windows NT5.1

# Referer : 
현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소

# Accept : 
클라이언트가 처리 가능한 MIME Type 종류 나열

# Accept-charset : 
클라이언트가 지원가능한 문자열 인코딩 방식

# Accept-language : 
클라이언트가 지원가능한 언어 나열

# Accept-encoding : 
클라이언트가 해석가능한 압축 방식 지정

# If-Modified-Since : 
여기에 쓰여진 시간 이후로 변경된 리소스 취득. 캐시가 만료되었을 때에만 데이터를 전송하는데 사용

# Authorization : 
인증 토큰을 서버로 보낼 때 쓰이는 헤더

# Origin : 
서버로 Post 요청을 보낼 때 요청이 어느 주소에서 시작되었는지 나타내는 값. 경로 정보는 포함하지 않고 서버 이름만 포함
이 값으로 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 난다.

# Cookie : 
쿠기 값 key-value로 표현된다. Set-Cookie 헤더와 함께 서버로부터 이전에 전송됐던 저장된 HTTP 쿠키를 포함
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>Response <span>Header</span></button></dt><dd>응답 헤더</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
Response Header(응답 헤더)
- 위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더


# Server : 
웹서버의 종류

# Age : 
max-age 시간내에서 얼마나 흘렀는지 초 단위로 알려주는 값

# Referrer-policy : 
서버 referrer 정책을 알려주는 값 ex) origin, no-referrer, unsafe-url

# WWW-Authenticate : 
사용자 인증이 필요한 자원을 요구할 시, 서버가 제공하는 인증 방식

# Proxy-Authenticate : 
요청한 서버가 프록시 서버인 경우 유저 인증을 위한 값

# Set-Cookie : 
서버측에서 클라이언트에게 세션 쿠키 정보를 설정 (RFC 2965에서 규정)
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>Entity <span>Header</span></button></dt><dd>엔티티 헤더</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
Entity Header(엔티티 헤더)
- 컨텐츠 길이나 MIME 타입과 같이 엔티티 바디에 대한 자세한 정보를 포함하는 헤더


# Content-type : 
리소스의 media type 명시 ex) application/json, text/html

# Content-Length : 
바이트 단위를 가지는 개체 본문의 크기

# Content-language : 
본문을 이해하는데 가장 적절한 언어

# Content-location : 
반환된 데이터 개체의 실제 위치 ex) /index.html

# Content-disposition : 
응답 메세지를 브라우저가 어떻게 처리할지. 주로 다운로드에 사용

# Content-Security-Policy : 
다른 외부 파일을 불러오는 경우 차단할 리소스와 불러올 리소스 명시
ex) default-src https -> https로만 파일을 가져옴
ex) default-src 'self' -> 자기 도메인에서만 가져옴
ex) default-src 'none' -> 외부파일은 가져올 수 없음

# Content-Encoding : 
본문의 리소스 압축 방식. 주로 Content-Type과 같이 사용되며 참조되는 미디어 타입을 얻도록 디코드하는 방법을 클라이언트가 알게 해줍니다.

# Location : 
301, 302 상태코드일 때만 볼 수 있는 헤더로 서버의 응답이 다른 곳에 있다고 알려주면서 해당 위치(URI)를 지정

# Last-Modified : 
리소스의 마지막 수정 날짜

# Allow : 
지원되는 HTTP 요청 메소드 ex) GET, HEAD, POST

# Expires : 
자원의 만료 일자

# ETag : 
리소스의 버전을 식별하는 고유한 문자열 검사기(주로 캐시 확인용으로 사용)


https://velog.io/@cham/
https://jeong-pro.tistory.com/181
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers
https://www.huskyhoochu.com/cache-control/
http://coffeenix.net/doc/network/http_1_0_vs_1_1.html


                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>개념</strong><div class="item_wrap"><dl class="item"><dt><button>Debounce <span></span></button></dt><dd>이벤트가 끝날 때까지 기다렸다가 한번만 실행</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
const debounce = (cb, waitTime = 500) => {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            cb(...args)
        }, waitTime);
    }
}
                                
                            </code>

                            <code class="markdown">


디바운스와 쓰로틀 
참고 자료 
https://class.codejong.kr/t/topic/58/2
https://css-tricks.com/debouncing-throttling-explained-examples/


리액트에서 로대쉬 이용하여 디바운스 쓰로틀 사용 
https://velog.io/@edie_ko/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EC%8B%9C%ED%82%A4%EA%B8%B0-feat.-Lodash-throttle-debounce
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>Throttle <span></span></button></dt><dd>이벤트가 실행하면 주기적으로 실행</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
const throttle = (cb, waitTime = 0) => {
    let waiting = true;
    return (...args) => {
        if(waiting) {
            cb(...args)
            waiting = false;
            setTimeout(() => {
                waiting = true;
            }, waitTime)
        }
    }
}                 
                            </code>

                            <code class="markdown">
디바운스와 쓰로틀 
참고 자료 
https://class.codejong.kr/t/topic/58
https://css-tricks.com/debouncing-throttling-explained-examples/



리액트에서 로대쉬 이용하여 디바운스 쓰로틀 사용 
https://velog.io/@edie_ko/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EC%8B%9C%ED%82%A4%EA%B8%B0-feat.-Lodash-throttle-debounce
https://velog.io/@skawnkk/debounce-throttle

바닐라
https://velog.io/@pjeeyoung/Throttle-Debounce-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B5%AC%ED%98%84
                            </code>
                        </pre></div></div></div></section><section class="conts"><h2>Express</h2><div class="depth_2"><strong>express</strong><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.json()</button></dt><dd>json 파싱하기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
express.json([options])

const express = require("express");
const app = express();

app.use(express.json()); // json파일 파싱...bodyParser 대신 이거 쓰면 됨

app.post('/', function(req, res){
  console.log(req.body);      // 사용자의 JSON 요청
    res.send(req.body);    // JSON 응답
});

app.listen(3000);


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.Router()</button></dt><dd>라우터 생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
var router = express.Router([options])


// app.js
import userRoutes from './routes/userRoutes.js' //가져올 파일
app.use('/api/user', userRoutes) // 미들웨어로 붙임


// userRoutes.js
import express from 'express';
const router = express.Router();

// @path  /api/user/alluser/alluser
router.post() ~ //작성방법

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.static()</button></dt><dd>정적파일</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
express.static(root, [options])

정적 파일이란, 직접 값에 변화를 주지 않는 이상 변하지 않는 파일을 의미합니다. 예를 들면, image, css 파일, js 파일 등을 의미합니다.  express는 이러한 정적 파일들을 손쉽게 제공할 수 있는 기능을 가지고 있습니다.

만약, 기능을 제공하지 않는다면 파일이 존재하는 path로 접근해왔을 때 파일을 제공해주면 됩니다. 하지만 이는 굉장히 번거롭고 코드를 복잡하게 만든다는 단점이 있습니다.


// 사용하기
app.use(express.static('public'));


// 두 파일 가져오기 
app.use(express.static('public'));
app.use(express.static('files'));

// 상대경로로 지정하기 
app.use('/static', express.static(__dirname + '/public'));



https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=pjok1122&logNo=221545195520

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.urlencoded()</button></dt><dd>form data parsing</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.use(express.urlencoded({extended: false}))
// form submit했을떄 urlincoded방식으로 넘겨주는데 이걸 해석해서 req.body에 넣어줌


HTML &lt;form&gt;에서는 enctype 속성을 통해서, 여러가지 방법으로 form을 서버에 제출할 수 있도록 합니다. 기본적으로 enctype을 명시하지 않았을때는 application/x-www-form-urlencoded로 보내지며, 이는 ‘&’으로 분리되고 ‘=’으로 키와 값을 연결하는 구조입니다.
자세한 사항은 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/POST" target="_blank" title="new window">mdn</a> 링크를 참조해 주세요.


https://kasterra.github.io/handle-POST-data-in-express/
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.text()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
express.text([options])


이 메소드는 body를 문자열로 보고 파싱하고, request내의 Content-type과 해당 메소드의 type옵션이 일치하는 request 만을 처리하는 미들웨어를 반환합니다. 모든 형태의 유니코드 인코딩을 받아드리며, gzip이나 deflate인코딩으로 압축된 내용들을 알아서 압축 해제 합니다.

미들웨어로 처리되고 난 다음의 새로운 body 객체 내에는 request 객체 내에서 파싱 된 데이터들이 들어있을 것입니다. 만약에 파싱할 데이터가 없거나, Content-type이 일치하지 않거나 에러가 난다면 body객체는 빈 객체가 될 것입니다.



                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>express</span>.raw()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

express.raw([options])


이 메소드는 body를 Buffer로 보고 파싱하고, request내의 Content-type과 해당 메소드의 type옵션이 일치하는 request 만을 처리하는 미들웨어를 반환합니다. 모든 형태의 유니코드 인코딩을 받아드리며, gzip이나 deflate인코딩으로 압축된 내용들을 알아서 압축 해제 합니다.

미들웨어로 처리되고 난 다음의 새로운 body 객체 내에는 request 객체 내에서 파싱 된 데이터들이 들어있을 것입니다. 만약에 파싱할 데이터가 없거나, Content-type이 일치하지 않거나 에러가 난다면 body객체는 빈 객체가 될 것입니다.

application/octet-stream은 언제 쓰나요?
RFC 2046에서 명시된 바로는 application/octet-steam은 임의의 2진 파일을 의미합니다. 대충 웹 요소가 아닌 무언가 정도로 해석하면 됩니다. 이게 언제 쓰이는지는 찾아봐도 잘 모르겠습니다.
일단 브라우저 쪽에서 해당 헤더를 가진 HTTP POST를 수신했을 때, 파일을 다운로드 하는 창을 띄운다고 합니다.



https://kasterra.github.io/handle-POST-data-in-express/
                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>Application</strong><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.listen()</button></dt><dd>서버 실행 시점</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.listen(path, [callback])



var express = require('express')
var app = express()
app.listen(3000)
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.get()</button></dt><dd>가져오기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.get('/', function (req, res) {
    res.send('GET request to homepage')
})

GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다.
파라미터에 내용이 노출되기 때문에 민감한 데이터를 다룰 때 GET 요청을 사용해서는 안 됩니다.
GET 요청은 브라우저 기록에 남습니다.
GET 요청을 북마크에 추가할 수 있습니다.
GET 요청에는 데이터 길이에 대한 제한이 있습니다.
Get 요청은 성공시, 200(Ok) HTTP 응답 코드를 XML, JSON뿐만 아니라 여러 데이터(html, txt등..), 여러 형식의 데이터와 함께 반환합니다.
GET 요청은 idempotent합니다.
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.post()</button></dt><dd>저장, 데이터 전송</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.post('/', function (req, res) {
    res.send('POST request to homepage')
})


POST는 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야될 데이터를 HTTP 메세지의 Body에 담아서 전송합니다. HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송할 수 있습니다. 그래서 POST 요청은 GET과 달리 대용량 데이터를 전송할 수 있습니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다 보안적인 면에서 안전하다고 생각할 수 있지만, POST 요청도 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용을 확인할 수 있기 때문에 민감한 데이터의 경우에는 반드시 암호화해 전송해야 합니다.

그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 합니다. 데이터 타입을 표시하지 않으면 서버는 내용이나 URL에 포함된 리소스의 확장자명 등으로 데이터 타입을 유추합니다. 만약, 알 수 없는 경우에는 application/octet-stream로 요청을 처리합니다.

POST 요청은 캐시되지 않습니다.
POST 요청은 브라우저 기록에 남아 있지 않습니다.
POST 요청을 북마크에 추가할 수 없습니다.
POST 요청에는 데이터 길이에 대한 제한이 없습니다.
Post 요청 중 자원 생성은 201(Created) HTTP 응답 코드를 반환합니다.
Post 요청은 idempotent하지 않습니다.
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.put()</button></dt><dd>필드 모두수정</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
!!주의점
필드 부분만 전달하면 필드 외 부분은 null or 초기화 됨


app.put('/', function (req, res) {
    res.send('PUT request to homepage')
})
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.patch()</button></dt><dd>필드 부분수정</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.patch('/', function (req, res) {
    res.send('patch request to homepage')
})
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.delete()</button></dt><dd>삭제</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.delete('/', function (req, res) {
    res.send('DELETE request to homepage')
})
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.route()</button></dt><dd>route 생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
var app = express()

app.route('/events')
    .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
    })
    .get(function (req, res, next) {
    res.json({})
    })
    .post(function (req, res, next) {
    // maybe add a new event...
})





                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.use()</button></dt><dd>미들웨어 붙이기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.use([path,] callback [, callback...])

app.use(function (req, res, next) {
    console.log('Time: %d', Date.now())
    next()
})

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.render()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">




                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.all()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.set()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.get()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.path()</button></dt><dd>path 검색</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.path()


var app = express()
var blog = express()
var blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.dir(app.path()) // ''
console.dir(blog.path()) // '/blog'
console.dir(blogAdmin.path()) // '/blog/admin'
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.param()</button></dt><dd>GET 전송</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.param([name], callback)

app.param('user', function (req, res, next, id) {
    // try to get the user details from the User model and attach it to the request object
    User.find(id, function (err, user) {
      if (err) {
        next(err)
      } else if (user) {
        req.user = user
        next()
      } else {
        next(new Error('failed to load user'))
      }
    })
  })

  app.param('id', function (req, res, next, id) {
    console.log('CALLED ONLY ONCE')
    next()
  })
  
  app.get('/user/:id', function (req, res, next) {
    console.log('although this matches')
    next()
  })
  
  app.get('/user/:id', function (req, res) {
    console.log('and this matches too')
    res.end()
  })
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.METHOD()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.get()</button></dt><dd>GET 전송</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
app.get('/', function (req, res) {
    res.send('GET request to homepage')
})
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.engine()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.enable()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.enabled()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.disable()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.disabled()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.locals</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>app</span>.mountpath</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>mount</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>Request</strong><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.app</button></dt><dd>미들웨어 가져오기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// index.js
app.get('/viewdirectory', require('./mymiddleware.js'))

// mymiddleware.js
module.exports = function (req, res) {
  res.send('The views directory is ' + req.app.get('views'))
}
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.body</button></dt><dd>client에서 보낸 데이터</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
var express = require('express')

var app = express()

app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', function (req, res, next) {
    console.log(req.body)
    res.json(req.body)
})
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.cookies</button></dt><dd>일반 쿠키</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
cookie-parser 미들웨어 붙이면 쿠키가 바디에 담기고 그때 부터 쓰면 됨

                            
// Cookie: name=tj
console.dir(req.cookies.name)
// => 'tj'
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.signedCookies</button></dt><dd>암호화된 쿠키</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
실제 값이 노출되어도 상관없는 경우엔 req.cookie 
보안때문에 쿠키가 노출되면 안된다면 req.signedCookies 


app.use(cookieParser('hohoho'))
res.cookie('DataB', 200, { signed: true })

req.signedCookies.dataB // 개발자 도구 쿠키창에 쿠키값이 노출되지 않음
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.params</button></dt><dd>client에서 보낸 params</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// GET /user/tj
console.dir(req.params.name)
// => 'tj'



router.delete('/delete/:userId', async(req, res) => {
    const { userId } = req.params // 클라이언트에서 넘어온 :userId 값이 담김
})
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.fresh</button></dt><dd>요청 상태</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
console.dir(req.fresh)
// => true
응답이 클라이언트 캐시에서 여전히 "신선한" 경우 true가 반환되고, 그렇지 않으면 false가 반환되어 클라이언트 캐시가 이제 부실하고 전체 응답을 보내야 함을 나타냅니다.

클라이언트가 종단 간 다시 로드 요청을 나타내기 위해 Cache-Control: no-cache 요청 헤더를 보낼 때 이 모듈은 이러한 요청을 투명하게 처리하기 위해 false를 반환합니다.

캐시 유효성 검사 작동 방식에 대한 자세한 내용은 HTTP/1.1 캐싱 사양에서 찾을 수 있습니다.
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.stale</button></dt><dd>요청 상태</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
console.dir(req.stale)
// => true

요청이 "부실"인지 여부를 나타내며 req.fresh의 반대입니다. 자세한 내용은 req.fresh를 참조하세요.
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.ip</button></dt><dd>ip 출력</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
console.dir(req.ip)
// => '127.0.0.1'
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.ips</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
-
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.method</button></dt><dd>GET POST ...등 HTTP메소드 리턴해줌</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
ontains a string corresponding to the HTTP method of the request: GET, POST, PUT, and so on.
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.originalUrl</button></dt><dd>도메인 제외 url 반환</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
//http://localhost:5000/api/user/61c07d24bb241609ebfe7fff

console.log(req.originalUrl)
///api/user/61c07d24bb241609ebfe7fff


// GET /search?q=something
console.dir(req.originalUrl)
// => '/search?q=something'
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.protocol</button></dt><dd>프로토콜 반환</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
console.dir(req.protocol)
// => 'http'
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.res</button></dt><dd>응답 객체에 대한 참조 ?</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
This property holds a reference to the response object that relates to this request object.
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.route</button></dt><dd>라우트값 반환</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
app.get('/user/:id?', function userIdHandler (req, res) {
    console.log(req.route)
    res.send('GET')
})



//결과 
Route {
    path: '/:userId',
    stack: [
      Layer {
        handle: [AsyncFunction (anonymous)],
        name: '&lt;anonymous&gt;',
        params: undefined,
        path: undefined,
        keys: [],
        regexp: /^\/?$/i,
        method: 'get'
      }
    ],
    methods: { get: true }
  }
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.subdomains</button></dt><dd>도메인 이름 배열로</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
An array of subdomains in the domain name of the request.

// Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.xhr</button></dt><dd>request header가 XMLHttpRequest인지</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
                            
요청의 X-Requested-With 헤더 필드가 "XMLHttpRequest"인 경우 true인 부울 속성은 요청이 jQuery와 같은 클라이언트 라이브러리에서 발행되었음을 나타냅니다.

console.dir(req.xhr)
// => true
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.accepts(types)</button></dt><dd>HTTP header 중에서 ‘Accept’ 의 필드값에 가장 잘 매칭되는 type 을 반환</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
HTTP header 중에서 ‘Accept’ 의 필드값에 가장 잘 매칭되는 type 을 반환한다.
                            

// Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.acceptsCharsets(charset [, ...])</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
-
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.acceptsEncodings(encoding [, ...])</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
-
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.acceptsLanguages(lang [, ...])</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
-
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.get(field)</button></dt><dd>HTTP header 필드값을 반환</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.is(type)</button></dt><dd>HTTP header 중에서 ‘Content-Type’ 의 필드값에 type 이 적절한가 확인</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
들어오는 요청의 "Content-Type" HTTP 헤더 필드가 type 매개변수에 지정된 MIME 유형과 일치하는 경우 일치하는 콘텐츠 유형을 반환합니다. 
요청에 본문이 없으면 null을 반환합니다. 
그렇지 않으면 false를 반환합니다.


// With Content-Type: text/html; charset=utf-8
req.is('html')
// => 'html'
req.is('text/html')
// => 'text/html'
req.is('text/*')
// => 'text/*'

// When Content-Type is application/json
req.is('json')
// => 'json'
req.is('application/json')
// => 'application/json'
req.is('application/*')
// => 'application/*'

req.is('html')
// => false
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>req</span>.range(size[, options])</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

오디오파일? 뭐 용량체크하는건가 ? 아직 잘 모르겠음 

// parse header from request
var range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
    // the ranges
    range.forEach(function (r) {
    // do something with r.start and r.end
    })
}


//https://nachwon.github.io/byterange/
                            
                        </code>
                    </pre></div></div></div><div class="depth_2"><strong>Response</strong><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.app</button></dt><dd>app에 대한 값</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
이 속성은 미들웨어를 사용하는 Express 애플리케이션의 인스턴스에 대한 참조를 보유합니다.
res.app은 요청 객체의 req.app 속성과 동일합니다.


console.log(res.app)
&lt;ref *1&gt; [Function: app] {
    _events: [Object: null prototype] { mount: [Function: onmount] },
    _eventsCount: 1,
    _maxListeners: undefined,
    setMaxListeners: [Function: setMaxListeners],
    getMaxListeners: [Function: getMaxListeners],
    emit: [Function: emit],
    addListener: [Function: addListener],
    on: [Function: addListener],
    prependListener: [Function: prependListener],
    once: [Function: once],
    prependOnceListener: [Function: prependOnceListener],
    removeListener: [Function: removeListener],
    off: [Function: removeListener],
    removeAllListeners: [Function: removeAllListeners],
    listeners: [Function: listeners],
    rawListeners: [Function: rawListeners],
    listenerCount: [Function: listenerCount],
    eventNames: [Function: eventNames],
    init: [Function: init],
    defaultConfiguration: [Function: defaultConfiguration],
    lazyrouter: [Function: lazyrouter],
    handle: [Function: handle],
    use: [Function: use],
    route: [Function: route],
    engine: [Function: engine],
    param: [Function: param],
    set: [Function: set],
    path: [Function: path],
    enabled: [Function: enabled],
    disabled: [Function: disabled],
    enable: [Function: enable],
    disable: [Function: disable],
    acl: [Function (anonymous)],
    bind: [Function (anonymous)],
    checkout: [Function (anonymous)],
    connect: [Function (anonymous)],
    copy: [Function (anonymous)],
    delete: [Function (anonymous)],
    get: [Function (anonymous)],
    head: [Function (anonymous)],
    link: [Function (anonymous)],
    lock: [Function (anonymous)],
    'm-search': [Function (anonymous)],
    merge: [Function (anonymous)],
    mkactivity: [Function (anonymous)],
    mkcalendar: [Function (anonymous)],
    mkcol: [Function (anonymous)],
    move: [Function (anonymous)],
    notify: [Function (anonymous)],
    options: [Function (anonymous)],
    patch: [Function (anonymous)],
    post: [Function (anonymous)],
    propfind: [Function (anonymous)],
    proppatch: [Function (anonymous)],
    purge: [Function (anonymous)],
    put: [Function (anonymous)],
    rebind: [Function (anonymous)],
    report: [Function (anonymous)],
    search: [Function (anonymous)],
    source: [Function (anonymous)],
    subscribe: [Function (anonymous)],
    trace: [Function (anonymous)],
    unbind: [Function (anonymous)],
    unlink: [Function (anonymous)],
    unlock: [Function (anonymous)],
    unsubscribe: [Function (anonymous)],
    all: [Function: all],
    del: [Function (anonymous)],
    render: [Function: render],
    listen: [Function: listen],
    request: IncomingMessage { app: [Circular *1] },
    response: ServerResponse { app: [Circular *1] },
    cache: {},
    engines: {},
    settings: {
      'x-powered-by': true,
      etag: 'weak',
      'etag fn': [Function: generateETag],
      env: 'development',
      'query parser': 'extended',
      'query parser fn': [Function: parseExtendedQueryString],
      'subdomain offset': 2,
      'trust proxy': false,
      'trust proxy fn': [Function: trustNone],
      view: [Function: View],
      views: '/Users/a80118535/Desktop/mongodb/back/views',
      'jsonp callback name': 'callback'
    },
    locals: [Object: null prototype] {
      settings: {
        'x-powered-by': true,
        etag: 'weak',
        'etag fn': [Function: generateETag],
        env: 'development',
        'query parser': 'extended',
        'query parser fn': [Function: parseExtendedQueryString],
        'subdomain offset': 2,
        'trust proxy': false,
        'trust proxy fn': [Function: trustNone],
        view: [Function: View],
        views: '/Users/a80118535/Desktop/mongodb/back/views',
        'jsonp callback name': 'callback'
      }
    },
    mountpath: '/',
    _router: [Function: router] {
      params: {},
      _params: [],
      caseSensitive: false,
      mergeParams: undefined,
      strict: false,
      stack: [ [Layer], [Layer], [Layer], [Layer], [Layer] ]
    }
  }
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.headersSent</button></dt><dd>HTTP로 보냈는지 bool</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

앱이 응답에 대해 HTTP 헤더를 보냈는지 여부를 나타내는 부울 속성입니다.


app.get('/', function (req, res) {
    console.dir(res.headersSent) // false
    res.send('OK')
    console.dir(res.headersSent) // true
})
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.locals</button></dt><dd>HTTP로</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
app.use(function (req, res, next) {
    res.locals.user = req.user
    res.locals.authenticated = !req.user.anonymous
    next()
})

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.append()</button></dt><dd>HTTP header에 추가</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">


console.log(res.append('asdasdasd', ['http~']))


[Symbol(kOutHeaders)]: [Object: null prototype] {
    'x-powered-by': [ 'X-Powered-By', 'Express' ],
    asdasdasd: [ 'asdasdasd', [Array] ]
}

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.attachment()</button></dt><dd>HTTP header에 파일정보</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
.attachment([filename])

res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png



// return value
[Symbol(kOutHeaders)]: [Object: null prototype] {
    'x-powered-by': [ 'X-Powered-By', 'Express' ],
    'content-type': [ 'Content-Type', 'image/png' ],
    'content-disposition': [ 'Content-Disposition', 'attachment; filename="logo.png"' ]
}
  

//응답 헤더에 아래 값 담김 
X-Powered-By                 Express
Content-Type                 image/png; charset=utf-8
Content-Disposition          attachment; filename="logo.png"



http://daplus.net/javascript-express%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-nodejs-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C/

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.cookie()</button></dt><dd>쿠키설정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
.cookie(name, value [, options])

Property	Type	Description
domain	    String	Domain name for the cookie. Defaults to the domain name of the app.
encode	    Function	A synchronous function used for cookie value encoding. Defaults to encodeURIComponent.
expires	    Date	Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.
httpOnly	Boolean	Flags the cookie to be accessible only by the web server.
maxAge	    Number	Convenient option for setting the expiry time relative to the current time in milliseconds.
path	    String	Path for the cookie. Defaults to “/”.
secure  	Boolean	Marks the cookie to be used with HTTPS only.
signed	    Boolean	Indicates if the cookie should be signed.
sameSite	Boolean or String	Value of the “SameSite” Set-Cookie attribute. More information at https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1.1.


ex1)
res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })

ex2)
res
  .status(201)
  .cookie('access_token', 'Bearer ' + token, {
    expires: new Date(Date.now() + 8 * 3600000) // cookie will be removed after 8 hours
  })
  .cookie('test', 'test')
  .redirect(301, '/admin')


ex3)
res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })

res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.clearCookie()</button></dt><dd>쿠키 지우기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
.clearCookie(name [, options])

웹 브라우저 및 기타 호환 클라이언트는 만료 및 maxAge를 제외하고 주어진 옵션이 res.cookie()에 제공된 옵션과 동일한 경우에만 쿠키를 지웁니다.

res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.download()</button></dt><dd>파일 내려주기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
download(path [, filename] [, options] [, fn])
-


ex1) 
app.get('/download', function(req, res){
    const file = `${__dirname}/upload-folder/dramaticpenguin.MOV`;
    res.download(file); // Set disposition and send it.
});

res.setHeader('Content-disposition', 'attachment; filename=dramaticpenguin.MOV');
res.setHeader('Content-type', 'video/quicktime');


ex2)
res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', function (err) {
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
})
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.send()</button></dt><dd>응답</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.send([body])
send에 전해진 argument에 따라서 Content-type이 자동적으로 만들어진다. 이게 기본이다.

res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('&lt;p&gt;some html&lt;/p&gt;')
res.status(404).send('Sorry, we cannot find that!')
res.status(500).send({ error: 'something blew up' })


res.set('Content-Type', 'text/html')
res.send(Buffer.from('&lt;p&gt;some html&lt;/p&gt;'))



결론적으로 말하면 res.send()와 res.json()은 별반 다를게 없다.

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.sendFile()</button></dt><dd>파일 응답</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.sendFile(path [, options] [, fn])

주어진 경로에서 파일을 전송합니다. 파일 이름 확장자를 기반으로 Content-Type 응답 HTTP 헤더 필드를 설정합니다. 
옵션 개체에 루트 옵션이 설정되어 있지 않으면 경로는 파일의 절대 경로여야 합니다.
express v4.8.0 이상에서 지원



app.get('/file/:name', function (req, res, next) {
    var options = {
      root: path.join(__dirname, 'public'),
      dotfiles: 'deny',
      headers: {
        'x-timestamp': Date.now(),
        'x-sent': true
      }
    }
  
    var fileName = req.params.name
    res.sendFile(fileName, options, function (err) {
      if (err) {
        next(err)
      } else {
        console.log('Sent:', fileName)
      }
    })
  })

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.sendStatus()</button></dt><dd>상태 응답</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.sendStatus(404)

res.statusCode가 잘못된 HTTP 상태 코드(100~599 범위를 벗어남)로 설정되면 Node.js의 일부 버전에서 오류가 발생합니다. 
사용 중인 Node.js 버전에 대한 HTTP 서버 문서를 참조하십시오.


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.json()</button></dt><dd>josn 응답</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

res.json([body])

json이 아닌 것도 json 형식으로 바꾸어서 보내준다. 즉 content-type 헤더를 application/JSON으로 고정한다. 그런데 결국 res.json()도 마지막에 res.send()를 호출한다.


res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.jsonp()</button></dt><dd>josnp 응답.. cross-domain</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

res.jsonp([body])
Cross-domain 이슈 해결용
JSONP 지원으로 JSON 응답을 보냅니다. 이 메서드는 JSONP 콜백 지원을 선택한다는 점을 제외하고 res.json()과 동일합니다.

res.jsonp(null)
// => callback(null)

res.jsonp({ user: 'tobi' })
// => callback({ "user": "tobi" })

res.status(500).jsonp({ error: 'message' })
// => callback({ "error": "message" })


기본적으로 JSONP 콜백 이름은 단순히 콜백입니다. 이것을 jsonp 콜백 이름 설정으로 재정의하십시오.
다음은 동일한 코드를 사용하는 JSONP 응답의 몇 가지 예입니다.


// ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// => foo({ "error": "message" })



//http://sugerent.tistory.com/424

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.end()</button></dt><dd>응답</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.end([data] [, encoding])

사실 이 메소드는 안써도 된다. 
문서를 읽어보면 보내줄 데이터가 없을 때 사용한다고 되어있는데, 
주로 예를 드는게 404를 리턴해주어야 할 때이다. 그리고 res.json()을 쓰나 res.send()를 쓰나 
응답을 종료해주는 역할은 하기 때문에 굳이 명시적으로 표시해줄 필요는 없다.

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.status()</button></dt><dd>응답 값</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.status(code)

res.status(403).end()
res.status(400).send('Bad Request')
res.status(404).sendFile('/absolute/path/to/404.png')


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.get()</button></dt><dd>HTTP header 값 가져오기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.get(field)
필드에서 지정한 HTTP 응답 헤더를 반환

res.get('Content-Type')
// => "text/plain"




                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.set()</button></dt><dd>HTTP header 값 설정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.set(field [, value])


res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})



Aliased as res.header(field [, value]).



                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.redirect()</button></dt><dd>리다이렉트</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.redirect([status,] path)
클라이언트로 응답값과 함께 리다이렉트 보내기 


res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')






ex1) 
app.get('/category', function(req, res) {
    var string = encodeURIComponent('something that would break');
    res.redirect('/?valid=' + string);
});



ex2) 
const url = require('url');    
app.get('/category', function(req, res) {
    res.redirect(url.format({
       pathname:"/",
       query: {
          "a": 1,
          "b": 2,
          "valid":"your string here"
        }
     }));
 });
//So if you want to redirect all req query string variables you can simply do

res.redirect(url.format({
       pathname:"/",
       query:req.query,
     });
 });
//And if you are using Node >= 7.x you can also use the querystring core module

const querystring = require('querystring');    
app.get('/category', function(req, res) {
      const query = querystring.stringify({
          "a": 1,
          "b": 2,
          "valid":"your string here"
      });
      res.redirect('/?' + query);
 });

 
ex3) 세션사용 
app.get('/category', function(req, res) {
    req.session.valid = true;
    res.redirect('/');
  });
  
  //And later on after the redirect...
  
  app.get('/', function(req, res) {
    var passedVariable = req.session.valid;
    req.session.valid = null; // resets session variable
    // Do something
  });

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.render()</button></dt><dd>client로 렌더링해서 보냄</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// send the rendered view to the client
res.render('index')

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function (err, html) {
    res.send(html)
})

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function (err, html) {
    // ...
})




function(req, res){
    res.render('index', { title: 'Express' });
});

res.render('index', { title: 'Express' }) 는
서버가 클라이언트에게 index.ejs를 렌더링하여 보내겠다는 의미이다.

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.links()</button></dt><dd>header에 links 추가</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.links(links)
응답의 링크 HTTP 헤더 필드를 채우기 위해 매개변수의 속성으로 제공된 링크를 결합합니다.


res.links({
    next: 'http://api.example.com/users?page=2',
    last: 'http://api.example.com/users?page=5'
  })


  Yields the following results:
  Link: &lt;http://api.example.com/users?page=2&gt;; rel="next",
        &lt;http://api.example.com/users?page=5&gt;; rel="last"

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.location()</button></dt><dd>HTTP Location header 지정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
location(path)
응답 Location HTTP 헤더를 지정된 경로 매개변수로 설정합니다.

res.location('/foo/bar')
res.location('http://example.com')
res.location('back')



//postman headers
//Location       http://example.com/path/to/logo.png

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.format()</button></dt><dd>포맷지정 ?</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.format(object)

있는 경우 요청 개체의 Accept HTTP 헤더에 대해 콘텐츠 협상을 수행합니다. 
req.accepts()를 사용하여 품질 값으로 정렬된 수용 가능한 유형을 기반으로 요청에 대한 핸들러를 선택합니다. 
헤더를 지정하지 않으면 첫 번째 콜백이 호출됩니다. 
일치하는 항목이 없으면 서버는 406 "Not Acceptable"로 응답하거나 기본 콜백을 호출합니다.

Content-Type 응답 헤더는 콜백이 선택될 때 설정됩니다. 그러나 res.set() 
또는 res.type()과 같은 메서드를 사용하여 콜백 내에서 이를 변경할 수 있습니다.

다음 예는 Accept 헤더 필드가 "application/json" 또는 "*/json"으로 설정된 경우 
{ "message": "hey" }로 응답합니다(그러나 "*/*"인 경우 응답은 "야").


res.format({
    'text/plain': function () {
      res.send('hey')
    },
  
    'text/html': function () {
      res.send('&lt;p&gt;hey&lt;/p&gt;')
    },
  
    'application/json': function () {
      res.send({ message: 'hey' })
    },
  
    default: function () {
      // log the request and respond with 406
      res.status(406).send('Not Acceptable')
    }
})


정규화된 MIME 유형 외에도 약간 덜 장황한 구현을 위해 이러한 유형에 매핑된 확장 이름을 사용할 수도 있습니다.

res.format({
    text: function () {
        res.send('hey')
    },

    html: function () {
        res.send('&lt;p&gt;hey&lt;/p&gt;')
    },

    json: function () {
        res.send({ message: 'hey' })
    }
})

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.type()</button></dt><dd>HTTP header 타입</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.type(type)


res.type('.html')
// => 'text/html'
res.type('html')
// => 'text/html'
res.type('json')
// => 'application/json'
res.type('application/json')
// => 'application/json'
res.type('png')
// => 'image/png'

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>res</span>.vary()</button></dt><dd>response header 필드 추가</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
res.vary(field)
필드가 아직 없는 경우 Vary 응답 헤더에 필드를 추가합니다.

res.vary('User-Agent').render('docs')
                        </code>
                    </pre></div></div></div><div class="depth_2"><strong>Router</strong><div class="item_wrap"><dl class="item"><dt><button><span>router</span>.all()</button></dt><dd>해당 파일 router 모두 설정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
해당 라우터 모두 설정하기
router.all(path, [callback, ...] callback)

router.all('*', requireAuthentication, loadUser)
router.all('*', requireAuthentication)
router.all('*', loadUser)
router.all('/api/*', requireAuthentication)




router.all('*', (req, res, next) => {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "X-Requested-With");
    res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
    res.header("X-Powered-By",' 3.2.1')
    res.header("Content-Type", "application/json;charset=utf-8");
    next();
   });
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>router</span>.METHOD()</button></dt><dd>HTTP method</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
router.METHOD(path, [callback, ...] callback)

GET, POST, DELETE, PUT ...등등 



router.get('/', function (req, res) {
    res.send('hello world')
})


router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function (req, res) {
    var from = req.params[0]
    var to = req.params[1] || 'HEAD'
    res.send('commit range ' + from + '..' + to)
})




                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>router</span>.param()</button></dt><dd>param 지정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
router.param(name, callback)


var express = require('express')
var app = express()
var router = express.Router()

// customizing the behavior of router.param()
router.param(function (param, option) {
  return function (req, res, next, val) {
    if (val === option) {
      next()
    } else {
      res.sendStatus(403)
    }
  }
})

// using the customized router.param()
router.param('id', '1337')

// route to trigger the capture
router.get('/user/:id', function (req, res) {
  res.send('OK')
})

app.use(router)

app.listen(3000, function () {
  console.log('Ready')
})
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>router</span>.route()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
router.route(path)

선택적 미들웨어로 HTTP 동사를 처리하는 데 사용할 수 있는 단일 경로의 인스턴스를 반환합니다. 
라우터 이름이 중복되어 입력 오류가 발생하지 않도록 하려면 router.route()를 사용하십시오.

위의 router.param() 예제를 기반으로 하는 다음 코드는 router.route()를 사용하여 
다양한 HTTP 메서드 핸들러를 지정하는 방법을 보여줍니다.

var router = express.Router()

router.param('user_id', function (req, res, next, id) {
    // sample user, would actually fetch from DB, etc...
    req.user = {
    id: id,
    name: 'TJ'
    }
    next()
})

router.route('/users/:user_id')
    .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
    next()
    })
    .get(function (req, res, next) {
    res.json(req.user)
    })
    .put(function (req, res, next) {
    // just an example of maybe updating the user
    req.user.name = req.params.name
    // save user ... etc
    res.json(req.user)
    })
    .post(function (req, res, next) {
    next(new Error('not implemented'))
    })
    .delete(function (req, res, next) {
    next(new Error('not implemented'))
    })

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>router</span>.use()</button></dt><dd>미들웨어 붙이기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
router.use([path], [function, ...] function)
app.use()와 비슷.. 

선택적 마운트 경로 경로와 함께 지정된 미들웨어 기능을 사용하며 기본값은 "/"입니다.
이 메소드는 app.use()와 유사합니다. 간단한 예와 사용 사례가 아래에 설명되어 있습니다. 
자세한 내용은 app.use()를 참조하세요.

미들웨어는 배관 파이프와 같습니다. 요청은 정의된 첫 번째 미들웨어 기능에서 시작하여 
일치하는 각 경로에 대해 미들웨어 스택 처리 "아래로" 작동합니다.
                        </code>
                    </pre></div></div></div></section><section class="conts"><h2>Pakage</h2><div class="depth_2"><strong>multer</strong><div class="item_wrap"><dl class="item"><dt><button><span>multer</span> 사용방법</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

`기본적인 흐름 
1. front에서 backend로 이미지를 post로 보냄 (postman  body -> form-data -> key에 위에 미들웨어와 동일한 키값 image넣음)
2. dest 설정을 하면 back에 upload 폴더가 생겨서 프론트에서 보낸 이미지가 여기 저장됨 (or diskStorage 사용)

`                            


import express from 'express';
import multer from 'multer';
import { v4 } from 'uuid';
import mime from 'mime-types'; //file type 지정




// 아래로 수정 const upload = multer({ dest: "uploads" }) //dest: 업로드할 경로. 자동으로 생성됨
const storage = multer.diskStorage({ //파일의 고유아이디 저장을 컨트롤 하기 위해 
    destination: (req, file, cb) => cb(null, "./uploads"),
    filename: (req, file, cb) => {cb(null, `${v4()}.${mime.extension(file.mimetype)}`);}
})
/*
req: request 정보 
file: 파일정보 
cb: 콜백
destionation: 어디에 저장할지 
filename: 어떤 이름으로 저장할지
*/

const upload = multer({ 
    storage, 
    fileFilter: (req, file, cb) => {
        if(['image/jpeg', 'image/png', 'image/jpg'].includes(file.mimetype)) {
            return cb(null, true)
        } else {
            return cb(new Error('invalid file type'), true) //처음: 오류, 두번째 불리언값 true=저장.
        };
       
    },
    limits: {
        fileSize: 1024 * 1024 * 5, //1024 * 1024 = 1mb 
    },
})


const app = express();
const PORT = 5000;

app.use('/uploads', express.static('uploads')) //http://localhost:5000/uploads/ae791f20-ca35-4e95-919b-655d94791127.jpeg 이거 접근됨...이거 없음 접근안됨



app.post('/upload', upload.single("image"), (req, res) => { 
    //post로 이미지를 보낼때 이미 req에 저장이 되어있음. upload(미들웨어)를 이용해서 저장된 이미지 가져옴 
    // postman  body -> form-data -> key에 위에 미들웨어와 동일한 키값 image넣음
    
    console.log(req.file)
    res.json(req.file);
})

  


app.listen(PORT, () => console.log('express server listening port ' + PORT))
                        </code>
                    </pre></div></div></div><div class="depth_2"><strong>bcrypt</strong><div class="item_wrap"><dl class="item"><dt><button><span>bcrypt</span> 사용방법</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

`기본적인 흐름 
1. 회원가입때 받은 비번을 해시화함 bcrypt.genSalt  bcrypt.hash
2. 해시화해서 db에 저장 
3. 로그인 할 때 db에서 가져온 해시암호를 client에서 받은 비번과 비교함 bcrypt.compare(받은비번, db비번)
4. 맞으면 인증성공
`
  

// register
router.post('/', async (req, res) => {
    try {
        const { id, password, email, name } = req.body;
        const user = await new User({ id, password, email, name })

        bcrypt.genSalt(10, (err, salt) => {
            bcrypt.hash(user.password, salt, (err, hash) => {
                if(err) throw new Error(err);
                user.password = hash
               
                user.save().then(user => {
                    console.log('then user:', user)
                    res.status(201).json({ user })  
                })
            })
        })

    } catch(err) {
        console.error(err)
    }
})



// login
router.post('/login', async (req, res) => {
    try {
        const { _id, id, password } = req.body
        const user = await User.findOne({ id: id }) 
        
        const match = await bcrypt.compare(password, user.password);
        if(!match) return res.status(400).json({ err: "비밀번호 불일치" })
        if(match) {
            jwt.sign({ _id: _id }, process.env.JWT_KEY, { expiresIn: "2 days" }, (err, token) => {
                if(err) throw new Error(err)
                res.status(201).json({
                    token,
                    _id: user._id, 
                    id: user.id,
                    email: user.email,
                    name: user.name,
                });
            });
        };
    } catch(err) {
        console.error(err)
    }
})




// edit password 
router.post('/:username/profile', async(req, res) => {
    try{
        const { prevPassword, password, checkPassword, userId } = req.body;
        const user = await User.findById(userId, 'password');
        const match = await bcrypt.compare(prevPassword, result.password)
     

        if(!isMatch) return res.status(400).json({match_error: '기존 비밀번호가 다릅니다'}).
        if(password !== checkPassword) return res.status(400).json({ error: "새로운 비밀번호가 다릅니다" })


        if(password === checkPassword) {
            bcrypt.genSalt(10, (err, salt) => { //salt 로 만들어줌 2의 10승으로 ..그 다음 반환된 salt를 해시로 만들어줌
                bcrypt.hash(password, salt, (err, hash) => { 
                    if(err) throw err;
                    user.password = hash;
                    user.save();
                })
            })

            res.status(200).json({ success: "비밀번호 변경 완료" });
        }

    } catch(err) {
        console.log(err)
    }
})





                        </code>
                    </pre></div></div></div><div class="depth_2"><strong>json web token</strong><div class="item_wrap"><dl class="item"><dt><button><span>jwt</span> 사용방법</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

`기본적인 흐름 
1. bcrypt에서 해시화된 값(db)과 입력받은(client) 값이 같다면 
2. jwt을 이용해서 특정값(_id값으로 하는게 편함)을 token 생성 후 client로 response. jwt.sign()

3. client에서는 받은 token을 쿠키나 로컬저장소에 저장해두고 
4. api호출에 인증이 필요하다면 request할 때 token값을 header에 실어서 보냄  

5. bakcend에서 req.header로 token값을 받아 decode함  jwt.verify(token, jwt_key)
6. 5번에서 리턴된 값으로 유저를 찾아 리턴해주거나 로그인 유지 등 이후 로직 실행 
`


` 사용방법
jwt.sign(payload, secret, options, [callback])


https://github.com/auth0/node-jsonwebtoken
`



// auth.js 커스텀 미들웨어 
import jwt from 'jsonwebtoken'; 
export const auth = async (req, res, next) => {
    try {
        const token = req.header('x-access-token') //client token
        const match = jwt.verify(token, process.env.JWT_KEY)
         //{ _id: '627c7b6cad3ac52d28a40418', iat: 1652419267 }

        if(match) {
            req.user = match;
            next()
        } 
    } catch(err) {
        res.status(400).json({ err: 'is not user or token' })
        console.error(err)
    }
}



// jwt auth test
router.post('/test', auth, async (req, res) => { // 여기서 auth 미들웨어가 에러나면 catch로
    try {
        const findUser = await User.findOne({ _id: req.user._id })
        res.status(200).json({ findUser })
        
        console.log('last line test api: ', req.user._id) // auth 미들웨어에서 req.user에 담아줌 
    } catch(err) {
        console.error(err)
    }
})



                        </code>
                    </pre></div></div></div></section><section class="conts"><h2>Node</h2><div class="depth_2"><strong></strong><div class="item_wrap"><dl class="item"><dt><button><span>path</span> 사용방법</button></dt><dd>es6 type module일 때 파일경로 찾기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
import path from 'path'
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename); 
const __dirname2 =path.resolve(); 

// __dirname
//C:\Users\user.SH80095621\Desktop\ipt\back\middleware 현재 경로

// __dirname2
//C:\Users\user.SH80095621\Desktop\ipt\back\  최초디렉토리
                        </code>
                    </pre></div></div></div></section></div></main><footer><div class="global_wrap"><ul class="info">asdasdsa</ul></div></footer></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>