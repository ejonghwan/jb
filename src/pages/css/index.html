<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Document</title><script defer="defer" src="../../../main.c4114316382a1cac31f9.js"></script><link href="../../../main.css" rel="stylesheet"></head><body><div class="wrap"><header><nav class="global_wrap sub"><ul class="line"></ul></nav></header><main><div class="global_wrap"><section class="conts"><p>1. 성능 측성 검사 <a href="https://pagespeed.web.dev/" target="_blank" title="새창">https://pagespeed.web.dev/</a></p><p>2. 구글 크롬 라이트하우스</p><p>3. font최적화 <a href="https://d2.naver.com/helloworld/4969726">d2 naver blog post</a></p><p>4. 브라우저 렌더링 <a href="https://d2.naver.com/helloworld/59361">d2 naver blog post</a></p></section><section class="conts"><h2>Performance</h2><div class="depth_2"><strong>css optimization</strong><div class="item_wrap"><dl class="item"><dt><button>16.6666666 <span>ms</span></button></dt><dd>모니터 주사율과 로드 속도</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
모니터는 1초에 깜빡이는 속도가 있는데 이걸 fps라고 하며 
모니터의 주사율은 각 모니터마다 다르지만 1초에 60fps로 잡는다면

한번 깜빡일 때 컨텐츠가 그려져야 덜 덜컥거림
한번 깜빡이는 건  1000ms / 60 = 16.666666ms...

즉 일정하게 16.6ms 마다 로드가 되야 사람들 눈에 자연스럽게 보인다 

ex) 
0          ~           60
||||||||||||||||||||||||

이렇게 모두 16ms이면 자연스럽게 화면에 표시되어 상관없지만  

0            ~                60
||||||| |||||||    ||||||||||
      20ms     30ms             

어떤 특정 엘리먼트들의 로드시간이 16ms를 넘어간다면 사용자는 저렇게 띄엄띄엄 부자연스러운 화면을 보게 될 것임
    
    </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>메모리 누수</button></dt><dd>가비지 콜렉터</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
자바스크립트는 가비지콜렉팅 언어로 사용하지 않는 것들은 가비지 콜렉터가 없애줌... 
하지만 원하지 않은 참조로 몇가지 경우로 없애지 않을 때가 있는데...  

1. 전역변수 
2. 해제되지 않은 타이머, 콜백
3. 돔 외부에서 참조 
4. 클로저 잘못 사용
    
    </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>불필요한 CSS 제거</button></dt><dd>불필요한 CSS를 제거 했는가 ?</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
#remove unused css
- Remove unused CSS 구글 라이트하우스는 2KB 이상 미사용 CSS가 포함된 파일을 검출해서 오류로 체크함. coverage 탭에 상세확인가능
* 폰트는 사용하지않는 CSS로 구분하는 오류가있음
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>렌더차단 리소스 제거</button></dt><dd>렌더차단 리소스를 제거 했는가 ?</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# render blocking
- CSS는 기본적으로 렌더차단 리소스라고 부르는데 웹 브라우저가 CSS파일을 만나면 다운로드하고 CSS를 해석하는 동안 렌더를 잠깐 멈춤
(이건 CSSOM 그릴 때 말하는건가 ..? 확인필요)
- 라이트하우스에서 Eliminate render-blocking resources 탭


# 해결방법 
1. 스크립트는 돔파싱 후 가져오기 ..해더에 디퍼,어싱크없는 스크립트들 
2. media 속성이 없는 link rel="stylesheet" 태그



# JS 해결방법 
## no async no defer 
1. html 파싱하다 js 만나면 멈춤
2. js 다운로드 후 해석, 실행 
3. 다시 html 파싱 시작 

## async : 병렬 다운로드, 즉시실행 
1. html 파싱하다 js 만나면 파싱하면서 다운로드 같이진행
2. js 다운로드 끝나면 html 파싱 멈추고 js 실행
3. 다시 남은 html 파싱 

## defer : 병렬 다운로드, 지연실행 
1. html 파싱하다 js를 만나도 파싱하면서 다운로드하고 
2. html 파싱이 끝나면 js를 해석, 실행


결론: defer를 안넣을거면 무적권 아래다 넣는게 좋음...왜냐면 다운로드할때 html 파싱을 멈추기때문. 혹은 아래다 넣고 async 넣거나... 

1. 필수 스크립트는 html에 &lt;script&gt; 형식으로 작성
2. 기타 스크립트는 &lt;scrip&gt; 종료 태그 직전에 선언 
3. 마지막에 파싱해도 문제 없으면 defer 속성 
4. 가능한 빠른 시점에 실행 필요하면 async 속성


# CSS 해결방법
rel="stylesheet" : media 속성이 없거나 
rel="stylesheet" : media="all" all 이거나 

위처럼 하면 렌더 차단 리로스임....모든 상황에서 차단되기 떄문에  


## 방법 1
* 아래처럼 특정조건에서만 해석하도록 해야됨 
media="print"
media="screen"
media="orientation:portrait" 

* 분기별로 각자에 맞는 파일 다운로드하게 만듦
&lt;link rel="stylesheet" href="" media="(max-width: 639px)"&gt; 
&lt;link rel="stylesheet" href="" media="(min-width: 640px) and (max-width: 960px)"&gt; 
&lt;link rel="stylesheet" href="" media="(min-width: 961px)"&gt; 


## 방법 2
1. 필수 스타일을 head 안에 style로 작성
2. 지연 스타일은 &lt;link rel="preload"&gt; 속성으로 병렬 로딩 후 지연 적용
예시) &lt;style>/*필수 스타일은 여기*/&lt;/style&gt;
&lt;link rel="preload" href="" as="style" onload="this.onload=null; this.rel='stylesheet'" /&gt; //로드후 렐바꿈. 지연로딩
- this.onload=null 할당이유? 
  rel속성을 변경할 때 일부 브라우저가 다시 onload를 실행하는 것을 방어 함
 

*rel="preload" 에 관한 블로그 
https://runebook.dev/ko/docs/html/preloading_content 


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>LCP <span>로딩속도</span></button></dt><dd>큰컨텐츠 빨리 그리기</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# LCP <span class="seg">(Largest Contentful Paint).. 큰덩어리 콘텐츠 그리기</span>
- 구글의 핵심 성능 지표에 포함되는 한 가지 항목
- 모든 성능에 관련된 지식으로 개선해야 높아짐


# 목표
- LCP를 2.5초 이내로 단축시키는게 목표 


# 맨 처음 생기는 덩어리.. 
- 라이트 하우스에 콘텐츠가 포함된 최대 페인트 요소 탭
- 주로 이미지가 가장 큰 컨텐츠일 가능성이 높음(히어로이미지) 
* 맨 처음뜨는 이미지가 무겁기 때문은 아니고 
  이미지를 브라우저가 그리기전에 생기는 
  모든 성능이슈가 LCP 문제를 해결하는 열쇠임 


성능개선 사례 
before - https://t.ly/tyMg 
after - https://t.ly/a7uy


# 해결방법 
## 1. 라이브러리 의존 줄이기
- jquery, lodash, mormalize, reset.css...등 내가 사용하지않는 기능을 포함하고 있기에 렌더차단 리소스로 작용할 확률이 높음
- jquery가 FCP(first content paint)를 엄청나게 지연시킴 
- https://youmightnotneed.com/ (바닐라로 작업된 내용물들 좀 있음)


## 2. 사용하지않는 css 제거


## 3. preconnect / preload
- css를 그냥 링크하면 css 읽을 때 렌더링 멈춤
(x) ? 이거도 병렬인데 ... 그냥 preload가 더 좋은가봄
&lt;link rel="stylesheet" href="*.css"&gt; 

(o)
&lt;link rel="preconnect" href="https://fonts.gataic.com"&gt; 
- href에 연결된 주소를 미리 연결하는 기능..미리 연결해서 준비해뒀다 필요한 내용을 다운로드함 
- 도메인을 알지만 자원의 최종 경로를 모르는 경우 서버와의 연결을 미리 설정 
- DNS, TCP, TLS 왕복에 필요한 시간을 단축 
- 서드파티 자원 연결에 적합..구글웹폰트 등

&lt;link rel="preload" as="style" href="*.css" onload="this.onload=null; this.rel='stylesheet'"&gt;
- css파일은 다운로드하면서 웹페이지 렌더링을 차단하지않음. 동시에 진행..그리고 로드 후 지연적용함
- img js 등 다양한 파일들을 병행 로드할 수 있음  as는 필수. as="script" as="image"


!! 주의점은 리소스의 사전로드와 병렬진행이 무조건적으로 빠르진 않다 ...(html 파싱 막는 리소스다운로드 제외.. 리소스끼리)
이미지 리소스를 병렬진행하면 다운로드가 느려질 수 있기 때문에 
꼭 필요한 이미지부터 사전로드와 병렬진행하고 나머지 이미지는 레이지 로드나 직렬진행하는게 오히려 더 빠를 수 있다 




## 4. 히어로 이미지 preload... LCP중 img를 미리 다운로드받아둠
&lt;head&gt;
&nbsp;    &lt;link rel="preload" as="image" media="(max-width:640px)" href="small.avif"&gt;
&nbsp;    &lt;link rel="preload" as="image" media="(min-width:641px)" href="large.avif"&gt;
&lt;/head&gt;


## 5. feature detection 
- image type 이나 viewport width를 감지해서 성능을 개선
&lt;picture&gt;
&nbsp;    &lt;source srcset="small.avif" type="image/avif" media="(max-width:640px)"&gt;
&nbsp;    &lt;source srcset="large.avif" type="image/avif"&gt;
&nbsp;    &lt;source srcset="small.webp" type="image/webp" media="(max-width:640px)"&gt;
&nbsp;    &lt;source srcset="large.webp" type="image/webp"&gt;
&nbsp;    &lt;img src="small.jpg" alt&gt;
&lt;/picture&gt;


## 6. image loading / decoding
- 이미지 지연로딩

&lt;img src="x.jpg" alt&gt; (x)
&lt;img src="x.jpg" alt loading="lazy" decoding="async"&gt; (o)

loading="lazy" - 뷰포트안에 없으면 로딩하지않음.. 스크롤하면 그때 로딩 
decoding="async" - decoding: 암호화했던 이미지를 복호화함. async값을 주면 화면에 다른 요소를 렌더링하는걸 중단하지않고 다른 요소를 먼저 표시 후 이미지를 뒤늦게 화면에 표시...(다른콘텐츠 표시 속도 빨라짐)

* img 요소에만 사용..picture, source에는 사용하지않음




## 7. css import vs link 
import : 엣지에서 문제발생. 직렬 
link : 병렬, 사전로드 가능 

결론: link를 쓰자

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>FID</button></dt><dd>사용자의 행동에 대해 실제로 이벤트 핸들러가 반응하기까지 걸리는 시간</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# FID <span class="seg">first input delay === total blocking time</span>

100ms 이내가 양호....

사용자의 행동에 대해 실제로 이벤트 핸들러가 반응하기까지 걸리는 시간.. 

사용자가 이벤트를 발생시켰을 때 메인스레드가 다른 작업중이라면 해당 작업을 끝내고 실행이 될텐데 그 시간을 말함

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>CLS</button></dt><dd>로드시점에서 덜컥거림..기존 레이아웃 변경</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# CLS <span class="seg">(cumulative layout shift)</span>
- 사용자 경험을 측정하는 대표적인 지표
- 구글의 검색결과에 반영됨
- 0.1 이내로 단축


# 사례
- 뒤늦게 돔이 추가되거나 배치가 변경되면서 사용자가 다른 버튼을 누르는 사례
- FOIT(font of invisible text) : 텍스트가 보이지 않다가 갑자기 화면에 나타남 
- FOUT(font of unstyled text) : 스타일없다가 갑자기 웹폰트 스타일로 바뀌는 사례
- 치수를 알 수 없는 이미지 로딩
- 동적으로 추가된 돔
- 웹폰트 swap 페인팅


# 목표
라이트하우스 Cumulative Layout Shift 0~1 중 0.1 이내로 단축
* 개발자도구 퍼포먼스 > Experience > summary 탭에서도 확인가능



# 해결방법 
## 1. 자리표시자 활용
- 동적으로 표현되는 컨텐츠에는 들어올 자리를 미리 잡아놓음
.class { min-height: 100px; background: silver; }


- 애니메이션은 transform 속성으로 사용



- 이미지/영상 요소에 비율 힌트 제공.. 이미지에 width height 넣어줘야함

이미지 
&lt;img src="" alt="" width="800" height="800"&gt; (o)
+
max-width: 100%;
height: auto;

* 웹브라우저는 이미지의 width, height로 비율을 계산하기떄문에 css로 하더라도 넣어주는게 좋음. 비록 로딩 후 해당 사이즈로 보이지않더라도 ..


영상
.utube {position: relative; padding-top: 56.25%}
.utube__iframe { position: absolute; width: 100%; height: 100%; top:0 }
*패딩탑을 %로 설정하는 것은 부모의 너비값을 기준으로 패딩 비율이 결정됨



## 2. 웹 폰트 대체 글꼴
- 줄간격이나 자간 장평 이런것들이 달라지면서 흔들리는 것을 방지

- 내가 지금  쓰는 웹폰트랑 비슷한 글꼴을 찾아서 시스템폰트에 적용해야함....
font-family: 'Noto sans KR', sans-serif; (x)
font-family: 'Noto sans KR', Verdana (비슷한글꼴), sans-serif; (o)



예제 페이지
before - https://t.ly/w1kp 
after - https://t.ly/itb9


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>FCP <span>로딩속도</span></button></dt><dd>첫 요소가 로드 될 때까지 걸리는 시간</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# FCP <span class="seg">first Contentfull Paint</span>
첫 요소가 랜더링 되기까지 걸리는 시간 ....


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>FMP <span>로딩속도</span></button></dt><dd>사용자에게 의미있는 컨텐츠 로드되기까지의 시간</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button>그 외 참고사항</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">
# 참고한 유툽
https://www.youtube.com/watch?v=A6J74xLWqYg

# 크롬 개발자도구 
https://www.youtube.com/watch?v=cAIo4dEEPuc
https://www.youtube.com/watch?v=toXJLUa7i0Y


# 프로젝트 개선 블로그 
https://velog.io/@jhyj0521/FE-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-feat.-Shall-We-Trip-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8


# 메모리 누수 참고블로그 
https://ohgyun.com/442

# js 최적화 
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization?hl=ko

# 랜더 설명 
https://darrengwon.tistory.com/1332


# 서비스 성격에 따라
1. 넷플릭스 같은 곳은 사용자 상호작용 FID와 메모리, 사용자 입력 안정화 대기시간 중요 
2. 위키디피아, 이 사이트 같은 경우 정보전달이 목적이니 로드되는 속도, cpu 소요시간이 중요 


# 기본환경에서  체크 
크롬 확장프로그램 같은게 많이 깔려있으면 성능체크에 영향이 가니 
시크릿모드에서 측정하는걸 추천 


# 모바일은 모바일에서 피시는 피시환경에서 체크하기 
웹으로 모바일로 체크해도 소용이 없다 ...? 라고함
실제로 모바일로 체크하고 모바일성능체크하면 피시보다 좀 적게나오긴함


- 검색
개발자도구 -> 컨트롤+쉬프트+p   

- 소스내 검색 
mac: 커맨드+옵션+f 
win: 컨트롤+쉬프트+f 

                            </code>
                        </pre></div></div></div></section><section class="conts"><h2>CSS 속성</h2><div class="depth_2"><strong></strong><div class="item_wrap"><dl class="item"><dt><button><span></span>animation</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="markdown">

.class {animation: 이름, 진행시간, 딜레이, 방향, 카운트, 멈추거나 다시 시작, 타이밍함수, 필모드}

1. 이름: test 
2. 진행시간: 애니메이션 진행시간
3. 딜레이: 얼마 후 실행될건지 
4. 방향: 종료되고 진행방향 
- normal: 기본값.. 끝나면 다시 원래위치에서 시작 
- alternate: 순방향 역방향 순방향 역방향 
- reverse: 역방향
- alternate-reverse: 역방향 순방향 역방향 순방향

5. 카운트: 몇번 반복할건지 
- 1 기본값 ~ 숫자 
- infinite: 무한

6. 멈추거나 다시시작: 애니를 멈추거나 다시 시작가능
- running: 재생 
- paused: 정지

7. 타이밍함수: 등속도 
8. 필모드: 시작되기전이나 끝나고 난 후 어떤 값이 적용될건지 
- none: 애니 끝난 후 상태설정 안함 
- forwards: 끝난 후 그 지점에 있음 
- backwards: 애니 후 시작점으로 
- both: 앞 뒤 결과를 조합하여 설정 
- inherit: 애니 상태를 상위 요소한테 상속받음



@keyframes test {
   0% {}
   50% {}
   100% {}
}
                            </code>
                        </pre></div></div></div></section></div></main><footer><div class="global_wrap"><ul class="info">asdasdsa</ul></div></footer></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>