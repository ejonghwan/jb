<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
   
    <title>Document</title>
</head>
<body>

    <div class="wrap">
        <header>
            <nav class="global_wrap sub">
                <ul class="line"></ul>
            </nav>
        </header>
        <main>
            <div class="global_wrap">
                

                       
                <!-- Canvas -->
                <section class="conts">
                    <h2>Canvas</h2>

                    <div class="depth_2">
                        <strong>-</strong>
                   
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>-</button></dt>
                            <dd>
                             -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="javascript">
asd
                            </code>
                        </pre>
                        </div>
                    </div>
                   <!-- item -->
                </div>
              </section>
               <!-- //Canvas -->








              <!-- Three.js -->
              <section class="conts">
                <h2>Three.js</h2>
                <div class="depth_2">
                    <strong>기본 요소들</strong>
                     <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button>구성요소</button></dt>
                        <dd>
                            Mesh(Geometry + Material)  |  Scene  |  Camera  |  Light
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="markdown">
three.js는 아래 구성요소를 가지고 있다 
축 x y z 존재해서 Mesh와 Camera위치가 중요 
- x 축은 오른쪽이 +
- y 축은 위가 +
- z 축은 앞이 +


# Mesh
요소
 - Geometry : 모양
 - Material : 재질


# Scene
장면 무대


# Camera
카메라


# Light
빛 조명

                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span></span>그림자 생성</button></dt>
                        <dd>
                            그림자 생성 시 설정
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
`castShadow: 그림자가 생겨야하는 요소에 설정 `
`receiveShadow: 그림자가 보여지게하는 곳에 요소에 설정` 


1. 랜더러 설정
renderer.shadowMap.enabled = true;

2. 그림자를 만들 수 있게 빛에 설정
light.castShadow = true; 

3. 메시 설정
mesh.castShadow = true; // 박스
mesh3.castShadow = true; // 구
mesh2.receiveShadow = true; // 바닥판


`그림자가 깨져보이는 이유는 맵사이즈 기본값 512로 설정되어있어서.. 
사이즈 너무 키우면 느려짐` 
light.shadow.mapSize.width = 512;
light.shadow.mapSize.height = 512;



`그림자 블러처리`
light.shadow.radius = 10 //이건 renderer 기본값만 적용됨


`그림자 형태 보정`
renderer.shadowMap.type = THREE.PCFShadowMap //기본값 
renderer.shadowMap.type = THREE.BasicShadowMap // 뾰족한 픽셀느낌..성능좋음
// BasicShadowMap으로 설정 후 mapSize를 16정도로 낮추면 마인크래프트 그림자 처럼 됨

renderer.shadowMap.type = THREE.PCFSoftShadowMap // 베이직보다 조금 더 부드러움



`그림자 최적화.. 처리할 곳까지만 그림자 생성`
light.shadow.camera.near = 1
light.shadow.camera.far = 5

                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span></span>레이캐스터</button></dt>
                        <dd>
                            선택한 타겟 지정
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
`
캔버스에서 선택한 공간을 특정할 수 없어서 카메라에서 어떠한 광선을 쏘는데 
모든 오브젝트를 관통하면서 그 위치를 파악 할 수 있음
예를 들어 동그라미 네모 순서대로 있다고 치면 내가 동그라미를 클릭했을 때 
레이캐스터는 동그라미 네모를 모두 관통하며 동그라미를 클릭했다는걸 특정지을 수 있음 
`


ex1) 물체 감지 
// 박스 오브젝트 생성
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const boxMaterial = new THREE.MeshStandardMaterial({ color: '#fff' })
const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
scene.add(boxMesh)
boxMesh.name = 'box'

// 도너츠 오브젝트 생성 
const torusGeometry = new THREE.TorusGeometry(1.5, .5, 20, 50);
const torusMaterial = new THREE.MeshStandardMaterial({ color: '#555' });
const torusMesh = new THREE.Mesh(torusGeometry, torusMaterial)
scene.add(torusMesh)
torusMesh.name = 'torus'


// 감지할 메시들 배열에 넣어둠 
const meshs = [boxMesh, torusMesh]; 


// 레이캐스터 인스턴스 생성
const raycaster = new THREE.Raycaster();



function draw() {
    const delta = clock.getDelta();
    const ElTime = clock.getElapsedTime() 


    // 광선을 아까 그 노란색 라인이랑 똑같이 맞춰주는 작업 
    const origin = new THREE.Vector3(0, 0, 100) //시작점
    const direction = new THREE.Vector3(0, 0, -100) //방향.. 방향은 -100이 아니라 -1 
    direction.normalize() //만약에 방향에 -100을 해주려면 이 메서드로 정규화를 해줘야됨
    raycaster.set(origin, direction) // 레이캐스터 셋팅

     
    // 오브젝트 무빙
    boxMesh.position.y = Math.sin(ElTime) * 3
    boxMesh.material.color.set('#fff')
    torusMesh.position.y = Math.cos(ElTime) * 3
    torusMesh.material.color.set('#fff')


    // 레이캐스트 실행
    const intersects = raycaster.intersectObjects(meshs)
    intersects.forEach(item => {
        item.object.material.color.set('#555')
    })

    renderer.render(scene, camera);
    renderer.setAnimationLoop(draw);
}




ex2) 클릭 감지 
// 박스 오브젝트 생성
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const boxMaterial = new THREE.MeshStandardMaterial({ color: '#fff' })
const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
scene.add(boxMesh)
boxMesh.name = 'box'

// 도너츠 오브젝트 생성 
const torusGeometry = new THREE.TorusGeometry(1.5, .5, 20, 50);
const torusMaterial = new THREE.MeshStandardMaterial({ color: '#555' });
const torusMesh = new THREE.Mesh(torusGeometry, torusMaterial)
scene.add(torusMesh)
torusMesh.name = 'torus'


// 감지할 메시들 배열에 넣어둠 
const meshs = [boxMesh, torusMesh]; 


// 레이캐스터 인스턴스 생성
const raycaster = new THREE.Raycaster();


// mouse 좌표 생성
const mouse = new THREE.Vector2();



canvas.addEventListerner('click', e => {
    // 마우스 좌표를 캔버스와 맞춰주고 
    mouse.x = e.clientX / canvas.clientWidth * 2 - 1
    mouse.y = -(e.clientY / canvas.clientHeight * 2 - 1)

    //레이캐스터 셋팅.. 좌표와 카메라
    raycaster.setFromCamera(mouse, camera) 

    // 레이캐스터 감지 시작 
    const intersects = raycaster.intersectObjects(meshs)
 

    // 브레이크걸려고 포오브로 ..
    for(const item of intersects) {
        console.log(item.object.name)
        
        item.object.material.color.set('red')
        // break
    }
})





` ------- 마우스 드래그 할 때 클릭되는거 방지 ㅎ ------- `


// 마우스 클릭방지 
let mouseClicked;
let mouseTime;
let mouseStartX;
let mouseStartY;

canvas.addEventListener('mousedown', e => {
    mouseClicked = false
    mouseStartX = e.clientX
    mouseStartY = e.clientY 
    mouseTime = Date.now();
})

canvas.addEventListener('mouseup', e => {
    const xgap = Math.abs(e.clientX - mouseStartX)
    const ygap = Math.abs(e.clientY - mouseStartY)

    // 마우스 드래그 한 시간 
    Date.now() - mouseTime > 300 ? mouseTime = true : mouseTime = false;

    // 마우스 이동한 거리
    xgap > 5 || ygap > 5 ? mouseClicked = true : mouseClicked = false;
})


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->

                <br />

                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.Raycaster()</button></dt>
                        <dd>
                            오브젝트 감지
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 박스 오브젝트 생성
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const boxMaterial = new THREE.MeshStandardMaterial({ color: '#fff' })
const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
scene.add(boxMesh)
boxMesh.name = 'box'

// 도너츠 오브젝트 생성 
const torusGeometry = new THREE.TorusGeometry(1.5, .5, 20, 50);
const torusMaterial = new THREE.MeshStandardMaterial({ color: '#555' });
const torusMesh = new THREE.Mesh(torusGeometry, torusMaterial)
scene.add(torusMesh)
torusMesh.name = 'torus'


// 감지할 메시들 배열에 넣어둠 
const meshs = [boxMesh, torusMesh]; 


// 레이캐스터 인스턴스 생성
const raycaster = new THREE.Raycaster();



function draw() {
    const delta = clock.getDelta();
    const ElTime = clock.getElapsedTime() 


    // 광선을 아까 그 노란색 라인이랑 똑같이 맞춰주는 작업 
    const origin = new THREE.Vector3(0, 0, 100) //시작점
    const direction = new THREE.Vector3(0, 0, -100) //방향.. 방향은 -100이 아니라 -1 
    direction.normalize() //만약에 방향에 -100을 해주려면 이 메서드로 정규화를 해줘야됨
    raycaster.set(origin, direction) // 레이캐스터 셋팅

     
    // 오브젝트 무빙
    boxMesh.position.y = Math.sin(ElTime) * 3
    boxMesh.material.color.set('#fff')
    torusMesh.position.y = Math.cos(ElTime) * 3
    torusMesh.material.color.set('#fff')


    // 레이캐스트 실행
    const intersects = raycaster.intersectObjects(meshs)
    intersects.forEach(item => {
        item.object.material.color.set('#555')
    })

    renderer.render(scene, camera);
    renderer.setAnimationLoop(draw);
}










                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.Vector3()</button></dt>
                        <dd>
                            필드에 점 찍음
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
new Vector2(x, y)  //2차원 
new Vector3(x, y, z)  //3차원


import * as Three from 'three'

const vector = new Three.Vector3(0, 0, 100); // z 100정도 앞에 점 하나 찍음 

                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                    <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.Color()</button></dt>
                        <dd>
                            장면에 컬러 설정
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">

import * as Three from 'three'


const scene = new Three.Scene();
const color = new Three.Color('red')
scene.background = color


* 장면은 랜더러보다 위에 있어서 먼저 적용 
* 알파값을 주려면 장면에 컬러주지 말고 랜더러에 줘야됨


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.Clock()</button></dt>
                        <dd>
                           시간
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">

import * as Three from 'three'

/*
autoStart: true
elapsedTime: 0
oldTime: 0
running: false
startTime: 0
*/


const clock = new Three.Clock();

const draw = () => {

    // 이렇게 하면 모니터마다 주사율이 달라서 어떤 곳에선 1초에 60번, 노트북에선 30번 ...다 다를 수 있다
    // mesh.rotation.x += Three.MathUtils.degToRad(.1) 
    

    // 그럴때 clock을 이용해서 절대 시간을 대입하면 어떤 환경에서든 같은 동작을 구현할 수 있다


    const time = clock.getElapsedTime() //여기 안에서는 1초씩 반환 ..
    mesh.rotation.x = 2 * time 
}






                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.Fog()</button></dt>
                        <dd>
                            안개
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
Three.Fog('black', 3, 7) // color, near, far


const scene = new Three.Scene();
scene.fog = new Three.Fog('black', 3, 7)
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.Ling()</button></dt>
                        <dd>
                            라인
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const lineMaterial = new THREE.LineBasicMaterial({ color: 'yellow' })
const points = []; 
points.push(new THREE.Vector3(0, 0, 100))
points.push(new THREE.Vector3(0, 0, -100))
const lineGeometry = new THREE.BufferGeometry().setFromPoints(points)

const guide = new THREE.Line(lineGeometry, lineMaterial)
scene.add(guide)
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                  <!-- item -->
                  <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.Group()</button></dt>
                        <dd>
                            그룹 묶기
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const group1 = new THREE.Group();
const box1 = new THREE.Mesh(geometry, material);

const group2 = new THREE.Group();
const box2 = new THREE.Mesh(geometry, material);
box2.scale.set(.3, .3, .3);
group2.position.x = 2;


const group3 = new THREE.Group();
const box3 = new THREE.Mesh(geometry, material);
box3.scale.set(.1, .1, .1)
group3.position.x = 0.5
group3.position.y = 0.1

group3.add(box3)
group2.add(box2, group3)
group1.add(box1, group2)


scene.add(group1)


const clock = new THREE.Clock();

	function draw() {
		const delta = clock.getDelta();

		group1.rotation.y += delta
		group2.rotation.y += delta
		group3.rotation.y += delta


		renderer.render(scene, camera);
		renderer.setAnimationLoop(draw);
	}
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.TextureLoader()</button></dt>
                        <dd>
                            외부 텍스처 대입
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const textureLoader = new THREE.TextureLoader()
const texture = textureLoader.load(
    './textures/add/c.png',
    () => {console.log('load com')}, 
    () => {console.log('loading...')}, 
    () => {console.log('load error')},
    )


const material1 = new THREE.MeshStandardMaterial({
    map: texture,
});



// 텍스쳐 위치 이동
texture.wrapS = THREE.RepeatWrapping; // 위치이동하고 깨진 텍스쳐를 보완해줌
texture1.wrapT = THREE.RepeatWrapping;
texture.offset.x = 0.3 

// 반복 몇번 할건지도 가능
textrue.repeat.x = 2 

// 이미지 돌리기 
texture1.rotation = Math.PI * 0.25

// 이미지 센터로 
texture1.center.x = 0.5
texture1.center.y = 0.5


// 픽셀이미지 필터 붙이기 
texture4.magFilter = THREE.NearestFilter;




ex) 한 메시에 여러 머테리얼 붙이기 

// load manager
const manager = new THREE.LoadingManager()
manager.onStart = () => console.log('start')
manager.onLoad = () => console.log('load')
manager.onProgress = () => console.log('progress')
manager.onError = () => console.log('error')


// 텍스쳐
const textureLoader = new THREE.TextureLoader(manager)
const texture1 = textureLoader.load('./textures/add/c.png')
const texture2 = textureLoader.load('./textures/add/a.jpg')
const texture3 = textureLoader.load('./textures/add/b.jpg')

const texture4 = textureLoader.load('./textures/mcstyle/right.png')
const texture5 = textureLoader.load('./textures/mcstyle/left.png')
const texture6 = textureLoader.load('./textures/mcstyle/top.png')
const texture7 = textureLoader.load('./textures/mcstyle/bottom.png')
const texture8 = textureLoader.load('./textures/mcstyle/front.png')
const texture9 = textureLoader.load('./textures/mcstyle/back.png')
const materials = [
    new THREE.MeshLambertMaterial({ map: texture4}), 
    new THREE.MeshLambertMaterial({ map: texture5}), 
    new THREE.MeshLambertMaterial({ map: texture6}), 
    new THREE.MeshLambertMaterial({ map: texture7}), 
    new THREE.MeshLambertMaterial({ map: texture8}), 
    new THREE.MeshLambertMaterial({ map: texture9}), 
]

texture4.magFilter = THREE.NearestFilter;
texture5.magFilter = THREE.NearestFilter;
texture6.magFilter = THREE.NearestFilter;
texture7.magFilter = THREE.NearestFilter;
texture8.magFilter = THREE.NearestFilter;
texture9.magFilter = THREE.NearestFilter;


const mesh4 = new THREE.Mesh(geometry1, materials)




                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.CubeTextureLoader()</button></dt>
                        <dd>
                            주변 환경을 비추는 텍스쳐
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">

// cube 
const cubeLoader = new THREE.CubeTextureLoader()
const cubeTexture1 = cubeLoader.setPath('textures/hdr/').load([
    // + -, x y z 순으로 n은 네거티브, p는 포지티브
    'px.png', 'nx.png',
    'py.png', 'ny.png',
    'pz.png', 'nz.png',
])

const material7 = new THREE.MeshStandardMaterial({ //basic 재질은 메탈리스 안줘도 됨.. 지금 빛 적용돼서 잘 안보이는거
    envMap: cubeTexture1,
    metalness: 1,
    roughness: .05,
})

const mesh7 = new THREE.Mesh(geometry1, material7)
scene.add(mesh7)



// 스카이맵... 배경으로 까는 법은 씬 bg에 적용하면 된다

scene.background = cubeTexture1;
    



                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.LoadingManager()</button></dt>
                        <dd>
                            로딩 한번에 해주고 중간 컨트롤 가능
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// load manager
const manager = new THREE.LoadingManager()
manager.onStart = () => console.log('start')
manager.onLoad = () => console.log('load')
manager.onProgress = () => console.log('progress')
manager.onError = () => console.log('error')


// 텍스쳐
const textureLoader = new THREE.TextureLoader(manager)
const texture1 = textureLoader.load('./textures/add/c.png')
const texture2 = textureLoader.load('./textures/add/a.jpg')
const texture3 = textureLoader.load('./textures/add/b.jpg')
                        

const material1 = new THREE.MeshStandardMaterial({
    color: 'hotpink',
    map: texture1,
    
});

const material2 = new THREE.MeshPhongMaterial({
    color: '#ddd',
    map: texture2,
})

const material3 = new THREE.MeshLambertMaterial({
    color: '',
    map: texture3,
})
                        

                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->

                <br />

                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.OrbitControls()</button></dt>
                        <dd>
                            카메라 컨트롤 
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">

import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'

const controls = new OrbitControls(camera, renderer.domElement);


// 장면 아웃할 때 부드럽게 더해지기
controls.enableDamping = true
request animation draw 함수에 controls.update() 함수 실행해줘야함 


// 줌 기능 끄고 키기 
controls.enableZoom = false


// 최대 줌 설정 
controls.maxDistance = 5


// 최소 줌 설정
controls.minDistance = 2


// 위 아래로 회전 하는 각도 ... PI가 180도니깐 / 4하면 45도... 45도만 움직일수 있음
controls.minPolarAngle = Math.PI / 4 


// 위 아래로 회전 하는 각도 ... max
controls.maxPolarAngle = Math.PI / 4 


// 카메라를 돌리는 중심점  x, y, z
controls.target.set(5, 5, 5)


// 카메라 자동으로 돌리기
controls.autoRotate = true
controls.autoRotateSpeed = 5




그 외 옵션들은 아래서~
//https://threejs.org/docs/index.html?q=control#examples/en/controls/OrbitControls


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.TrackballControls()</button></dt>
                        <dd>
                            볼 모양처럼 컨트롤
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
//얘는 전방위 모두 스크롤이 됨



import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls'

const controls = new TrackballControls(camera, renderer.domElement);


// 얘는 꼭 update함수 실행해줘야함 
request animation draw 함수에 controls.update() 


// 최대 줌 설정 
controls.maxDistance = 5


// 최소 줌 설정
controls.minDistance = 2
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.FlyControls()</button></dt>
                        <dd>
                            게임같은 컨트롤 
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
//게임처럼 방향키 이동 가능한 카메라 컨트롤러
//다른 키나 마우스 방향에 따라서도 움직임



import { FlyControls } from 'three/examples/jsm/controls/FlyControls'

const controls = new FlyControls(camera, renderer.domElement);


// !!얘는 꼭 update함수실행하면서 delta값을 넣어줘야됨 실행해줘야함 

const clock = new Three.Clock()
const draw = () => {
    const delta = clock.getDelta()
    controls.update(delta)

    requestAnimationFrame(draw)
}



`
 wasd : 게임처럼 방향키 
 방향키 : 카메라 좌우위아래 이동 
 마우스 좌클릭 : 앞 
 마우스 우클릭 : 뒤
 qe : 보는 시점 이동
 rf : 위 아래로 카메라
 마우스 위치 : 위치 따라감
`

// 마우스 따라가는 스피드
controls.rollSpeed = 0.05; //default 0.005

// 이동 스피드
controls.movementSpeed = 3;


// 마우스 자동이동 막기 
controls.dragToLook = true






// https://threejs.org/docs/index.html?q=control#examples/en/controls/FlyControls


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.FirstPersonControls()</button></dt>
                        <dd>
                            게임같은 컨트롤
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 게임처럼 방향키 이동 가능한 카메라 컨트롤러
// 다른 키나 마우스 방향에 따라서도 움직임
// 플라이 컨트롤이랑 거의 같은데 좀더 추가됨


import { FirstPersonControls } from 'three/examples/jsm/controls/FirstPersonControls'

const controls = new FirstPersonControls(camera, renderer.domElement);


// !!얘는 꼭 update함수실행하면서 delta값을 넣어줘야됨 실행해줘야함 

const clock = new Three.Clock()
const draw = () => {
    const delta = clock.getDelta()
    controls.update(delta)

    requestAnimationFrame(draw)
}




//https://threejs.org/docs/index.html?q=control#examples/en/controls/FirstPersonControls



                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.PointerLockControls()</button></dt>
                        <dd>
                            포인트 락 컨트롤 
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 게임에 1인칭 시점으로 멈추면서 마우스 무브로 그 자리에서 화면만 돌릴수있음


import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls'


const controls = new PointerLockControls(camera, renderer.domElement);

controls.domElement.addEventListener('click', () => {
    controls.lock()
})

controls.addEventListener('lock', () => console.log('lock'))
controls.addEventListener('unlock', () => console.log('un lock'))





ex) 

const keyEvt = new KeyController()
console.log(keyEvt)	

function walk() {
    // console.log(11)
    if(keyEvt.keys['KeyW'] || keyEvt.keys['ArrowUp']) return controls.moveForward(0.02) 
    if(keyEvt.keys['KeyS'] || keyEvt.keys['ArrowDown']) return controls.moveForward(-0.02)
    if(keyEvt.keys['KeyA'] || keyEvt.keys['ArrowLeft']) return controls.moveRight(-0.02)
    if(keyEvt.keys['KeyD'] || keyEvt.keys['ArrowRight']) return controls.moveRight(0.02)
    
}


const draw = () => {
    walk()
    
    renderer.render(scene, camera);
    renderer.setAnimationLoop(draw);
    requestAnimationFrame(draw)
}



//KeyController module 
class KeyController {
    constructor() {
        this.keys = [];
        
        window.addEventListener('keydown', e => {
            console.log('눌림')
            this.keys[e.code] = true;
        })

        window.addEventListener('keyup', e => {
            console.log('뗌')
            delete this.keys[e.code]
        })

        console.log(this.keys)

    }
}


export default KeyController;


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.DragControls()</button></dt>
                        <dd>
                            요소들 드래그 가능
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 드래그


import { DragControls } from 'three/examples/jsm/controls/DragControls'


// Mesh
const geometry = new THREE.BoxGeometry(1, 1, 1);
let mesh;
let material;
let meshs = []

for(let i = 0; i &lt; 20; i++) {
    material = new THREE.MeshStandardMaterial({
        color: `rgb(${Math.round( 200 + Math.random() * 55 )}, ${Math.round( 100 + Math.random() * 155 )}, ${Math.round( 100 + Math.random() * 155 )} )`
    })

    mesh = new THREE.Mesh(geometry, material)
    mesh.position.x = Math.random() * 6 - 3
    mesh.position.y = Math.random() * 6 - 3
    mesh.position.z = Math.random() * 6 - 3


    mesh.name = `box-${i}`
    meshs[i] = mesh

    scene.add(mesh)
}

scene.add(mesh);




// 첫번째 매개변수에 메시배열 넣어야함
const controls = new DragControls(meshs, camera, renderer.domElement);
console.dir(controls)

// 메시에 이름 정보 넣어주면 이벤트때 특정지을 수 있음 
controls.addEventListener('dragstart', e => console.log(e.object.name)) 


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <br />

                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.AxesHelper()</button></dt>
                        <dd>
                            축 표시
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const axesHelper = new THREE.AxesHelper(3)
scene.add(axesHelper)
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three.</span>.GridHelper()</button></dt>
                        <dd>
                            그리드 표시
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const gridHelper = new THREE.GridHelper(5)
scene.add(gridHelper)
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
            </div>
                
                <br />


                <div class="depth_2">
                    <strong>속성</strong>
                    <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.position.x y z</button></dt>
                    <dd>
                        위치
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.x = 3 
light.position.y = 3 
light.position.z = 3 
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.position.set()</button></dt>
                    <dd>
                        위치
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.set(x, y, z) 

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.position.distanceTo()</button></dt>
                    <dd>
                        인자까지의 거리
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.distanceTo(new Vector3(1, 2, 0))  
//light에서부터 새로운 vector까지의 거리


                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.scale.x y z</button></dt>
                    <dd>
                        사이즈 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({
    color: 'seagreen'
});
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

mesh.scale.x = 1
mesh.scale.y = 1
mesh.scale.z = 1


mesh.scale.set(1, 1, 1) // 기본..    등등 다 있음  



                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.rotation.x y z</button></dt>
                    <dd>
                        회전 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

/*
    단위는 라디안값...
    360 = 2PI
*/


mesh.rotation.y += 0.1

Three.MathUtils.degToRad() //라디안값 각도로 바꿔줌..


                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.rotation.reorder()</button></dt>
                    <dd>
                        회전축 독립 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">



회전할 때 회전축 독립시켜주지 않으면 
축이 그대로 진행되게 됨 

// 축
mesh.rotation.y = THREE.MathUtils.degToRad(45)
mesh.rotation.x = THREE.MathUtils.degToRad(20)

위 처럼 했을 시 
45도 돌리고 그 축에서 20도를 다시 돌림... 



// reorder를 해주면 각각 축이 다르게 생김
mesh.rotation.reorder('YXZ')
mesh.rotation.y = THREE.MathUtils.degToRad(45)
mesh.rotation.x = THREE.MathUtils.degToRad(20)
	

                    </code>

                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>instance</span>.clone()</button></dt>
                    <dd>
                        복제
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">


const box1 = new Three.Mesh(모양, 재질)
const box2 = box1.clone()


                    </code>

                </pre>
                </div>
            </div>
            <!-- //item -->
                </div>


                <!-- #랜더러 -->
               <div class="depth_2">
                   <strong>랜더러</strong>
               
                   <!-- item -->
                   <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>new</span> WebGLRenderer()</button></dt>
                        <dd>
                            WebGL Renderer 인스턴스 생성
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
//js로 바로 생성 
import * as Three from 'three'
const renderer = new Three.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement)


//element로 생성
import * as Three from 'three'
const canvas_1 = document.querySelector('canvas')
const renderer = new Three.WebGLRenderer({ 
    canvas: canvas_1, 
    antialias: true,
    alpha: true,
});


// 리사이즈 시 
renderer.setSize(window.innerWidth, window.innerHeight);

// 레티나 대응 최적화
renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);


// 애니메이션 함수 
const draw = () => {


    renderer.render(scene, camera);
	renderer.setAnimationLoop(draw); // or requestAnimationFrame
}



// 리사이즈 시 카메라와 랜더링도 다시
const setSize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
}



window.addEventListener('resize', setResize)
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.render()</button></dt>
                        <dd>
                            그리기
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const renderer = new Three.WebGLRenderer({ canvas: canvas_1, antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);

//씬과 카메라를 생성해서 화면에 그림 
renderer.render(scene, camera)
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.setSize()</button></dt>
                        <dd>
                            사이즈 지정
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
const renderer = new Three.WebGLRenderer({ canvas: canvas_1, antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);

//씬과 카메라를 생성해서 화면에 그림 
renderer.render(scene, camera)
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.setPixelRatio()</button></dt>
                        <dd>
                            환경에 맞는 픽셀 수 계산해서 화면 표시
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1)
// 맥에서는 캔버스 화면 2배 크기됨

/* 
    console.log(window.devicePixelRatio) 
    픽셀 밀도 mac 2  window 1 ...
    mac은 100px 이미지를 표현할때 200픽셀 쓴다는 뜻 그래서 정사이즈 이미지 쓰면 꺠져보임
    
    
    1보다 크면 2로..아님 1로  처리해줘야 성능에 좋음
*/
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.setClearAlpha()</button></dt>
                        <dd>
                            랜더러 알파값 조절
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 0~ 1
renderer.setClearAlpha(.1)



                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.setClearColor()</button></dt>
                        <dd>
                            랜더러 컬러 조절
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
renderer.setClearColor('color')



                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                 <!-- item -->
                 <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>renderer</span>.setAnimationLoop()</button></dt>
                        <dd>
                            requestAnimationFrame 이랑 같음
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
// 사용방법도 같음.. 근데 웹환경이 아닌 VR, AR 같은 곳에선 requestAnimationFrame 못쓰니 사용

renderer.setAnimationLoop(function)



                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                
            </div>


                
                <!-- #씬 -->
            <div class="depth_2">
                <strong>씬</strong>
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.Scene()</button></dt>
                        <dd>
                            장면 인스턴스 생성
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
import * as Three from 'three'
const scene = new Three.Scene()
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>scene.</span>.add()</button></dt>
                        <dd>
                            장면에 추가
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">

const scene = new Three.Scene();

const camera = new Three.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    1,
    30
)

scene.add(camera)
                            
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                
                
                
            </div>



            <!-- #카메라 -->
            <div class="depth_2">
                <strong>카메라</strong>
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.DirectionalLightHelper()</button></dt>
                        <dd>
                            카메라 위치 표시해주는 헬퍼
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
import * as Three from 'three'

const ambLight = new THREE.AmbientLight('#fff', .5) //기본으로 깔아주고 다른조명 씀 
const directionLight = new THREE.DirectionalLight('#fff', .5)
scene.add(ambLight, directionLight) 
directionLight.position.y = 3

//Light helper
const LightHelper = new THREE.DirectionalLightHelper(directionLight, 1)
scene.add(LightHelper)



// https://threejs.org/docs/index.html?q=light#api/en/helpers/DirectionalLightHelper

                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->

                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.PerspectiveCamera()</button></dt>
                        <dd>
                            원근감 카메라 인스턴스 생성
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
import * as Three from 'three'
const camera = new PerspectiveCamera()



PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )

fov — 카메로로부터 넓어지는 시야각(부채꼴 V) 
aspect — 가로, 세로 비율... (가로/세로)
near — 카메라와 near 사이(target)는 안보임    camera  |  target(안보임)  |(near)
far — 카메라에 어디까지 보여질건지 ...     camera     |(near)       피사체        |far()  target(안보임)  



* 위치 설정하지 않으면 초기값은 xyz: 0



//https://threejs.org/docs/index.html?q=camera#api/ko/cameras/PerspectiveCamera


                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>Three</span>.OrthographicCamera()</button></dt>
                        <dd>
                            직교 카메라 인스턴스 생성
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
디아, 롤같은 게임들.. 하늘에서 기울여서 보는 뷰

OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )
left — 카메라 절두체 좌평면.
right — 카메라 절두체 우평면.
top — 카메라 절두체 상평면.
bottom — 카메라 절두체 하평면.
near — 카메라 절두체 근평면.
far — 카메라 절두체 원평면.


* 위치 설정하지 않으면 초기값은 xyz: 0






ex)
import * as Three from 'three'
const camera = new OrthographicCamera(
    -(window.innerWidth / window.innerHeight),
    window.innerWidth / window.innerHeight,
    -1,
    1,
    0.1,
    1000
)


scene.add(camera)





//https://threejs.org/docs/index.html?q=camera#api/ko/cameras/OrthographicCamera
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
                
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>camera</span>.lookAt()</button></dt>
                    <dd>
                        카메라가 특정한것만 바라보기
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
camera.lookAt(x, y, z)
camera.lookAt(mesh.position) //해당 mesh의 포지션을 바라보기...카메라 위치가 변경되어도.


ex) 이렇게 해주면 카메라가 이동되어도 계속 mesh를 바라봄

gui.add(camera.position, 'x').min(-10).max(10).step(0.01).name('camera 위치')

camera.lookAt(mesh.position)
const draw = () => {
    camera.lookAt(mesh.position)
    requestAnimationFrame(draw)   
}

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
               <!-- item -->
               <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>camera</span>.zoom</button></dt>
                    <dd>
                        카메라 줌 설정
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
//기본값은 1
camera.zoom = 0.5

// 줌아웃가튼 효과를 내려면 z값이 아니라 zoom속성을 조절해줘야됨
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>camera</span>.updateProjectionMatrix()</button></dt>
                    <dd>
                        카메라 업데이트
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
//카메라 설정 변경 시 업데이트
camera.updateProjectionMatrix()
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->


            </div>


                 <!-- #메시 #요소-->
            <div class="depth_2">
                <strong>Mesh</strong>
                <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.Mesh()</button></dt>
                    <dd>
                        요소 인스턴스 생성
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
const geometry = new Three.BoxGeometry(1, 1, 1);
const material = new Three.MeshBasicMaterial({
    color: '#123124'
});


const mesh = new Three.Mesh(geometry, material)
// 만들어둔 모양과 재질 등록 
scene.add(mesh)


                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>mesh</span>.rotation</button></dt>
                    <dd>
                        회전
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
/*
    단위는 라디안값...
    360 = 2PI
*/


mesh.rotation.y += 0.1


Three.MathUtils.degToRad() //라디안값 각도로 바꿔줌..


                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            </div>


            <!-- #메시 #모양-->
            <div class="depth_2">
                <strong>Mesh Geometry(모양)</strong>
                <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.BoxGeometry()</button></dt>
                    <dd>
                        정육면체
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
BoxGeometry(
    width : Float, 
    eight : Float, 
    depth : Float, 
    widthSegments : Integer, 
    heightSegments : Integer, 
    depthSegments : Integer
    )


const geometry = new Three.BoxGeometry(1, 1, 1, 5) 
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.SphereGeometry()</button></dt>
                    <dd>
                        구
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
SphereGeometry(
    radius : Float, 
    widthSegments : Integer, 
    heightSegments : Integer,
    phiStart : Float, 
    phiLength : Float, 
    thetaStart : Float, 
    thetaLength : Float
    )


const geometry = new THREE.SphereGeometry( 10, 20, 20 );

console.log(geometry.attribute.position.array) //도트들이 담겨져 있는 정보





ex) 움직이는 모양 만들기 

// Mesh
const geometry = new THREE.SphereGeometry( 10, 50, 50, 50 );
const material = new THREE.MeshStandardMaterial({
    color: 'hotpink',
    wireframe: true,
    side: THREE.DoubleSide,
    flatShading: true,
    
});
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

// 점 컨트롤
// console.log(geometry.attributes.position.array)

const geoArr = geometry.attributes.position.array;
let cloneGeoArr = []


for(let i = 0; i &lt; geoArr.length; i = i + 3) {
    geoArr[i] = geoArr[i] + (Math.random() - 0.5) * 0.01
    geoArr[i + 1] = geoArr[i + 1] + (Math.random() - 0.5) * 0.01
    geoArr[i + 2] = geoArr[i + 2] + (Math.random() - 0.5) * 0.01

    cloneGeoArr[i] = geoArr[i] + (Math.random() - 0.5) * 0.01
    cloneGeoArr[i + 1] = geoArr[i + 1] + (Math.random() - 0.5) * 0.01
    cloneGeoArr[i + 2] = geoArr[i + 2] + (Math.random() - 0.5) * 0.01
}


const clock = new THREE.Clock();
    
	function draw() {
		// const delta = clock.getDelta();
		const time = clock.getElapsedTime();

        /*
            처음에 내가 했던 게 안됐던 이유는 랜덤된 좌표가 draw안에 있어서 계속 랜덤좌표가 찍혔기 때문.... 
            그게 아니라 랜덤된 좌표를 하나 만들어준 다음 그 좌표안에서 조금씩 변화를 줘야됨 아래처럼 .....공 자체는 멈춰있어야 하기 때문
        */    
        for(let i = 0; i &lt; geoArr.length; i += 3) {
            // 내가한거
            // geoArr[i] = cloneGeoArr[i] + Math.sin( time * Math.random() - 0.5 ) * 0.2
            // geoArr[i + 1] = cloneGeoArr[i + 1] + Math.sin( time * Math.random() - 0.5 ) * 0.2
            // geoArr[i + 2] = cloneGeoArr[i + 2] + Math.sin( time * Math.random() - 0.5 ) * 0.2

            geoArr[i] +=  Math.sin( time + cloneGeoArr[i] * 50 ) * 0.001
            geoArr[i + 1] +=  Math.sin( time + cloneGeoArr[i + 1] * 50 ) * 0.001
            geoArr[i + 1] +=  Math.sin( time + cloneGeoArr[i + 2] * 50 ) * 0.001
            geometry.attributes.position.needsUpdate = true
            
        }

		renderer.render(scene, camera);
		renderer.setAnimationLoop(draw);
	}


                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
              <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.PlaneGeometry()</button></dt>
                    <dd>
                        판
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
const planeGeometry = new THREE.PlaneGeometry(10, 10)

const mesh2 = new THREE.Mesh(planeGeometry, material2)

mesh2.rotation.x = -Math.PI * 0.5
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.BufferGeometry()</button></dt>
                    <dd>
                        미리 모양이 만들어져있지 않음
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

const loader = new THREE.TextureLoader()
const textrue = loader.load('./매탭 이미지 경로')
const material7 = new THREE.MeshMatcapMaterial({
    color: '#fff',
    matcap: textrue,
})

const mesh = new THREE.Mesh(geometry, material7)
scene.add(mesh)
                    
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.TorusGeometry()</button></dt>
                    <dd>
                        도너츠 모양
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

`
TorusGeometry(반지름, 두께, 세그먼트~, 세그먼트, 얼마나 길게할지)
걍 인자값은 공식문서 보는게 빠름
`


const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const torus = new THREE.Mesh( geometry, material );
scene.add( torus );

// https://threejs.org/docs/index.html?q=Geometry#api/en/geometries/TorusGeometry

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            
            </div>


            <!-- #메시 #재질-->
            <div class="depth_2">
                <strong>Mesh Material(재질)</strong>
                <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshBasicMaterial()</button></dt>
                    <dd>
                        기본 재질
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

// 이 재질은 빛에 반응 안함. 입체적x. 성능은 좋음

const material = new Three.MeshBasicMaterial({
    color: 'hotpink',
	wireframe: true, //와이어 프레임으로 보기 
	side: THREE.DoubleSide, // 기본적으로는 단면이지만 이 옵션추가 시 뒷면 옆면도 모두 보이게 설정
    flatShading: true, // 플리곤처럼 각진 느낌
    
})
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshStandardMaterial()</button></dt>
                    <dd>
                        표준 재질
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">


const material = new Three.MeshStandardMaterial({
    olor: 'hotpink',
	wireframe: true, //와이어 프레임으로 보기 
    side: THREE.FrontSide,
	side: THREE.BackSide,
	side: THREE.DoubleSide, // 기본적으로는 단면이지만 이 옵션추가 시 뒷면 옆면도 모두 보이게 설정
    flatShading: true, // 플리곤처럼 각진 느낌
    roughness: 0.2, // 광
    metalness: 0.3 // 메탈느낌

    map: brickTextrue1, // 베이직 텍스처 이미지
    normalMap: brickTextrue4, // 디테일 텍스처 이미지
    roughnessMap: brickTextrue5, //디테일 텍스처 이미지
    aoMap: brickTextrue2, // 그림자 조금 더 진하게 명암
    aoMapIntensity: 5, //aoMap 조절
})
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshLambertMaterial()</button></dt>
                    <dd>
                        하이라이트 없는 재질
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

// 하이라이트, 반사광이 없는 재질
const material1 = new THREE.MeshLambertMaterial({
    color: 'hotpink',
});
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshPhongMaterial()</button></dt>
                    <dd>
                        하이라이트 있는 재질
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// 하이라이트, 반사광 표현 가능 재질
const material2 = new THREE.MeshPhongMaterial({
    color: 'seagreen',
    shininess: 1000, //하이라이트 정도
    // wireframe: true,
});
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshToonMaterial()</button></dt>
                    <dd>
                        만화 느낌
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

// 투톤으로 이뤄진 원뿔 모양나옴 
const geometryCon = new THREE.ConeGeometry(1, 2, 120)
const material5 = new THREE.MeshToonMaterial({
    color: 'plum',
    // map: texture4,
})



// 그라데이션 단계를 조금 더 주려면 

const textureLoader = new THREE.TextureLoader(manager)
const gradiuntTexture = textureLoader.load('./textures/gradient.png') //width 3px height 1px 사이즈를 가진 3톤명암 이미지
const geometryCon = new THREE.ConeGeometry(1, 2, 120)
const material5 = new THREE.MeshToonMaterial({
    color: 'plum',
    // map: texture4,
    gradientMap: gradiuntTexture,
    
});
gradiuntTexture.magFilter = THREE.NearestFilter

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshNormalMaterial()</button></dt>
                    <dd>
                        법선 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
법선..?? 
각도에 맞게 컬러 알지비로 보임 .. 어따쓰는거지 ? 


const material6 = new THREE.MeshNormalMaterial()
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.MeshMatcapMaterial()</button></dt>
                    <dd>
                        3d 매캡 이미지 적용하는 재질 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">

const loader = new THREE.TextureLoader()
const textrue = loader.load('./매탭 이미지 경로')
const material7 = new THREE.MeshMatcapMaterial({
    color: '#fff',
    matcap: textrue,
})

const mesh = new THREE.Mesh(geometry, material7)
scene.add(mesh)
                    
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.LineBasicMaterial()</button></dt>
                    <dd>
                        라인
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
const lineMaterial = new THREE.LineBasicMaterial({ color: 'yellow' })
const points = []; 
points.push(new THREE.Vector3(0, 0, 100))
points.push(new THREE.Vector3(0, 0, -100))
const lineGeometry = new THREE.BufferGeometry().setFromPoints(points)

const guide = new THREE.Line(lineGeometry, lineMaterial)
scene.add(guide)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
           
            
        </div>



            <!-- #빛 -->
            <div class="depth_2">
                <strong>빛</strong>
                <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.DirectionalLight()</button></dt>
                    <dd>
                        모두 비추는 빛
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
//무대 위 요소들을 태양처럼 모두 비춰주는 


import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)  //color, 빛 세기
scene.add(light)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.AmbientLight()</button></dt>
                    <dd>
                        은은하게 밝혀주는 빛
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
import * as Three from 'three';

const light = new Three.AmbientLight('red', 1)  //color, 빛 세기
scene.add(light)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.PointLight()</button></dt>
                    <dd>
                        전구같은 빛
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
PointLight( 색, 빛 강도, 조명범위, 빛의 거리에 따라 어두워지는 양 )

const light = new THREE.PointLight('red', .5)
const LightHelper = new THREE.PointLightHelper(light, 1)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.SpotLight()</button></dt>
                    <dd>
                        집중 조명
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
SpotLight( 색, 빛 강도, 조명범위, 각도 )

const light = new THREE.SpotLight('red', .5)
const LightHelper = new THREE.SpotLightHelper(light, 1)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.HemisphereLightHelper()</button></dt>
                    <dd>
                        두가지 색으로 조명
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
// 그림자 없음. 카메라없음. 엠비언트 라이트처럼 모두를 비춰줌
// 첫번째 인자는 하늘에서 쏘는 빛
// 두번째 인자는 바닥에서 쏘는 빛

const light = new THREE.HemisphereLight('red', 'lime', .5)
const LightHelper = new THREE.HemisphereLightHelper(light, 1)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
             <!-- item -->
             <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>Three</span>.RectAreaLight()</button></dt>
                    <dd>
                        사각형 빛
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
RectAreaLight(색, 강도, 네모사이즈, 네모 사이즈)
const light = new THREE.RectAreaLight('red', .5, 2, 2)



얘는 헬퍼가 코어에 없음  
import { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper' 에 있음
const helper = new RectAreaLightHelper(light)
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            


            </div>

            <!-- #외부 -->
            <div class="depth_2">
                <strong>외부 라이브러리</strong>
                 <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span></span>Stats.js</button></dt>
                    <dd>
                        초당 프레임 
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
npm i Stats.js

import Stats from 'stats.js'


// stats
const stats = new Stats()
document.body.append(stats.domElement)


const draw = () => {
    stats.update() // 애니메이션 함수에서 업데이트 실행
    
    requestAnimationFrame(draw)
}

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
                <dl class="item">
                    <dt><button><span></span>dat.gui</button></dt>
                    <dd>
                        GUI 이동 테스트
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
three js 뿐만 아니라 다른 곳에서도 가능 
npm i dat.gui

import dat from 'dat.gui'

const gui = new dat.GUI();
// gui.add(mesh.position, 'y', -5, 5, 0.01) //움직일것, 움직일속성, 범위 최소, 최대, 스탭..단계
or
gui.add(mesh.position, 'y').min(-5).max(5).step(0.01).name('메시 z 위치')
gui.add(camera.position, 'x').min(-10).max(10).step(0.01).name('camera 위치')

                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->
            <br /><br />
            <!-- item -->
            <div class="item_wrap">
                3d 텍스처 사이트 - <a href="https://3dtextures.me/">https://3dtextures.me/</a><br />
                3d 매캡 이미지 사이트 - <a href="https://www.deviantart.com/sespider/art/163-FREE-MatCaps-258893793">https://www.deviantart.com/</a><br />
                3d 배경 이미지 사이트 - <a href="https://polyhaven.com/">https://polyhaven.com/</a><br />
                hdr 이미지 자르는 사이트 - <a href="https://matheowis.github.io/HDRI-to-CubeMap/">https://matheowis.github.io/HDRI-to-CubeMap/</a><br />
            </div>
            <!-- //item -->


            </div>










<br /><br /><br /><br /><br /><br /><br /><br />
------------------------------------


              <!-- item -->
              <div class="item_wrap">
                <dl class="item">
                    <dt><button><span>document</span>.body</button></dt>
                    <dd>
                        -
                </dd>
                </dl>
                <div class="code_wrap">
                <pre>
                    <code class="javascript">
asd
                    </code>
                </pre>
                </div>
            </div>
            <!-- //item -->


          </section>
          <!-- Three.js -->


         

              


            </div>
        </main>
        <footer>
            <div class="global_wrap">
                <ul class="info">
                    asdasdsa
                </ul>
            </div>
        </footer>
    </div>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>