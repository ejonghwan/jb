<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Document</title><script defer="defer" src="../../../main.61aadaac0cffa957c543.js"></script><link href="../../../main.css" rel="stylesheet"></head><body><div class="wrap"><header><nav class="global_wrap sub"><ul class="line"></ul></nav></header><main><div class="global_wrap"><section class="conts"><h2>Canvas</h2><div class="depth_2"><strong>-</strong><div class="item_wrap"><dl class="item"><dt><button><span>document</span>.body</button></dt><dd>현재 문서의 body 또는 frameset 노드를 반환 adsadasdasdasdasdasdasdplalsjdlkajdlkajskda</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
asd
                            </code>
                        </pre></div></div></div></section><section class="conts"><h2>Three.js</h2><div class="depth_2"><strong>기본 요소들</strong><div class="item_wrap"><dl class="item"><dt><button>구성요소</button></dt><dd>Mesh(Geometry + Material) | Scene | Camera | Light</dd></dl><div class="code_wrap"><pre>
                        <code class="markdown">
three.js는 아래 구성요소를 가지고 있다 
축 x y z 존재해서 Mesh와 Camera위치가 중요 
- x 축은 오른쪽이 +
- y 축은 위가 +
- z 축은 앞이 +


# Mesh
요소
 - Geometry : 모양
 - Material : 재질


# Scene
장면 무대


# Camera
카메라


# Light
빛 조명

                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.Color()</button></dt><dd>장면에 컬러 설정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

import * as Three from 'three'


const scene = new Three.Scene();
const color = new Three.Color('red')
scene.background = color


* 장면은 랜더러보다 위에 있어서 먼저 적용 
* 알파값을 주려면 장면에 컬러주지 말고 랜더러에 줘야됨


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.Clock()</button></dt><dd>시간</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

import * as Three from 'three'

/*
autoStart: true
elapsedTime: 0
oldTime: 0
running: false
startTime: 0
*/


const clock = new Three.Clock();

const draw = () => {

    // 이렇게 하면 모니터마다 주사율이 달라서 어떤 곳에선 1초에 60번, 노트북에선 30번 ...다 다를 수 있다
    // mesh.rotation.x += Three.MathUtils.degToRad(.1) 
    

    // 그럴때 clock을 이용해서 절대 시간을 대입하면 어떤 환경에서든 같은 동작을 구현할 수 있다


    const time = clock.getElapsedTime() //여기 안에서는 1초씩 반환 ..
    mesh.rotation.x = 2 * time 
}






                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.fog()</button></dt><dd>안개</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
Three.Fog('black', 3, 7) // color, near, far


const scene = new Three.Scene();
scene.fog = new Three.Fog('black', 3, 7)
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.Group()</button></dt><dd>그룹 묶기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
const group1 = new THREE.Group();
const box1 = new THREE.Mesh(geometry, material);

const group2 = new THREE.Group();
const box2 = new THREE.Mesh(geometry, material);
box2.scale.set(.3, .3, .3);
group2.position.x = 2;


const group3 = new THREE.Group();
const box3 = new THREE.Mesh(geometry, material);
box3.scale.set(.1, .1, .1)
group3.position.x = 0.5
group3.position.y = 0.1

group3.add(box3)
group2.add(box2, group3)
group1.add(box1, group2)


scene.add(group1)


const clock = new THREE.Clock();

	function draw() {
		const delta = clock.getDelta();

		group1.rotation.y += delta
		group2.rotation.y += delta
		group3.rotation.y += delta


		renderer.render(scene, camera);
		renderer.setAnimationLoop(draw);
	}
                            
                        </code>
                    </pre></div></div><br><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.AxesHelper()</button></dt><dd>축 표시</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
const axesHelper = new THREE.AxesHelper(3)
scene.add(axesHelper)
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.GridHelper()</button></dt><dd>그리드 표시</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
const gridHelper = new THREE.GridHelper(5)
scene.add(gridHelper)
                            
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.OrbitControls()</button></dt><dd>카메라 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'

const controls = new OrbitControls(camera, renderer.domElement);


// 장면 아웃할 때 부드럽게 더해지기
controls.enableDamping = true
request animation draw 함수에 controls.update() 함수 실행해줘야함 


// 줌 기능 끄고 키기 
controls.enableZoom = false


// 최대 줌 설정 
controls.maxDistance = 5


// 최소 줌 설정
controls.minDistance = 2


// 위 아래로 회전 하는 각도 ... PI가 180도니깐 / 4하면 45도... 45도만 움직일수 있음
controls.minPolarAngle = Math.PI / 4 


// 위 아래로 회전 하는 각도 ... max
controls.maxPolarAngle = Math.PI / 4 


// 카메라를 돌리는 중심점  x, y, z
controls.target.set(5, 5, 5)


// 카메라 자동으로 돌리기
controls.autoRotate = true
controls.autoRotateSpeed = 5




그 외 옵션들은 아래서~
//https://threejs.org/docs/index.html?q=control#examples/en/controls/OrbitControls


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.TrackballControls()</button></dt><dd>볼 모양처럼 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
//얘는 전방위 모두 스크롤이 됨



import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls'

const controls = new TrackballControls(camera, renderer.domElement);


// 얘는 꼭 update함수 실행해줘야함 
request animation draw 함수에 controls.update() 


// 최대 줌 설정 
controls.maxDistance = 5


// 최소 줌 설정
controls.minDistance = 2
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.FlyControls()</button></dt><dd>게임같은 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
//게임처럼 방향키 이동 가능한 카메라 컨트롤러
//다른 키나 마우스 방향에 따라서도 움직임



import { FlyControls } from 'three/examples/jsm/controls/FlyControls'

const controls = new FlyControls(camera, renderer.domElement);


// !!얘는 꼭 update함수실행하면서 delta값을 넣어줘야됨 실행해줘야함 

const clock = new Three.Clock()
const draw = () => {
    const delta = clock.getDelta()
    controls.update(delta)

    requestAnimationFrame(draw)
}



`
 wasd : 게임처럼 방향키 
 방향키 : 카메라 좌우위아래 이동 
 마우스 좌클릭 : 앞 
 마우스 우클릭 : 뒤
 qe : 보는 시점 이동
 rf : 위 아래로 카메라
 마우스 위치 : 위치 따라감
`

// 마우스 따라가는 스피드
controls.rollSpeed = 0.05; //default 0.005

// 이동 스피드
controls.movementSpeed = 3;


// 마우스 자동이동 막기 
controls.dragToLook = true






// https://threejs.org/docs/index.html?q=control#examples/en/controls/FlyControls


                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.FirstPersonControls()</button></dt><dd>게임같은 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// 게임처럼 방향키 이동 가능한 카메라 컨트롤러
// 다른 키나 마우스 방향에 따라서도 움직임
// 플라이 컨트롤이랑 거의 같은데 좀더 추가됨


import { FirstPersonControls } from 'three/examples/jsm/controls/FirstPersonControls'

const controls = new FirstPersonControls(camera, renderer.domElement);


// !!얘는 꼭 update함수실행하면서 delta값을 넣어줘야됨 실행해줘야함 

const clock = new Three.Clock()
const draw = () => {
    const delta = clock.getDelta()
    controls.update(delta)

    requestAnimationFrame(draw)
}




//https://threejs.org/docs/index.html?q=control#examples/en/controls/FirstPersonControls



                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.PointerLockControls()</button></dt><dd>포인트 락 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// 게임에 1인칭 시점으로 멈추면서 마우스 무브로 그 자리에서 화면만 돌릴수있음


import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls'


const controls = new PointerLockControls(camera, renderer.domElement);

controls.domElement.addEventListener('click', () => {
    controls.lock()
})

controls.addEventListener('lock', () => console.log('lock'))
controls.addEventListener('unlock', () => console.log('un lock'))




                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three.</span>.DragControls()</button></dt><dd>포인트 락 컨트롤</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// 드래그


import { DragControls } from 'three/examples/jsm/controls/DragControls'


// Mesh
const geometry = new THREE.BoxGeometry(1, 1, 1);
let mesh;
let material;
let meshs = []

for(let i = 0; i &lt; 20; i++) {
    material = new THREE.MeshStandardMaterial({
        color: `rgb(${Math.round( 200 + Math.random() * 55 )}, ${Math.round( 100 + Math.random() * 155 )}, ${Math.round( 100 + Math.random() * 155 )} )`
    })

    mesh = new THREE.Mesh(geometry, material)
    mesh.position.x = Math.random() * 6 - 3
    mesh.position.y = Math.random() * 6 - 3
    mesh.position.z = Math.random() * 6 - 3


    mesh.name = `box-${i}`
    meshs[i] = mesh

    scene.add(mesh)
}

scene.add(mesh);




// 첫번째 매개변수에 메시배열 넣어야함
const controls = new DragControls(meshs, camera, renderer.domElement);
console.dir(controls)

// 메시에 이름 정보 넣어주면 이벤트때 특정지을 수 있음 
controls.addEventListener('dragstart', e => console.log(e.object.name)) 







                        </code>
                    </pre></div></div></div><br><div class="depth_2"><strong>속성</strong><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.position.x y z</button></dt><dd>위치</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.x = 3 
light.position.y = 3 
light.position.z = 3 
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.position.set()</button></dt><dd>위치</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.set(x, y, z) 

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.position.distanceTo()</button></dt><dd>인자까지의 거리</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)
scene.add(light)

light.position.distanceTo(new Vector3(1, 2, 0))  
//light에서부터 새로운 vector까지의 거리


                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.scale.x y z</button></dt><dd>사이즈</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
// light mesh camera 등등...

import * as Three from 'three';

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({
    color: 'seagreen'
});
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

mesh.scale.x = 1
mesh.scale.y = 1
mesh.scale.z = 1


mesh.scale.set(1, 1, 1) // 기본..    등등 다 있음  



                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.rotation.x y z</button></dt><dd>회전</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">

/*
    단위는 라디안값...
    360 = 2PI
*/


mesh.rotation.y += 0.1

Three.MathUtils.degToRad() //라디안값 각도로 바꿔줌..


                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.rotation.reorder()</button></dt><dd>회전축 독립</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">



회전할 때 회전축 독립시켜주지 않으면 
축이 그대로 진행되게 됨 

// 축
mesh.rotation.y = THREE.MathUtils.degToRad(45)
mesh.rotation.x = THREE.MathUtils.degToRad(20)

위 처럼 했을 시 
45도 돌리고 그 축에서 20도를 다시 돌림... 



// reorder를 해주면 각각 축이 다르게 생김
mesh.rotation.reorder('YXZ')
mesh.rotation.y = THREE.MathUtils.degToRad(45)
mesh.rotation.x = THREE.MathUtils.degToRad(20)
	

                    </code>

                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.clone()</button></dt><dd>복제</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">


const box1 = new Three.Mesh(모양, 재질)
const box2 = box1.clone()


                    </code>

                </pre></div></div></div><!-- #랜더러 --><div class="depth_2"><strong>랜더러</strong><div class="item_wrap"><dl class="item"><dt><button><span>new</span> WebGLRenderer()</button></dt><dd>WebGL Renderer 인스턴스 생성</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
//js로 바로 생성 
import * as Three from 'three'
const renderer = new Three.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement)


//element로 생성
import * as Three from 'three'
const canvas_1 = document.querySelector('canvas')
const renderer = new Three.WebGLRenderer({ 
    canvas: canvas_1, 
    antialias: true,
    alpha: true,
});
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.render()</button></dt><dd>그리기</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
const renderer = new Three.WebGLRenderer({ canvas: canvas_1, antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);

//씬과 카메라를 생성해서 화면에 그림 
renderer.render(scene, camera)
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.setSize()</button></dt><dd>사이즈 지정</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
const renderer = new Three.WebGLRenderer({ canvas: canvas_1, antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);

//씬과 카메라를 생성해서 화면에 그림 
renderer.render(scene, camera)
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.setPixelRatio()</button></dt><dd>환경에 맞는 픽셀 수 계산해서 화면 표시</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1)
// 맥에서는 캔버스 화면 2배 크기됨

/* 
    console.log(window.devicePixelRatio) 
    픽셀 밀도 mac 2  window 1 ...
    mac은 100px 이미지를 표현할때 200픽셀 쓴다는 뜻 그래서 정사이즈 이미지 쓰면 꺠져보임
    
    
    1보다 크면 2로..아님 1로  처리해줘야 성능에 좋음
*/
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.setClearAlpha()</button></dt><dd>랜더러 알파값 조절</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// 0~ 1
renderer.setClearAlpha(.1)



                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.setClearColor()</button></dt><dd>랜더러 컬러 조절</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
renderer.setClearColor('color')



                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>renderer</span>.setAnimationLoop()</button></dt><dd>requestAnimationFrame 이랑 같음</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
// 사용방법도 같음.. 근데 웹환경이 아닌 VR, AR 같은 곳에선 requestAnimationFrame 못쓰니 사용

renderer.setAnimationLoop(function)



                        </code>
                    </pre></div></div></div><!-- #씬 --><div class="depth_2"><strong>씬</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.Scene()</button></dt><dd>장면 인스턴스 생성</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
import * as Three from 'three'
const scene = new Three.Scene()
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>scene.</span>.add()</button></dt><dd>장면에 추가</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">

const scene = new Three.Scene();

const camera = new Three.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    1,
    30
)

scene.add(camera)
                            
                        </code>
                    </pre></div></div></div><!-- #카메라 --><div class="depth_2"><strong>카메라</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.PerspectiveCamera()</button></dt><dd>원근감 카메라 인스턴스 생성</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
import * as Three from 'three'
const camera = new PerspectiveCamera()



PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )

fov — 카메로로부터 넓어지는 시야각(부채꼴 V) 
aspect — 가로, 세로 비율... (가로/세로)
near — 카메라와 near 사이(target)는 안보임    camera  |  target(안보임)  |(near)
far — 카메라에 어디까지 보여질건지 ...     camera     |(near)       피사체        |far()  target(안보임)  



* 위치 설정하지 않으면 초기값은 xyz: 0



//https://threejs.org/docs/index.html?q=camera#api/ko/cameras/PerspectiveCamera





                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.OrthographicCamera()</button></dt><dd>직교 카메라 인스턴스 생성</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">
디아, 롤같은 게임들.. 하늘에서 기울여서 보는 뷰

OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )
left — 카메라 절두체 좌평면.
right — 카메라 절두체 우평면.
top — 카메라 절두체 상평면.
bottom — 카메라 절두체 하평면.
near — 카메라 절두체 근평면.
far — 카메라 절두체 원평면.


* 위치 설정하지 않으면 초기값은 xyz: 0






ex)
import * as Three from 'three'
const camera = new OrthographicCamera(
    -(window.innerWidth / window.innerHeight),
    window.innerWidth / window.innerHeight,
    -1,
    1,
    0.1,
    1000
)


scene.add(camera)





//https://threejs.org/docs/index.html?q=camera#api/ko/cameras/OrthographicCamera
                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>camera</span>.position</button></dt><dd>위치 설정</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">

* 위치단위는 구현하는것마다 다름... 
예를 들어 어떤 집을 구현한다면 m로 기준을 잡고 
어떤 작은 물건들이라면 cm로 본인이 기준을 잡아야됨


camera.position.x = 5
camera.position.y = 5
camera.position.z = 5
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>camera</span>.lookAt()</button></dt><dd>카메라가 특정한것만 바라보기</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
camera.lookAt(x, y, z)
camera.lookAt(mesh.position) //해당 mesh의 포지션을 바라보기...카메라 위치가 변경되어도.


ex) 이렇게 해주면 카메라가 이동되어도 계속 mesh를 바라봄

gui.add(camera.position, 'x').min(-10).max(10).step(0.01).name('camera 위치')

camera.lookAt(mesh.position)
const draw = () => {
    camera.lookAt(mesh.position)
    requestAnimationFrame(draw)   
}

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>camera</span>.zoom</button></dt><dd>카메라 줌 설정</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
//기본값은 1
camera.zoom = 0.5

// 줌아웃가튼 효과를 내려면 z값이 아니라 zoom속성을 조절해줘야됨
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>camera</span>.updateProjectionMatrix()</button></dt><dd>카메라 업데이트</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
//카메라 설정 변경 시 업데이트
camera.updateProjectionMatrix()
                    </code>
                </pre></div></div></div><!-- #메시 #요소--><div class="depth_2"><strong>Mesh</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.Mesh()</button></dt><dd>요소 인스턴스 생성</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
const geometry = new Three.BoxGeometry(1, 1, 1);
const material = new Three.MeshBasicMaterial({
    color: '#123124'
});


const mesh = new Three.Mesh(geometry, material)
// 만들어둔 모양과 재질 등록 
scene.add(mesh)


                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mesh</span>.rotation</button></dt><dd>회전</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
/*
    단위는 라디안값...
    360 = 2PI
*/


mesh.rotation.y += 0.1


Three.MathUtils.degToRad() //라디안값 각도로 바꿔줌..


                    </code>
                </pre></div></div></div><!-- #메시 #모양--><div class="depth_2"><strong>Mesh Geometry(모양)</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.BoxGeometry()</button></dt><dd>정육면체</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
BoxGeometry(
    width : Float, 
    eight : Float, 
    depth : Float, 
    widthSegments : Integer, 
    heightSegments : Integer, 
    depthSegments : Integer
    )


const geometry = new Three.BoxGeometry(1, 1, 1, 5) 
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.SphereGeometry()</button></dt><dd>구</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
SphereGeometry(
    radius : Float, 
    widthSegments : Integer, 
    heightSegments : Integer,
    phiStart : Float, 
    phiLength : Float, 
    thetaStart : Float, 
    thetaLength : Float
    )


const geometry = new THREE.SphereGeometry( 10, 20, 20 );

console.log(geometry.attribute.position.array) //도트들이 담겨져 있는 정보





ex) 움직이는 모양 만들기 

// Mesh
const geometry = new THREE.SphereGeometry( 10, 50, 50, 50 );
const material = new THREE.MeshStandardMaterial({
    color: 'hotpink',
    wireframe: true,
    side: THREE.DoubleSide,
    flatShading: true,
    
});
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

// 점 컨트롤
// console.log(geometry.attributes.position.array)

const geoArr = geometry.attributes.position.array;
let cloneGeoArr = []


for(let i = 0; i &lt; geoArr.length; i = i + 3) {
    geoArr[i] = geoArr[i] + (Math.random() - 0.5) * 0.01
    geoArr[i + 1] = geoArr[i + 1] + (Math.random() - 0.5) * 0.01
    geoArr[i + 2] = geoArr[i + 2] + (Math.random() - 0.5) * 0.01

    cloneGeoArr[i] = geoArr[i] + (Math.random() - 0.5) * 0.01
    cloneGeoArr[i + 1] = geoArr[i + 1] + (Math.random() - 0.5) * 0.01
    cloneGeoArr[i + 2] = geoArr[i + 2] + (Math.random() - 0.5) * 0.01
}


const clock = new THREE.Clock();
    
	function draw() {
		// const delta = clock.getDelta();
		const time = clock.getElapsedTime();

        /*
            처음에 내가 했던 게 안됐던 이유는 랜덤된 좌표가 draw안에 있어서 계속 랜덤좌표가 찍혔기 때문.... 
            그게 아니라 랜덤된 좌표를 하나 만들어준 다음 그 좌표안에서 조금씩 변화를 줘야됨 아래처럼 .....공 자체는 멈춰있어야 하기 때문
        */    
        for(let i = 0; i &lt; geoArr.length; i += 3) {
            // 내가한거
            // geoArr[i] = cloneGeoArr[i] + Math.sin( time * Math.random() - 0.5 ) * 0.2
            // geoArr[i + 1] = cloneGeoArr[i + 1] + Math.sin( time * Math.random() - 0.5 ) * 0.2
            // geoArr[i + 2] = cloneGeoArr[i + 2] + Math.sin( time * Math.random() - 0.5 ) * 0.2

            geoArr[i] +=  Math.sin( time + cloneGeoArr[i] * 50 ) * 0.001
            geoArr[i + 1] +=  Math.sin( time + cloneGeoArr[i + 1] * 50 ) * 0.001
            geoArr[i + 1] +=  Math.sin( time + cloneGeoArr[i + 2] * 50 ) * 0.001
            geometry.attributes.position.needsUpdate = true
            
        }

		renderer.render(scene, camera);
		renderer.setAnimationLoop(draw);
	}


                    </code>
                </pre></div></div></div><!-- #메시 #재질--><div class="depth_2"><strong>Mesh Material(재질)</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.MeshBasicMaterial()</button></dt><dd>기본 재질</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">

// 이 재질은 빛에 반응 안함

const material = new Three.MeshBasicMaterial({
    color: 'hotpink',
	wireframe: true, //와이어 프레임으로 보기 
	side: THREE.DoubleSide, // 기본적으로는 단면이지만 이 옵션추가 시 뒷면 옆면도 모두 보이게 설정
    flatShading: true, // 플리곤처럼 각진 느낌
    
})
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.MeshStandardMaterial()</button></dt><dd>표준 재질</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">


const material = new Three.MeshStandardMaterial({
    olor: 'hotpink',
	wireframe: true, //와이어 프레임으로 보기 
	side: THREE.DoubleSide, // 기본적으로는 단면이지만 이 옵션추가 시 뒷면 옆면도 모두 보이게 설정
    flatShading: true, // 플리곤처럼 각진 느낌
})
                    </code>
                </pre></div></div></div><!-- #빛 --><div class="depth_2"><strong>빛</strong><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.DirectionalLight()</button></dt><dd>모두 비추는 빛</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
//무대 위 요소들을 태양처럼 모두 비춰주는 


import * as Three from 'three';

const light = new Three.DirectionalLight('red', 1)  //color, 빛 세기
scene.add(light)
                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Three</span>.AmbientLight()</button></dt><dd>은은하게 밝혀주는 빛</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
import * as Three from 'three';

const light = new Three.AmbientLight('red', 1)  //color, 빛 세기
scene.add(light)
                    </code>
                </pre></div></div></div><!-- #외부 --><div class="depth_2"><strong>외부 라이브러리</strong><div class="item_wrap"><dl class="item"><dt><button><span></span>Stats.js</button></dt><dd>초당 프레임</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
npm i Stats.js

import Stats from 'stats.js'


// stats
const stats = new Stats()
document.body.append(stats.domElement)


const draw = () => {
    stats.update() // 애니메이션 함수에서 업데이트 실행
    
    requestAnimationFrame(draw)
}

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span></span>dat.gui</button></dt><dd>GUI 이동 테스트</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
three js 뿐만 아니라 다른 곳에서도 가능 
npm i dat.gui

import dat from 'dat.gui'

const gui = new dat.GUI();
// gui.add(mesh.position, 'y', -5, 5, 0.01) //움직일것, 움직일속성, 범위 최소, 최대, 스탭..단계
or
gui.add(mesh.position, 'y').min(-5).max(5).step(0.01).name('메시 z 위치')
gui.add(camera.position, 'x').min(-10).max(10).step(0.01).name('camera 위치')

                    </code>
                </pre></div></div></div><br><br><br><br><br><br><br><br>------------------------------------<div class="item_wrap"><dl class="item"><dt><button><span>document</span>.body</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
asd
                    </code>
                </pre></div></div></section></div></main><footer><div class="global_wrap"><ul class="info">asdasdsa</ul></div></footer></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>