<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><title>Document</title><script defer="defer" src="../../../main.2382b002bd80f3ac9b95.js"></script><link href="../../../main.css" rel="stylesheet"></head><body><div class="wrap"><header><nav class="global_wrap sub"><ul class="line"></ul></nav></header><main><div class="global_wrap"><p>query 정리 https://velopert.com/479</p><p>query 정리 https://mongoosejs.com/docs/api/model.html</p><p>params query body 차이 https://dar0m.tistory.com/m/222</p><section class="conts"><h2>MongoDB</h2><div class="depth_2"></div></section><section class="conts"><h2>Mongoose</h2><div class="depth_2"><strong>타입, 속성</strong><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span> 스키마 생성</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                        <code class="javascript">


// # Schema type
String, Number, id, Date, Buffer, Boolean, Mixed, Array


// # Schema attribute
`
required:꼭 입력해야 한다.
unique:다른 행과 중복되면 안 된다.
trim:공백을 제거합니다.(문자열 타입에 사용)
default:문서가 생성되면 기본값으로 저장됩니다.
lowercase:대문자를 소문자로 저장한다(문자열 타입)
match:정규식으로 저장하려는 값과 비교한다.
validate:함수로 개발자가 조건을 만듭니다.
set:값을 입력할 때 함수로 조건을 만듭니다.
get:값을 출력할 때 함수로 조건을 만듭니다.
ref:해당하는 모델을 참조할 때 사용한다.
`


// package.json type="module"                             

import mongoose from 'mongoose'

const UserSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
    },
    name: {
        first: { type: String, required: true,},
        last: { type: String, required: true, }
    },
    age: Number,
    email: String,
    array: [
        { name: { type: String } }
    ]
}, {
    timestamps: true, //생성한 시간을 만들어줌, 업데이트할 때마다 업데이트키를 생성해줌 
})

const User = mongoose.model('user', UserSchema) //첫번째 인자로 모델 생성 (db에는 users로 저장)
export default User



                        </code>
                    </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span> 타입</button></dt><dd>String, Number, id, Date, Buffer, Boolean, Mixed, Array</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
`
타입 종류: String, Number, id, Date, Buffer, Boolean, Mixed, Array
`



var exampleSchema = new mongoose.Schema({
    name:{
     type:String,
     required:true
    }
    age:Number
    number:Schema.Types.ObjectId
    created:{
     type:Date,
     default:Date.now
    }
    binary:Buffer,
    living:Boolean
    mixed:Schema.Types.Mixed
    array:[],
    arrayNumber:[Number],
    arrayString:[String]
 });


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span> 속성</button></dt><dd>required, unique, trim, default, lowercase, match, validate, set, get, ref</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
`
required:꼭 입력해야 한다.
unique:다른 행과 중복되면 안 된다.
trim:공백을 제거합니다.(문자열 타입에 사용)
default:문서가 생성되면 기본값으로 저장됩니다.
lowercase:대문자를 소문자로 저장한다(문자열 타입)
match:정규식으로 저장하려는 값과 비교한다.
validate:함수로 개발자가 조건을 만듭니다.
set:값을 입력할 때 함수로 조건을 만듭니다.
get:값을 출력할 때 함수로 조건을 만듭니다.
ref:해당하는 모델을 참조할 때 사용한다.
`

...
var exampleSchema = mongoose.Schema({
   firstName:{
    type:String,
    required:true,
    trim:true,
    lowercase:true  
   },
   lastName:{
    type:String,
    trim:true,
    lowercase:true
   }
   age:{
    type:Number,
    required:true,
   }
   created:{
    type:Date,
    default:Date.now
   },
   number:{
    type:Number,
    match:/^\d{3}-\d{3,4}-\d{4}$/
   },
   password:{
    type:String,
    validate:[
      function(password){
       return password&&password.length>6;
      },'비밀번호를 입력하거나 길이가 6보다커야합니다.'
     ]
   },
   author:{
    type:Schema.Types.Id,
    ref:'User'
   }
});



                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span> 메서드</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
`
스키마에 적용하는 메서드들 
두 가지 방법으로 해당하는 스키마에서 사용할 수 있는 메서드를 생성했다.
methods와 statics 두 가지 방식으로 스키마 메서드를 만들 수 있다


methods 방식은 다큐 먼스를 CRUD 하여 나타낸 객체를 연산할 때 사용하고 
statics은 CRUD 하는 메서드와 같이 모델 변수에서 전역으로 사용
`

exampleSchema.methods.hash(password){
    ...
}
exampleSchema.static.findName(name,callback){
    findOne({name:name},callback)
}

var Data = mongoose.model('data',exampleSchema);

Data.findName(name,function(err,names){
     return name;
  }
);
Data.find(function(err,users){
  users.hash(password);
 }
);

                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>트랜젝션</strong><div class="item_wrap"><dl class="item"><dt><button><span>transactions</span> 기본 개념</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
`                        
트랜잭션이란 데이터베이스의 상태를 변경하는 논리적 작업단위 
논리적 단위라 하나의 트랜잭션은 반드시 commit / rollback이 됨
이런 특성을 이용해 데이터베이스에 장애가 발생했을 때 데이터를 복구하는 작업의 단위로 사용 

트랜잭션은 크게 4가지 특징을 갖는데 이 특징들을 모두 만족해야 트랜잭션이 데이터베이스의 무결성과 일관성을 보장

A: Atomicity (all & noting)
하나의 트랜잭션 내 모든 연산이 모두 정상적으로 실행되거나, 하나라도 실패 시 모두 실행되지 말아야함

C: Consistency
트랜잭션이 성공적으로 완료된 후에도 데이터베이스는 항상 일관성 있는 상태여야 함

I: Isolation
현재 데이터베이스에 접근중인 트랜잭션이 완료될 때까지 다른 트랜잭션이 접근할 수 없다는 것을 의미
약간 동기 비동기랑 비슷

D: Durability
일단 완료된 트랜잭션은 데이터베이스에 반영되었으므로 어떠한 경우에도 이 내용이 손실되지 않고 영구적이어야 됨

`


## blog api 프로젝트에서의 문제점... 
faker로 가데이터로 만들 때 데이터 수정에 오류가 있었던 이유는 Isolation 때문임...

병렬로 데이터를 생성했기 때문에 ...
a data를 불러와서 처리하는 동안 
a data를 다른데서 동시에 처리해서 commentCount가 그대로였던 것. 


## 해결방법 
1. 트랜잭션 사용
2. db에서 바로 처리.. 
- db에서 백엔드로 가져와서 처리했을 경우 병렬로 처리(백엔드에서 처리한걸 db에서는 v로 비교함..)할 때 공백이 발생하기에 ..
"같은 데이터를 병렬로 반복 처리"해서 countCommnet의 카운터가 계속 1이었던것...
db에서 바로 처리하게 되면 그런 공백이 발생하지 않아 Isolation(일관성) 문제는 해결할 수 있음. 



## 트랜잭션을 꼭 써야할 때.. 
금융같은 숫자에 민감한 것들..한개가 성공했는데 다른 한개가 성공안한다면? 크리티컬
하지만 너무 자주 쓰면 메모리 낭비가 심함
꼭 써야할 때만 쓰기


                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Session</span>.startSession()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
import mongoose from 'mongoose'

const session = await mongoose.startSession()

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Session</span>.withTransaction()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
import mongoose from 'mongoose'

const session = await mongoose.startSession()
await session.withTransaction(async() => {
    ...
})



ex) 
// @ POST
// @ /api/blog/:blogId/comment
route.post('/', async (req, res) => {
    
    // 트랜젝션
    const session = await mongoose.startSession()
    let createComment;
    try {
         await session.withTransaction(async() => {
            const { content, userId } = req.body;
            const { blogId } = req.params;
    
            if(content && typeof content !== 'string') return res.status(400).send('is requied content') 
            if(!mongoose.isValidObjectId(userId)) return res.status(400).send('is not objectId')
            if(!mongoose.isValidObjectId(blogId)) return res.status(400).send('is not objectId')
    
            const [user, blog] = await Promise.all([
                User.findById(userId, {}, { session }), // 두번째 조건 없으니 빈 객체, 뒤에 옵션으로 추가해줘야됨
                Blog.findById(blogId, {}, { session })
            ])
            createComment = await new Comment({ content, user, blog: blogId })
    
            await session.abortTransaction() // 하나라도 잘못되었다면 기존에 적용된게 있다 하더라도..트랜잭션 중단 (아토믹) 

            blog.commentCount++;
            blog.comments.push(createComment);
            if(blog.commentCount > 3) {
                blog.comments.shift()
            }
          
           await Promise.all([
                createComment.save({ session }),
                blog.save(), // blog는 없어도 되는 이유는 findById에서 세션으로 불러왔기 때문에..
           ])
         })
         return res.status(200).json(createComment);
    } catch(error) {
        console.log(error)
    } finally {
        await session.endSession();
    }
})

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Session</span>.abortTransaction()</button></dt><dd>뭐 하나 실패했을 때 원복</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
import mongoose from 'mongoose'

const session = await mongoose.startSession()
await session.withTransaction(async() => {
    ...
    await session.abortTransaction() // 하나라도 잘못되었다면 기존에 적용된게 있다 하더라도..트랜잭션 중단 (아토믹) 
})

                    </code>
                </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>Session</span>.endSession()</button></dt><dd>세션 끝</dd></dl><div class="code_wrap"><pre>
                    <code class="javascript">
import mongoose from 'mongoose'

const session = await mongoose.startSession()
try {
    await session.withTransaction(async() => {
        ...
    })
} catch(err) {
    console.log(err)
} finally {
    session.endSession() //만든 세션 종료
}

                    </code>
                </pre></div></div></div><div class="depth_2"><strong>메서드</strong><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span>.connect()</button></dt><dd>몽고디비 연결</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
import mongoose from 'mongoose'

const dbInfo = `mongodb+srv://${process.env.DB_NAME}:${process.env.DB_PASSWORD}@mongostudy.5g49u.mongodb.net/${process.env.DB_TITLE}?retryWrites=true&w=majority`

await mongoose.connect(dbInfo).then(result => console.log('몽고디비 연결성공'))

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span>.virtual()</button></dt><dd>가상 필드 만듦</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

`
아래 같이 설정되어있는 경우 따로 필드가 없어도 
backend에서 populate({ path: 'comment' })로 Blog모델에 comment 추가해서 보내기 가능

` 




// Blog model
import mongoose from 'mongoose'

const { Schema, model, Types } = mongoose;


const BlogSchema = new Schema({
    title: { type: String, required: true, },
    content: { type: String, required: true, },
    isLive: { type: Boolean, default: false, },
    user: { type: Types.ObjectId, required: true, ref: 'user' },
}, {
    timestamps: true,
})

// comments 필드가 없으니 가상으로 만듦
// 이 필드는 db에 저장되는게 아님..데이터 보내줄 때 추가돼서 보내줌
BlogSchema.virtual('comments', {
    ref: "comment", //어디를 참조할건지
    localField: "_id", //이 필드에서 어떤 것을 
    foreignField: "blog", // 이 필드랑 어떤 관계냐 ...Comment 모델에 들어가보면 blog로 필드이름 저장되어있음.. ref아님
})

BlogSchema.set("toObject", { virtuals: true });
BlogSchema.set("toJSON", { virtuals: true });


const Blog = model('blog', BlogSchema);

export default Blog;



//Comment model
import mongoose from 'mongoose';

const { Types, model, Schema } = mongoose;


const CommentModel = new Schema({
    content: { type: String, required: true, },
    user: { type: Types.ObjectId, required: true, ref: 'user', },
    blog: { type: Types.ObjectId, required: true, ref: 'blog', } 
}, {
    timestamps: true,
})

const Comment = model('comment', CommentModel)
export default Comment;


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span>.set()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
import mongoose from 'mongoose'

mongoose.set('debug', true) 
//query


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span>.isValidObjectId()</button></dt><dd>_id 검증</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
client params로 넘어온 아이디가 몽고디비 _id와 형식? 이 같은지 검사해줌...
.isValidObjectId(_id)


import mongoose from 'mongoose'

if(!mongoose.isValidObjectId(userId)) { //isValidObjectId는 objectId 형식인지 불린값으로 리턴해줌
    res.status(400).json({ err: 'invalid userId' })
}
const user = await User.findOne({ _id: userId }) 

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>mongoose</span>.countDocuments()</button></dt><dd>문서 숫자</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
const comments = await Comment.find({ blog: req.params.blogId }).countDocuments()  // 몇개 코멘트가 있는지 ..3

                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>쿼리 옵션</strong><div class="item_wrap"><dl class="item"><dt><button><span>{</span> new: true <span>}</span></button></dt><dd>db 업데이트된 값 반환</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
const post = new Post({ ...req.body, params }, { new: true })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>{</span> arrayFilters: [{}] <span>}</span></button></dt><dd>조건 필터</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">





그냥 text: [{ }]  
위 구조일 때는 
Project.findByIdAndUpdate(projectId, { $pull: { "joinUser": { _id: userId } } }, { new: true }),



text: [{ text2: [ {  } ] }]
위 구조일때는 
arrayFilters 써야됨
           
ex1) 
db 구조 
joinProjects: [
    { _id: { type: Types.ObjectId, ref: 'project'}, state: { type: Boolean, default: false } }
],

필터
User.findByIdAndUpdate(userId, { "joinProjects.$[ele].state": true }, { arrayFilters: [{"ele._id": projectId}], new: true })

1. joinProjects 필드 안에 배열 중 $[ele] 이 아래 있는 state를 : true로 
2. $[ele]는 뒤에서 arrayFilters로 넣어줌 = 위에서는 ele._id: projectId 로 필터




ex2)
// model
User 
Blog (user, cooments: [ comment_info, user ]) 
Comment (user, blogId)

user: { name: { first: '', last: '' } }

const user = await User.findById(req.body.userId)

if(req.body.name.first) {
    // Comment 모델에 있는 user정보 업데이트 
    await Comment.updateMany({ 'user._id' }, { 'user.name.first': user.name.first })

    // Blog 모델에 있는 user정보 업데이트
    await Blog.updateMany({ 'user._id' }, { 'user.name.first': user.name.first })

    // Blog 모델에 있는 comments:[] 필드안에 있는 user정보 업데이트
    await Blog.updateMany(
        { 'comments.user._id': userId }, // 인덱스를 찾을 수 있으면 효율 더 좋음
        { 'comments.$[comm].user': user.name.first }, // comments필드에 .$ 인덱스 선택 [comm] 필터에 쓸 변수같은? 
        { arrayFilters: [ {'comm.user._id': req.body.userId} ] }, // arrayFilters 옵션에 여러 조건을 넣는다..
    )
}
                                
/* 
    await Blog.updateMany({}, 
        { 'comments.$[ele].users.$[user].username': user.name.first }, 
        { arrayFilters: [ {"ele.user._id": userId}, 
        {"user._id": userId} ] })
    comments 필드안에 users 배열이 있고 그 안에 username을 필터링해서 바꿔줌 

*/


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>{</span> upsert: true <span>}</span></button></dt><dd>값이 없다면 추가</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.people.update({ name: "Elly" }, { name: "Elly", age: 17 }, { upsert: true } })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>search</button></dt><dd>검색</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
BlogSchema.index({ title: 'text', }) //search - text inexing... 인덱싱은 중간에 저장해도 키가 만들어짐

// 검색
{ $text: { $search: 'rerum'  } }

//2개 중 하나만 포함해도 
{ $text: { $search: 'rerum abc'  } }



// 두개 필드에서 검색 (복합키) 
BlogSchema.index({ title: 'text', content: 'text' })  



// 단점
// 정상 단어가 아니면 검색이 안됨 



-------------------------------

// blog 만들땐 정규표현식으로 find 함 

router.get('/:searchTerm', async(req, res, next) => {
    try {
        const result = await Post.find({
           title: {
               $regex: req.params.searchTerm,
               $options: 'i',
           }
        });

        console.log('search result', result)
        res.status(200).json(result);

    } catch(err) {
        console.log(err)
        next(err)
    }
})
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span></span>select()</button></dt><dd>원하는 필드만</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

db구조
joinUser: [{
    _id: { type: Types.ObjectId, ref: 'user' },
    state: { type: Boolean, default: false },
}]

const isUser = await Project.findById(projectId).select({'joinUser': {$elemMatch: { _id: userId }} })


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>push</button></dt><dd>배열 값 추가</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

그냥 text: [{ }]  
위 구조일 때는 
Project.findByIdAndUpdate(projectId, { $push: { "joinUser": { _id: userId } } }, { new: true }),


text: [{ text2: [ {  } ] }]
위 구조일때는 
arrayFilters 써야됨
                                
----------------------------------------------


db구조
joinUser: [{
    _id: { type: Types.ObjectId, ref: 'user' },
    state: { type: Boolean, default: false },
}]

const project = await Project.findByIdAndUpdate(projectId, { $push: { "joinUser": { _id: userId } } }, { new: true })



// Charlie document의 skills 배열에 "angularjs" 추가
> db.people.update(
... { name: "Charlie" },
... { $push: { skills: "angularjs" } }
... )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

출처: velopert.log: https://velopert.com/479

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>pull</button></dt><dd>배열 값 삭제</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">


그냥 text: [{ }]  
위 구조일 때는 
Project.findByIdAndUpdate(projectId, { $pull: { "joinUser": { _id: userId } } }, { new: true }),


text: [{ text2: [ {  } ] }]
위 구조일때는 
arrayFilters 써야됨



-----------------------------------------                     

db.book.find({
    "auther":{
            $elemMatch: {"name":"park"} // auther배열객체 들 중에서 {"name":"park"} 검색.
    }
})


//북 db 구조 

...: 
auther: [ { "name": "park", "age": 30 } ]


출처: https://inpa.tistory.com/entry/MONGO-%F0%9F%93%9A-Embedded-%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4-%EA%B2%80%EC%83%89-%EC%BF%BC%EB%A6%AC#$elemMatch







// Charlie document에서 skills 값의 mongodb 제거
// 얘는 무조건 객체여야하는듯? 
// $push 는 []구조면 []로 넣어주고 ..$pull은 []도 {}으로 ...


유저 구조- projects: [ {_id: projectId, date: []} ]
await Promise.all([
    Project.deleteMany({ _id: projectId }),
    User.updateOne({_id: userId}, { $pull: {projects: {_id: projectId} } }, { new: true })
])





db.people.update(
  { name: "Charlie" },
  { $pull: { skills: "mongodb" } }
)

// 다른 모델 하위에 있는 연결된 코멘트 지우기
Blog 
  commnets: [...]

await Blog.updateOne({ 'comments._id': req.params.commentId }, { $pull: { comments: { _id: commentId } } })
// comments._id 선택하고 $pull: { 삭제할 필드: { 삭제조건 }, { 삭제조건 } }  둘 중 하나만 걸리면 삭제
 
// elemMatch....
// comments._id 선택하고 $pull: { 삭제할 필드: $elemMatch: { { 삭제조건 }, { 삭제조건 } } } 둘다 맞아야 삭제



                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>pop</button></dt><dd>조건 idx 빼주기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
$pop: { field: idx }

$pull은 조건에서 뺴는거고 $pop은 인덱스로 뺴는거
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>elemMatch</button></dt><dd>둘 다 맞으면</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

// 다른 모델 하위에 있는 연결된 코멘트 지우기
Blog 
  commnets: [...]

await Blog.updateOne({ 'comments._id': req.params.commentId }, { $pull: { comments: { _id: commentId } } })
// comments._id 선택하고 $pull: { 삭제할 필드: { 삭제조건 }, { 삭제조건 } }  둘 중 하나만 걸리면 삭제
 
// elemMatch....
// comments._id 선택하고 $pull: { 삭제할 필드: $elemMatch: { { 삭제조건 }, { 삭제조건 } } } 둘다 맞아야 삭제



//find ex
$elemMatch 연산자
$elemMatch 연산자는 Embedded Documents 배열을 쿼리할때 사용됩니다. 저희 mock-up data 에서는 comments 가 Embedded Document에 속합니다.

예제11: comments 중 “Charlie” 가 작성한 덧글이 있는 Document 조회
db.articles.find( { “comments”: { $elemMatch: { “name”: “Charlie” } } } )




// 배열과 오브젝트일때 쿼리 
https://koonsland.tistory.com/120


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>set</button></dt><dd>특정 필드 추가 및 업데이트</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.people.update( { name: "Abet" }, { $set: { age: 20 } } )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })



// document를 replace 하기
// Betty document를 새로운 document로 대체한다.
> db.people.update( { name: "Betty" }, { "name": "Betty 2nd", age: 1 })
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>unset</button></dt><dd>특정 필드 삭제</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.people.update( { name: "David" }, { $unset: { score: 1 } } )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>eq</button></dt><dd>조건에 일치한 값</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>ne</button></dt><dd>조건에 일치하지않는 값</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>lt</button></dt><dd>미만</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>lte</button></dt><dd>이하</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
// age가 20 보다 낮거나 같은 document의 score를 10으로 설정
db.people.update(
        { age: { $lte: 20 } },
        { $set: { score: 10 } },
        { multi: true }
        )
WriteResult({ "nMatched" : 3, "nUpserted" : 0, "nModified" : 0 })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>gt</button></dt><dd>초과</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>gte</button></dt><dd>이상</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>sort</button></dt><dd>정렬</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.people.update(
    ... { name: "Charlie" },
    ... { $push: {
    ...     skills: {
    ...         $each: [ "c++", "java" ],
    ...         $sort: 1
    ...     }
    ...   }
    ... }
... )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })


$sort 값을 내림차순으로 정렬하려면 -1 로 하면 됩니다.
$sort: { KEY: -1 }

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>in</button></dt><dd>특정 키값 검색해서 있으면 채우기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.nettuts.find( { 'occupation' : { '$in' : [ "actor", "developer" ] } }, { "first" : 1, "last" : 1 } );
in은 특정 key의 값이 ㅁㅁㅁ인 경우에 사용한다.
이렇게 사용한다. 이렇게 쿼리를 작성하면 occupation 이 actor이거나 developer인 것을 가져온다.
first 와 last 에 각각 1이 있으므로 오름차순으로 정렬한다.




출처: https://fors.tistory.com/403 [Code]

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>nin</button></dt><dd>in 반대</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.nettuts.find( { 'occupation' : { '$in' : [ "actor", "developer" ] } }, { "first" : 1, "last" : 1 } );

occupation 이 actor도 아니고 developer도 아닌 것을 가져온다.

출처: https://fors.tistory.com/403 [Code]

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>or</button></dt><dd>주어진 조건 중 하나라도 있으면</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
const existingUser = await User.findOne({$or: [{id: id}, {phoneNumber: phoneNumber}] });
if(existingUser) return res.status(400).json({ message: '유저가 이미 존재합니다' });
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>and</button></dt><dd>주어진 조건이 모두 맞을 때</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>not</button></dt><dd>주어진 조건이 아닐 때</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.nettuts.find( { 'occupation' : { '$not' : [ "actor", "developer" ] } }, { "first" : 1, "last" : 1 } );
not 뒤의 조건이 아닌 경우를 찾는다.


출처: https://fors.tistory.com/403 [Code]
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>nor</button></dt><dd>주어진 조건이 모두 아닐 때</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>regex</button></dt><dd>정규 표현식</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.nettuts.find( { "first" : /(ma|to)*/i, "last" : /(se|de)/i  } );
// 이렇게 쿼리를 작성하면 first가 ma 또는 to 로 시작하는 것을 가져온다.


//그리고 last 가 se 또는 de로 시작하는 것도 가져온다.
//특정 문자를 포함하는 결과를 모두 가져오려면 이렇게 하면 된다.


db.nettuts.find( { "first" : { $regex : /(ma)/ } } );
//이렇게 하면 ma가 앞뒤로 포함된 모든 결과를 가져온다.


출처: https://fors.tistory.com/403 [Code]




https://velopert.com/479 여기부터 하면 됨

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>inc</button></dt><dd>값 증가</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
조회수 증가, 포인트 증감에 사용하면 됨

collection.update(
  {$inc: {'count': 1}
})



감소할 땐 -1

collection.update(
  {$inc: {'count': -1}
})

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>each</button></dt><dd>여러개</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
// 여러개 동시. 반복문 비슷~
model.findOneAndUpdate(id, { $push: { comments: { $each: [푸시할거 1, 푸시할거 2] } } })  


// 카운트 하면서 특정갯수만 푸시.. 아래 예제는 최근 3개만 넣고 다 삭제 
model.findOneAndUpdate(id, { $inc: 1, $push: { comments: { $each: [푸시할거], $slice: 3 } } }) 
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>$</span>slice</button></dt><dd>잘라내기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-3 : 예전 3개만 빼고 다 삭제 
3 : 최근 3개 뺴고 다 삭제


// 카운트 하면서 특정갯수만 푸시.. 아래 예제는 최근 3개만 넣고 다 삭제 
model.findOneAndUpdate(id, { $inc: 1, $push: { comments: { $each: [푸시할거], $slice: 3 } } }) 
                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>생성</strong><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.insert()</button></dt><dd>단일, 다수 생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
db.products.insert( { item: "card", qty: 15 } )


                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.insertOne()</button></dt><dd>단일 생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
insertOne({ name: " aaa ", email: " dd@dd.com " }) - 한개만 생성
insertOne({ name: { a: "aa", b: "bb" }, email: " dd@dd.com " }) - 객체도 배열도 넣기 가능 
※ 근데 불러올 땐 findOne({ "name.a": "aa" }) - 이런식으로 해야됨 객체접근에 "" 넣기 꼭!

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.insertMany()</button></dt><dd>다수 생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>instance</span>.save()</button></dt><dd>생성</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

import { User } from '../model/User'

app.post('/user', async (res, req) => {
    try {
        // 여기 검증은 유저가 잘못입력한거라 400
        let { username, name } = req.body; 
        if(!username) return res.status(400).send({ err: 'username is required' })
        if(!name || !name.first || !name.last) return res.status(400).send({ err: 'name is required' })


        const user = new User(req.body) //백엔드(몽구스)에 먼저 유저 인스턴스생성
        await user.save() // 디비에 저장..promise 리턴
        // 위 방식이면 몽구스에서 생성해서 디비에 저장한게 됨 
        // findOneAndUpdate(userId, {}, { new: true }) 이런 방식은 동시에 실행한거라 디비에서 작업이 이뤄짐

        return res.status(200).json(user)
    } catch(err) {
        console.log(err)
        return res.status(500).json({ err: err.message }) //여긴 서버에러라 500
    }
})





## 중요
.findOneAndUpdate()  vs   .save()


1) 이 방식은 두번 호출하지만 백엔드에서 불러온 데이터를 한번 수정할 수 있다는 장점이 있음..
단점은 두번 요청한다는 것(크게 무리가 가지 않는다고 함)  
.findOne()  
.save()

// 조회와 업데이트 모두 한방에 ! 방법 1 
let bodyObj = {}
if(req.body.age) bodyObj.age = req.body.age
if(req.body.name) bodyObj.name = req.body.name
if( req.body.email) bodyObj.email = req.body.email

console.log(bodyObj, 'asdasd')
"name": { "first": "cc", "last": "ee" }

//console.log(req.body)
const user = await User.findByIdAndUpdate(userId, {
    username: req.body.username,
   $set: { bodyObj },

}, { new: true })
const user = await User.findByIdAndUpdate(userId, bodyObj, { new: true })


----------------------------


2) 이 방식은 한번 처리되고 디비에서 작업이 이뤄짐. 요청이 한번만 이뤄지지만 복잡한 수정, 검증은 힘듦
.findOneAndUpdate()
.findOneAndDelete()
등등

// 조회 한번 하고 가져온 다음 업데이트하는 방법 2... 
// 이 방법은 검증이나 수정이 복잡하거나 여러 인스턴스를 가져와서 복잡적으로 수정해야 될 경우 
const user = await User.findById(userId) //가져와서 
if(req.body.age) user.age = req.body.age; // 검증함 하고 !
if(req.body.name) user.name = req.body.name;
user.save()  //담는다! 여기서 save()는 실제로 update 메서드가 실행됨..


// 이런식으로 했을 땐 { new: true } 도 필요없음..백엔드에서 몽구스로 가져온 다음 수정해서 다시 보내기 때문.
// 몽구스가 바뀐 것만 알아서  찾아주기 때문에 검증 후 새 객체에 넣어줄 필요도 없음 
res.status(200).json(user)

 

                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>검색</strong><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.skip()</button></dt><dd>검색 시작 위치</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
model.find().skip(3) // 데이터 인덱스 4부터 검색

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.limit()</button></dt><dd>몇개 검색</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
model.find().limit(10) //10개 검색

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.populate()</button></dt><dd>ObjectId를 검색해서 채워주기</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

https://www.zerocho.com/category/MongoDB/post/59a66f8372262500184b5363




//ObjectId로 연결되어있는 필드를 해당 필드 검색해서 mongoose가 $in으로 값을 채워 넣어줌 
model.populate({ path: '해당 ObjectId 연결된 필드명' })
ex)  user: { type: Types.ObjectId, required: true, ref: 'user' },



// 한개 추가 
model.populate({ path: 'user' }) 

// 여러 모델 넣기
model.populate([ {path: 'comment'}, {path: 'user'} ]) 

// 모델 아래 하위 모델 넣기 
model.populate({ path: user, populate: { path: 'user' } })



------------------------------

//모델구조
import mongoose from 'mongoose'

const { Schema, model, Types } = mongoose;

const BlogSchema = new Schema({
    title: { type: String, required: true, },
    content: { type: String, required: true, },
    isLive: { type: Boolean, default: false, },
    user: { type: Types.ObjectId, required: true, ref: 'user' },
}, {
    timestamps: true,
})

// comments 필드가 없으니 가상으로 만듦
// 이 필드는 db에 저장되는게 아님..데이터 보내줄 때 추가돼서 보내줌
BlogSchema.virtual('comments', {
    ref: "comment", //어디를 참조할건지
    localField: "_id", //이 필드에서 어떤 것을 
    foreignField: "blog", // 이 필드랑 어떤 관계냐 ...Comment 모델에 들어가보면 blog로 필드이름 저장되어있음.. ref아님
})

BlogSchema.set("toObject", { virtuals: true });
BlogSchema.set("toJSON", { virtuals: true });

const Blog = model('blog', BlogSchema);
export default Blog;

----------------------------

const allBlog = await Blog.find().populate([{ path: 'user' }, { path: 'comments', populate: { path: 'user' } }])



### 객체 뎁스 안에 또 아이디로 저장되어 있을 경우 둘다 퍼퓰시킬 때 

- db 구조 
  _id: { 
    type: mongoose.Schema.Types.ObjectId, ref: 'user' 
    target: { type: mongoose.Schema.Types.ObjectId, ref: 'project' }
    },

- backend query 
  await Model.findbyId(id).populate("_id.target")
  
  이렇게 해주면 _id, target 둘 다 퍼퓰해줌
  

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.find()</button></dt><dd>다수 검색 (배열반환)</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
// 모두검색
.find({ 탐색 }, { 수정할 것 }, { 옵션 }) 


// 특정값으로 검색 
db.monsters.find({ name: 'Slime' }); // { 슬라임 }
db.monsters.find({ name: 'Slime', hp: 25 }); // name이 Slime이고 hp가 25인 다큐먼트


// 여러 조건 중 한가지만 해당
db.monsters.find({ $or: [{ name: 'Slime' }, { hp: 50 }] }); // name이 Slime이거나 hp가 50



// 
db.monsters.find({ hp: { $lt: 100 } }); // hp가 100보다 다큐먼트



// 특정조건 나중 추가
// db 구조 : 1뎁스 public: {type: Boolean, require: true, default: false,}
DB.find({ public: true }); 

// db 구조 : 2뎁스 public: {type: Boolean, require: true, default: false,}
DB.find({ "1뎁스.public": true }); 




                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findOne()</button></dt><dd>하나 검색 (객체반환)</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

사용법
.findOne(검색할애, { 조건 })


// 특정 값으로 찾기 
findOne({ name: " aaa " }) - 이렇게 하면 name: " aaa " 해당하는 것 한개만 불러옴


// 특정 유저아이디로 찾기 
app.get('/user/:userId', async (req, res) => {
    try {
        ...
        if(!mongoose.isValidObjectId(userId)) { //isValidObjectId는 objectId 형식인지 불린값으로 리턴해줌
            res.status(400).json({ err: 'invalid userId' })
        }

        const { userId } = req.params
        const findUser = await User.findOne({ _id: userId })
        res.status(200).json(findUser)

    } catch(err) {
        ...
    }
})



//배열 조회 
db.zero.find({ interest: 'mongodb' });


// 객체 조회 
db.zero.find({ 'profile.birth': 1994 });


// 특정 요소만 불러오고 싶을 때 .. Slime을 찾아서 그 안에 name, hp를 가져오고 _id는 안가져옴
db.monsters.findOne({ name: 'Slime' }, { name: true, hp: true, _id: false});




                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findByid()</button></dt><dd>아이디로 검색</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

const user = await User.findById(req.params.userId)

                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>수정</strong><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.update()</button></dt><dd>수정</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

몽고 3.2? 부턴가 update 대신 updateOne / updateMany 사용권장

-
update 아토믹하다 
*아토믹(원자성): 모두 반영되거나 모두 롤백되거나 

아토믹 참고
https://chrisjune-13837.medium.com/db-transaction-%EA%B3%BC-acid%EB%9E%80-45a785403f9e 
                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.updateOne()</button></dt><dd>하나 찾아 업데이트</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
model.updateOne({ 선택 }, { 바꿀거 })

// 아이디로 찾아 변경
model.updateOne({ _id: '62143c5831b0efa850896c86' }, { content: req.body.content })

// 하위에 있는 배열 컨텐츠 변경  '' + .으로 접근 
model.updateOne({ 'comments._id': req.params.commentId }, { 'comments.$.content': req.body.content })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.updateMany()</button></dt><dd>조건에 맞는 여러개 업데이트</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-
model.updateMany({ 선택 }, { 바꿀거 })

// 아이디로 찾아 모두 변경
model.updateMany({ _id: req.params.userId }, { content: req.body.content })

// 하위에 있는 배열 컨텐츠 변경  '' + .으로 접근 
model.updateMany({ 'comments._id': req.params.commentId }, { 'comments.$.content': req.body.content })

// 유저정보 변경시 연결되어있는 모델 모두 변경

// model
User 
Blog (user, cooments: [ comment_info, user ]) 
Comment (user, blogId)

user: { name: { first: '', last: '' } }

const user = await User.findById(req.body.userId)

if(req.body.name.first) {
    // Comment 모델에 있는 user정보 업데이트 
    await Comment.updateMany({ 'user._id' }, { 'user.name.first': user.name.first })

    // Blog 모델에 있는 user정보 업데이트
    await Blog.updateMany({ 'user._id' }, { 'user.name.first': user.name.first })

    // Blog 모델에 있는 comments:[] 필드안에 있는 user정보 업데이트
    await Blog.updateMany(
        { 'comments.user._id': userId }, // 해당 인덱스 있으면 넣는게 더 효율좋음
        { 'comments.$[comm].user': user.name.first }, // comments필드에 .$ 인덱스 선택 [comm] 필터에 쓸 변수같은? 
        { arrayFilters: [ {'comm.user._id': req.body.userId} ] }, // arrayFilters 옵션에 여러 조건을 넣는다..
    )
}


/* 
    await Blog.updateMany({}, { 'comments.$[ele].users.$[user].username': user.name.first }, { arrayFilters: [ {"ele.user._id": userId}, {"user._id": userId} ] })

    comments 필드안에 users 배열이 있고 그 안에 username을 필터링해서 바꿔줌 

*/

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findOneAndUpdate()</button></dt><dd>검색 후 수정 (반환)</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

findOneAndUpdate은 아토믹하다 
*아토믹(원자성): 모두 반영되거나 모두 롤백되거나 


업데이트된 콜렉션 반환받고 싶으면 이거~

app.put('/user/update/:userId', async (req, res) => {
    try {

        ...
        const { age } req.body // 넘어온 age data
        const user = await User.findOneAndUpdate(req.params.userid, 
            { $set: { age: age } }, 
            { new: true }
        )
        // 해당 아이디의 값중에 age를 바꿈
        // new: true는 업데이트하고 난 다음 문서를 리턴해줌 ...안하면 안바뀐거 리턴

    } catch(err) {
        ....
    }
})




ex)
// @ path  /api/user/
router.put('/update/:userId', async(req, res) => {
    try {
        const { userId } = req.params 

        if(!mongoose.isValidObjectId(userId)) {
           res.status(400).json({ err: 'invalid userId' }) 
        }
        if(!req.body.age && !req.body.name) {
            res.status(400).json({ err: 'age or name is required' }) 
        }
        if(req.body.age && typeof req.body.age !== 'number') {
            res.status(400).json({ err: 'age must be a number' }) 
        }
        if(req.body.name && typeof req.body.name.first !== 'string' && typeof req.body.name.last !== 'string') {
            return res.status(400).json({ err: 'name must be a string' }) 
        }

        // 조회와 업데이트 모두 한방에 ! 방법 1 
        // let bodyObj = {}
        // if(req.body.age) bodyObj.age = req.body.age
        // if(req.body.name) bodyObj.name = req.body.name
        // if( req.body.email) bodyObj.email = req.body.email

        // console.log(bodyObj, 'asdasd')
        // "name": { "first": "cc", "last": "ee" }

        // console.log(req.body)
        // const user = await User.findByIdAndUpdate(userId, {
        //     // username: req.body.username,
        // //    $set: { bodyObj },
        
        // }, { new: true })
        // const user = await User.findByIdAndUpdate(userId, bodyObj, { new: true })


        // 조회 한번 하고 가져온 다음 업데이트하는 방법 2... 
        // 이 방법은 검증이나 수정이 복잡하거나 여러 인스턴스를 가져와서 복잡적으로 수정해야 될 경우 
        const user = await User.findById(userId) //가져와서 
        if(req.body.age) user.age = req.body.age; // 검증함 하고 !
        if(req.body.name) user.name = req.body.name;
        user.save()  //담는다! 여기서 save()는 실제로 update 메서드가 실행됨..


        // 이런식으로 했을 땐 { new: true } 도 필요없음..백엔드에서 몽구스로 가져온 다음 수정해서 다시 보내기 때문.
        // 몽구스가 바뀐 것만 알아서  찾아주기 때문에 검증 후 새 객체에 넣어줄 필요도 없음 
        res.status(200).json(user)



    } catch(err) {
        console.log(err)
    }
})

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findByIdAndUpdate()</button></dt><dd>아이디 검색 후 수정</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">

findByIdAndUpdate은 내부적으로 findOneAndUpdate가 실행됨
findOneAndUpdate은 아토믹하다. 따라서 findByIdAndUpdate도 아토믹하다
*아토믹(원자성): 모두 반영되거나 모두 롤백되거나 

아이디로 찾을거면 findByIdAndUpdate
그 외로 찾을거면 findOneAndUpdate

*_id는 인덱싱이 되어있음.






                            </code>
                        </pre></div></div></div><div class="depth_2"><strong>삭제</strong><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.deleteOne()</button></dt><dd>하나 삭제</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
얘는 삭제만 함.. 
콜렉션을 받을 필요없으면 얘가 좀 더 효율적  

const user = await User.deleteOne({ _id: params userId })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.deleteMany()</button></dt><dd>여러개 삭제</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
얘는 삭제만 함.. 
콜렉션을 받을 필요없으면 얘가 좀 더 효율적  


projectId가 ["id", "id"] 배열로와도, "id" 문자열로 와도 .. {_id: "id"}객체로 와도 삭제가 됨
const project = await Project.deleteMany({ _id: projectId });

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findOneAndDelete()</button></dt><dd>검색 후 하나 삭제 (유저반환)</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
검색 후 삭제.. 
콜렉션 받을거면 이거 써야됨
이유는 검색했는데 없으면 null이라서~


const user = await User.findOneAndDelete({ _id: params userId })

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.findOneAndRemove()</button></dt><dd>-</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
-

                            </code>
                        </pre></div></div><div class="item_wrap"><dl class="item"><dt><button><span>model</span>.exec()</button></dt><dd>온전한 promise로 만듦</dd></dl><div class="code_wrap"><pre>
                            <code class="javascript">
findOne findOneAndUpdate findOneAndDelete 등은 유사 프로미스 
.exec() 을 붙이면 온전한 프로미스 객체가 됨 

붙이든 안붙이든 동일하지만 에러 발생 시 stack trace에 코드 위치가 표기 되기에 붙이는걸 권장


--10 17 수정
업데이트 후 .exec()안붙이면 바로 실행안될수도 있음 
업데이트 메서드들에 콜백이 있는데 콜백 사용안할거면 .exec() 붙이자

                            </code>
                        </pre></div></div></div></section></div></main><footer><div class="global_wrap"><ul class="info">asdasdsa</ul></div></footer></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>