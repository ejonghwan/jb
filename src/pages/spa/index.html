<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
   
    <title>Document</title>
</head>
<body>

    <div class="wrap">
        <header>
            <nav class="global_wrap sub">
                <ul class="line"></ul>
            </nav>
        </header>
        <main>
            <div class="global_wrap">
                
                <!-- performence -->
                <section class="conts">
                    <h2>performence</h2>

                    <div class="depth_2">
                        <strong>리소스 관리</strong>
                   
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>성능</button></dt>
                            <dd>
                                로딩성능 | 렌더링 성능 
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
성능최적화에는 아래 두 가지로 나뉨  

# 로딩성능 
: 필요한 자원들을 미리 로드하거나 지연로드 
- 이미지 최적화 
- code split (코드분할)
- 리소스 텍스트 압축
- 컴포넌트 레이지 로딩 
- 컴포넌트 프리로딩 
- 이미지 프리로딩 


# 렌더링 성능 
: 필요한 자원들을 화면에 렌더링 
- bottleneck 코드 최적화
- reflow, repaint 최적화



`performance 탭 선.. 
요청연결준비 | 요청 | 다운로드 | 메인스레드 처리 `

                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                     <!-- item -->
                     <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>이미지</button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
// 구글에서 배포한 이미지 최적화 앱
squoosh.app 



# cdn 이미지는 파라미터로 이미지 사이즈 조절하기 
(없다면 여기서 생성 https://imgix.com/)


# 이미지 사이즈 너무 큰거넣지 않기..레티나 대응해서 2~3배 사이즈 


# picture, webp 쓰기 
&lt;picture&gt;
    &lt;source srcSet={main_items} type="image/webp" /&gt;
    &lt;img  data-src={main_items} ref={imgRef_1} /&gt;
&lt;/picture&gt;



# intersection observer API 사용하기 

import React, { useEffect, useRef } from 'react'
const App = () => {

    const imgRef = useRef(null) 
    useEffect(() => {

        const options = {}
        const callback = (entries, obsever) => {
            entries.forEach(item => {
                if(item.isIntersecting) {
                    item.target.src = item.target.dataset.src
                    item.target.previousSibling.src = item.target.previousSibling.dataset.srcset //야는 ref로 안잡아놔서 옵저브안되고 있었음
                    observer.unobserve(item.target)
                }
            })
        }
        const observer = new IntersectionObserver(callback, options)
        observer.observe(imgRef.current)

    }, [])


    return (
        &lt;ficture&gt;
            &lt;source data-srcset={main_items} type="image/webp" /&gt;
            &lt;img data-src={'../assets/main1.jpg'} ref={imgRef} alt&gt;
        &lt;/ficture&gt;
    )
}
                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>비디오</button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
# webm 압축해서 사용 
변환프로그램으로 webm으로 변환
주의점은 화질 많이 떨어지니 영상이 주가 아닌 사이트에 사용 

webm은 브라우저 호환이 별로 안좋으니 &lt;video&gt;&lt;/video&gt;태그로 분기 

https://www.media.io/ko/video-compressor.html



# 예제
import Video_webm from './video.webm'
import Video from './video.mp4'

&lt;video
    autoPlay
    loop
    muted
&gt;
    &lt;source src={Video_webm} type="video/webm" /&gt;
    &lt;source src={Video} type="video/mp4" /&gt;
&lt;/video&gt;

https://developer.mozilla.org/ko/docs/Web/HTML/Element/Video



# 그 외 동영상 화질저하 가려보기
- 동영상 루프 시간 조금 줄이기 
- 동영상 앞에 패턴주기 
- css blur 사용하기
                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>폰트</button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
FOUT (IE, 엣지) 방식 : 시스템폰트 였다가 웹폰트가 늦게 먹어서 움찔거림
FOIT (크롬) 방식 : 웹폰트가 다운로드 다 받아져야 폰트자체가 생겨남 


해결방법(구글에서는 preload와 optional 권장)


# 폰트 적용 시점 컨트롤

font-display: 속성 이용
auto 
- 브라우저 기본동작

block 
- FOIT (timeout = 3s...3초까진 기다렸다가 그래도 안나오면 시스템폰트 적용)

swap 
- FOUT (기본폰트 적용 이후 웹폰트)

fallback 
- FOIT (timeout = 0.1s)... 0.1초만에 기본폰트를 보여주고 
    3초 이후에도 웹폰트를 다운로드 못했을 시 기본폰트를 쭉 보여주고 웹폰트는 캐시.. 
    다음엔 바로 캐시 웹폰트로보여줌

optional 
- FOIT(timeout = 0.1s)... fallback이랑 비슷하지만 네트워크 상태에 따라 
    기본폰트로 유지할지 웹폰트로 적용할지 결정, 이후 캐시



# 폰트 사이즈 줄이기   
(EOT > TTF/OTF > WOFF > WOFF2) 용량 낮은순
https://transfonter.org/ (폰트변환)


# 웹폰트 포멧 사용
@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
        url('./assets/fonts/fontname.woff2') format('woff2'), //이거 지원안하면 아래꺼 적용
        url('./assets/fonts/fontname.woff') format('woff'),
        url('./assets/fonts/fontname.ttf') format('truetype');
    font-display: block;
    unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 
}


# local 폰트 사용 (위에꺼처럼)
src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
만약 FOIT 방식으로 적용하고 움찔하는걸 없애려면 시스템폰트와 웹폰트가 비슷한걸 쓰고 방식을 FOIT로 됨 


# Subset 사용 (특정문자 몇개만  사용 할 때)
만약 2글자만 웹폰트를 사용한다면 필요한 2글자만 자를 수 있음 
(1) https://transfonter.org/  접속 
(2) 하단 Subset 옵션(특정 폰트) 설정하거나 Charactoers(특정 문자)에 넣고싶은 문자만 넣고 Convert 
(3) Convert 된 subset 폰트파일 css에 적용

- 단점은 다른곳에서 폰트적용을 했을 때 쓰지않아도 다운로드함. 이 단점을 없애려고 unicode range 적용
unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 


# Unicode Range 적용 (위에꺼 단점 대응)
unicode-range: u+0041,u+0042,u+0043,u+0044,u+0045,u+0046,u+0054 // A에 대한 폰트가 있을 때만 폰트파일 다운로드 

Array.prototype.map.call('ABCDEFT', c => 'u+' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4)).join(',') //유니코드 뽑아내는 코드 u+0041,u+0042,u+0043,u+0044,u+0045,u+0046,u+0054


# data-uri로 변환 (웹팩 이미지 메모리저장하는거랑 비슷한 방식)
(1) https://transfonter.org/  접속 
(2) 하단 Subset 옵션(특정 폰트) 설정하거나 Charactoers(특정 문자)에 넣고싶은 문자만 넣고 
(3) 상단 base64 encode  온!! 하고 Convert


3번 Subset과 용량은 비슷하지만 네트워크 요청시간을 줄이고 css불러올떄 같이불러옴  

@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
            url('data:app~~~asasfasdas~') format('woff2'), //이거 지원안하면 아래꺼 적용
            url('data:app~~~asasfasdas~') format('woff'),
            url('data:app~~~asasfasdas~') format('truetype');
    font-display: block;
    unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 
}
                                
                    

# 폰트 프리로드 
- 보통은 css를 읽으면서 @font-face를 읽을 때 폰트가 필요해! 하고 다운로드하지만 
    프리로드는 그 전에 다운로드 하는 기법

1. HTML 에서 사전로드를 하고 
&lt;link rel="preload" href="주소나 경로.woff2" as="font" type="font/woff2" crossorigin /&gt;

2. @font-face 에서 사용.. 1번에서 사전 로드했으니 css에서 아래 소스를 만나도 로드하지않음
@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
            url('./assets/fonts/fontname.woff2') format('woff2'), //이거 지원안하면 아래꺼 적용
            url('./assets/fonts/fontname.woff') format('woff'),
            url('./assets/fonts/fontname.ttf') format('truetype');
    font-display: block;
    }


!! 여기서 질문?  이거 질문올림
@font-face가 들어있는 css 자체를 preload로 사전로드하면 폰트도 사전로드 될까 ?  
                                



# font preload를 CRA 사용시 문제점 
빌드할 때마다 preload의 href를 변경해줘야하는데 
웹팩을 커스텀  해주면 해결 
https://www.npmjs.com/package/react-app-rewired?activeTab=dependents


1. 다운로드 
npm i -D react-app-rewired

2. 스크립츠 수정
package.json
"scripts": {
    -   "start": "react-scripts start",
    +   "start": "react-app-rewired start",


3. 루트경로에 아래 파일 추가 하고 내용추가
// config-overrides.js
module.exports = function override(config, env) {
    //do stuff with the webpack config...
    return config;
  }


4. 웹팩 플로그인 모듈 설치 
npm i -D preload-webpack-plugin 

...이거 설치안됨 

5. 설정파일 수정 
// config-overrides.js

import preloadWebpackPlugin = require('preload-webpack-plugin ')
module.exports = function override(config, env) {
    
    config.plugins.push(new preloadWebpackPlugin({
        rel: 'preload',
        as: 'font',
        include: 'allAssets', 
        fileWhitelist: [/(.woff2?)/i]
    }))

    return config;
  }


                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button>텍스트 압축 <span>서버 | 빌드</span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
서버에서 압축해줌 -> 클라이언트에서 압축해제
무분별하게 압축하면 성능이 오히려 떨어지고 2kb 이상만 하는게 좋음

응답받은 헤더에 Content-Encoding: gzip 항목... (gzip으로 압축되어있는 파일)




웹상 압축방식은 크게 두가지 (gzip이 조금 더 좋음) 
1. GZIP 
2. Deflate (LZ77)






Compress(압축) + Minify(경량화?) 둘다 적용하는게 베스트


# Compress(압축) - 서버
네트워크 전송 시, 텍스트 데이터 자체를 압축하는 작업
쉽게 생각해서 zip으로 압축하듯이 압축한다고 생각하시면 됩니다.
일반적인 텍스트 파일(html, js, css 등)들은 압축을 통해 사이즈를 줄일 수 있습니다.
웹에서 사용하는 압축방식은 gzip입니다.
텍스트의 패턴에 따라 많게는 1/10, 적게는 1/5까지 사이즈가 줄어듭니다.
이렇게 정리할 수 있습니다.
Minify와 Uglify는 Build 타임에 적용이 되며, Compress는 네트워크 상에서 전송할 때 압축이 진행됩니다.
따라서 어떤게 좋다 나쁘다라고 할 수 없고 다른 작업들입니다. 모두 적용하는게 일반적으로는 효율적입니다.




# Minify(경량화?) - 빌드시 
실제 코드 실행에 불필요한 공백, 주석 등을 제거하는 작업
let test1 = 123;
const test2 = 234; 

--->    let test=123;const b=234;
공백과 개행을 모두 제거했지만 코드 실행에는 아무 문제 없습니다.



#Uglify(난독화): 코드의 변수명이나 함수명등을 알아보기 힘들게 바꾸는 작업
let veryImportantValue = 123;

---> let a = 123;
보안성 강화 + 긴 변수명 또는 함수명을 짦게 바꿔줘서 최적화 효과도 있음






-------------------------------------------------------------
유동균님 답변 

1. 

우선, Compress(압축)과 Minify(경량화?)를 구부하셔야 합니다. 둘은 다릅니다. 
말씀해주신 플러그인은 Minify 플러그인입니다.
조금 더 세분화해서 예를 들어보면,

Minify: 실제 코드 실행에 불필요한 공백, 주석 등을 제거하는 작업
let test1 = 123;
const test2 = 234; 

--->    let test=123;const b=234;
공백과 개행을 모두 제거했지만 코드 실행에는 아무 문제 없습니다.
Uglify(난독화): 코드의 변수명이나 함수명등을 알아보기 힘들게 바꾸는 작업
let veryImportantValue = 123;

---> let a = 123;
보안성 강화 + 긴 변수명 또는 함수명을 짦게 바꿔줘서 최적화 효과도 있음



Compress: 네트워크 전송 시, 텍스트 데이터 자체를 압축하는 작업
쉽게 생각해서 zip으로 압축하듯이 압축한다고 생각하시면 됩니다.
일반적인 텍스트 파일(html, js, css 등)들은 압축을 통해 사이즈를 줄일 수 있습니다.
웹에서 사용하는 압축방식은 gzip입니다.
텍스트의 패턴에 따라 많게는 1/10, 적게는 1/5까지 사이즈가 줄어듭니다.
이렇게 정리할 수 있습니다.
Minify와 Uglify는 Build 타임에 적용이 되며, Compress는 네트워크 상에서 전송할 때 압축이 진행됩니다.
따라서 어떤게 좋다 나쁘다라고 할 수 없고 다른 작업들입니다. 모두 적용하는게 일반적으로는 효율적입니다.

2.

네, 맞습니다.
위에 정리해뒀듯, Minify와 Uglify는 코드 실행에 전혀 영향을 주지 않습니다. 단지 사람이 보기 힘들어 졌을 뿐입니다.

3.

1번에서 언급했듯 일반적으로 모두 적용하는 것이 효율적입니다.

4. 

음... 이건 그 분이 잘못 알고 계신겁니다.
텍스트 압축(gzip) 시간은 서비스 시간에 거의 영향을 주지 않습니다.

강의에서도 언급했던거 같은데요, 대략 2KB를 기준으로 그 이하 사이즈인 파일은 압축은 안하는 것이 더 낫습니다. 반대로 그 이상의 사이즈 파일은 압축을 하는 것이 좋다는 것이되는 거죠.
(보통 이 분기는 압축을 적용하는 곳에서 해줍니다.)

그런데 서비스 코드 중에 2KB를 안 넘는 것이 과연 얼마나 될까요?
거의 없죠.. 즉, 웬만하면 압축을 하는게 좋다는 겁니다.

이 gzip을 적용하는 작업은 작업 리소스 대비 효율이 굉장히 좋습니다.
꼭 하시길 바랍니다. 코드가 500KB라면 압축 후, 거의 100~50KB가 될겁니다.

 

답변이 도움되셨길 바라며, 강의에 관심을 가져주셔서 감사합니다. :)
                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->

                </div>




                <div class="depth_2">
                    <strong>코드 관리</strong>

                     <!-- item -->
                     <div class="item_wrap">
                        <dl class="item">
                            <dt><button>병목현상<span> bottleneck</span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
# 병목현상 (bottleneck) 이란?   

`차로가 4차선에서 2차선으로 줄어들 때 생기는 교통체증 같이 
프로그래밍에서 생기는 정체현상

많은 양의 데이터를 순식간에 보냈을 때 메모리가 이를 제대로 소화하지 못해 성능이 떨어지는 현상. 
주로 용량이 적은 주변기기를 사용할 때 많이 발생. 
즉 담을 수 있는 데이터의 양은 적으나 한꺼번에 많은 양의 데이터가 유입 됨으로써 
컴퓨터가 느려지는 현상


때문에 js에선 가비지컬렉터(GC) 가 중간중간 제거를 해줌

https://github.com/ejonghwan/performance_apply 
aticle 컴포넌트안에 병목현상이 생기는 함수 `



# 예제 코드
/*
 * 파라미터로 넘어온 문자열에서 일부 특수문자를 제거하는 함수
 * (Markdown으로 된 문자열의 특수문자를 제거하기 위함)
*/
function removeSpecialCharacter(str) {
    const removeCharacters = ['#', '_', '*', '~', '&', ';', '!', '[', ']', '`', '>', '\n', '=', '-']
    let _str = str
    let i = 0,
      j = 0
  
    for (i = 0; i &lt; removeCharacters.length; i++) {
      j = 0
      while (j &lt; _str.length) {
        if (_str[j] === removeCharacters[i]) {
          _str = _str.substring(0, j).concat(_str.substring(j + 1))
          continue
        }
        j++
      }
    }
  
    return _str
  }

 //jsx 
 &lt;div className={'Article__summary__desc'}&gt;{removeSpecialCharacter(props.content)}&lt;/div&gt;


# 문제점
`위 코드의 문제점.. 
 인자로 넘어온 마크다운 문자열중 특수문자를 제거하기 위해 
 두번의 반복문을 돌고 있음 
 
 때문에 퍼포먼스 탭에서 반복문을 두번씩 돌다가 메모리가 넘치면 GC가 제거하고 
 다시 돌리고를 반복해서 병목현상이 발생
`


# 해결방법
1. .replace 함수와 정규식 사용
2. 마크다운의 특수문자를 지워주는 라이브러리 사용
3. 작업하는 양 줄이기 (전체 말고 필요한 부분만 계산)



//let _str = str.substring(0, 300); //모든 문자열이 아닌 0~ 300자 까지만 검사 
//_str = _str.replace(/[\#\_\*\~\&\;\!\[\]\`\>\n\=\-]/g, '') //내장객체와 정규표현식 사용 



                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button>code splitting & lazy loading<span></span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="javascript">
# code splitting : 코드 분할 ..큰 파일을 필요한부분만 쓸 수 있게 .. 
# lazy loading : 나중에 필요한건 나중에 로딩
- 모듈별로
- 페이지별로
- 위 두가지 섞어서

핵심은 "불필요한 코드와 중복되는 코드" 없이 
"적절한 사이즈의 코드"가 
"적절한 타이밍에 로드"될 수 있도록 


//code splitting은 웹팩이 해주는 것임. 웹팩 설정  (cra는 설정 다 되어있음)
//https://webpack.js.org/guides/code-splitting/#root


//https://ko.reactjs.org/docs/code-splitting.html
//Route-based code splitting



`
!! 예제 문제점
현재 번들파일이 용량이 커서 다운로드 시간이 오래걸림
다운로드 시간이 오래걸리면 다운로드 후 실행하기 떄문에 그만큼 지연됨 
`


`1. 분석 툴 (https://www.npmjs.com/package/webpack-bundle-analyzer)`
npm i webpack-bundle-analyzer 

`2. cra를 사용한다면 직접 플로그인 넣으려면 웹팩을 리젝하거나 커스텀lib 써야함
 lib -> cra-bundle-analyzer
 https://www.npmjs.com/package/cra-bundle-analyzer
`
npm i cra-bundle-analyzer
npx cra-bundle-analyzer



`3. cra-bundle-analyzer 실행해보면 번들파일에서 
어떤게 제일 많이 먹고 있는지 블럭으로 보여줌... 

1. chunk.js 제외하고 가장 많이 먹고 있는게 refractor
2. pakacge-lock.json 에서 refractor 검색해보면 
3. react-syntax-highlighter 에서 사용하는 하위 종속된 모듈인것 확인
4. 그렇다면 상세페이지에서만 필요한거니 상제페이지에서만 다운로드하게끔 코드 스플리팅!
`


//splitting code 
`cra는 웹팩설정 안해줘도 되지만 처음부터 설정한다면 code splitting 설정을 따로 해줘야함..웹팩이 해주는거라`

import React, { Suspense, lazy } from 'react'
import { Switch, Route } from 'react-router-dom'

const Component1 = lazy(() =&gt; import('./page/component1/index'))
const Component2 = lazy(() =&gt; import('./page/component1/index'))

&lt;Suspence fallback={&lt;div&gt;loading...&lt;div&gt;}&gt;
    &lt;Switch&gt;
        &lt;Route path="/" component={Component1} exact /&gt;
        &lt;Route path="/about/:id" component={Component2} exact /&gt;
    &lt;/Switch&gt;
&lt;/Suspence&gt;



//Component2 
import { Link } from 'react-router-dom'
&lt;Link to={`/view/${item.id}`}&gt;
    &lt;Article {...item} /&gt;
&lt;/Link&gt;



코드 적용결과(npx cra-bundle-analyzer) 
refractor 코드와 react-dom 코드가 분리되어있음

때문에 
리스트 페이지에서는 필요한 모듈만을 불러오고 
뷰 페이지에서는 두개를 더 불러옴


                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                     
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span></span>reflow repaint</button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
# 브라우저 렌더링 간단하게 
1. DOM 생성 
2. CSSOM 생성
3. DOM + CSSOM = render tree 생성 
4. layout (위치 크기 계산해서 배치)
5. paint (색칠)
6. composite (레이어별로 layout와 paint가 작업된 레이어들을 합성)



# 주의
reflow가 일어나는 css를 사용하면 렌더링할 때마다 1~ 6까지의 단계가 반복됨 ... (1,2,3,4,5,6 단계) 

- 리플로우를 자주 발생하는 소스의 퍼포먼스탭에 프레임을 보면 
  화면이 그려지는 각각 라인에 걸쳐있는 composite를 볼 수 있는데 
  라인에 걸쳐 있다면 화면엔 이전 프레임의 화면이 보여질거고 
  1 프레임이 누락되었기 때문에 60fps의 모니터를 사용시 59프레임이 되어버림... 
  그래서 뚜둑 끊기는거 (프레임 드랍)

- 퍼포먼스 탭에서 제일 상단에 있는 녹색 그래프가 프레임수를 나타내고(오른쪽에 FPS라고 써져있음) 
  60fps일 때 들쑥날쑥 하다면 애니메이션이 일어나면서 프레임드랍이 일어난거임

- 퍼포먼스 탭에서 상단에 보라색(레이아웃)과 녹색(컴포짙)이 많다는건 메인스레드가 많이 처리했다는 뜻 



# 해결
1. composite만 일어나는 css를 사용하는게 가장 베스트 
2. repaint부터 일어나는 css 사용  ...(1,2,3,5,6 단계)
2. GPU를 사용하는 opacity, transform 사용하기... (1,2,3,6 단계)
   (이건 좀 더 찾아봐야함.. opacity가 어떤 레이어에 있냐에 따라 reflow발생)
   (GPU를 사용하면 메인스레드가 작업하지 않기에 성능이 향상됨)



/*  기존 코드
    width: ${({width}) => width}%;
    transition: width 1.5s ease;
*/

/*  개선 코드
    width: 100%;
    transform: scaleX(${(props) => props.width / 100});
    transform-origin: 0;
    transition: transform 1.5s ease;
*/






GPU에 관련된 답글 
안녕하세요 불멸의너구리좌님,

GPU를 사용하는 상황에서 데이터 통신에 대한 부하가 걸리지는 않는지 질문을 주셨는데요.

브라우저가 GPU에 작업을 위임할 때, 흔히 우리가 생각하는 네트워크 통신처럼 시간이 걸는게 아니라 굉장히 빠른 프로세스 간의 통신이 이뤄집니다. 
또한, 크롬 브라우저에서는 이미 GPU 프로세스를 포함한 여러 역할을 담당하는 프로세스들이 동작하고 있기 때문에 
별도의 오버헤드 없이 해당 프로세스들 끼리 데이터를 주고 받을 수 있게 됩니다.

즉, CPU에서 처리함으로써 떨어지는 성능에 비하면 거의 무의미한 수준의 비용이기 때문에 오히려 빨라지는 것입니다.

참고하실 수 있도록 도움되는 링크를 알려드리겠습니다.
- https://dev.opera.com/articles/ko/css-will-change-property/
- https://d2.naver.com/helloworld/2922312
- https://developers.google.com/web/updates/2018/09/inside-browser-part3#raster_and_composite_off_of_the_main_thread

강의에 관심을 가져주셔서 감사합니다. :)


                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                     <!-- item -->
                     <div class="item_wrap">
                        <dl class="item">
                            <dt><button>preload <span>component</span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">

# 이미지 슬라이드 팝업을 레이지로드 했을 때

import React, { useState, Suspense, lazy } from 'react'
const ImageModal = lazy(() => import('./components/ImageModal'))


&lt;Suspense fallback={null}&gt;
&nbsp;&nbsp;&nbsp;{showModal ? &lt;ImageModal closeModal={() =&gt; { setShowModal(false) }} /&gt; : null}
&lt;/Suspense&gt;



# 문제점
code splitting이 잘 되어 나중에 요청이 되지만 
문제는 느리다 ... 

왜냐면 클릭했을 때 ImageModal 컴포넌트에 있는 모듈 등등을 불러오기 때문에... 



# 해결방법 
이럴 때 preload를 해주면 된다. 크게 두가지 방법으로,. 

1. 버튼에 마우스 오버를 했을 때 
2. 화면로드가 다 끝난 후

코드 스플리팅했던 슬라이드에 사용된 image css module 등을 사전로드 하게 되면 
미리 로드준비를 해놓고 캐시에 저장해놔서 특정시점(나는 마우스오버에 검) 을 만나면 캐시해둔 
리소스를 받기 떄문에 빠르다



import React, { useEffect, lazy, Suspense } from 'react'

1. 마우스오버 시 프리로드 
const handleMouseenter = () => import('./')
const ImageModal = lazy(() => import('./'))
&lt;button onClick={imageModal} onMouseEnter={handleMouseenter}&gt;click&lt;/button&gt;

2. 받을게 많다면 마운트 후 시점에
useEffect(() => {
    // import한 함수를 변수에 안담아두면 함수실행하고 사용안한다고 에러뜸 
    const component = import('./')
}, [])
const ImageModal = lazy(() => import('./'))
&lt;button onClick={imageModal} &gt;click&lt;/button&gt;




부가 ------
// 만약 임포트할게 많다면 팩토리패턴으로 함수 
const lazyWithPreload = (importFunction) => {
    const Component = React.lazy(importFunction)
    console.log(Component)
    Component.preload = importFunction;
    return Component
}

const LazyImageModal = lazyWithPreload(() => import('./components/ImageModal'))

useEffect(() => {
    LazyImageModal.preload()
}, [])


                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button>preload <span>image</span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
// 기본적으로 image에 src속성이 들어가는 순간 비동기적으로 이미지 로드함
const img = new Image()
img.src = './'


# 마운트 후 시점에 이미지 사전로드 
useEffect(() => {
    const img = new Image()
    img.src = './'
}, [])

`하지만 이렇게 하면 다시 img.src 했을 때 또 로드됨... 미리 로드했기 떄문에 캐시가 걸려있는 상태` 
`네트워크 탭에서 해당 파일보면 cache-control 항목이 걸려있음`

`중요한건 가장크고 중요한 이미지만 사전로드하는 게 중요함... 모두 사전로드하면 오히려 느려짐`

                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button>cache<span></span></button></dt>
                            <dd>
                               -
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="markdown">
# 결론
서버에서 캐시를 리소스마다 다르게 설정하여 최적화 
ex) 
const header = {
    setHeaders: (res, path) => {
        if(path.endsWith('.html')) {
            // html은 변경 시 마다 새로받음
            res.setHeader('Cache-Control', 'no-cache') 
        } else if(path.endsWith('.js') || path.endsWith('.css') || path.endsWith('.webp') || path.endsWith('.jpg')) {
            // hash를 하면 길게줌 (빌드 시에도 변경이 없으면 해시값이 안변함...개쩌네;;)
            res.setHeader('Cache-Control', 'public, max-age=315360000')
        } else {
            // 그 외 파일은 캐시하지않음
            res.setHeader('Cache-Control', 'no-store')
        }
    }
}
app.use(express.static(path.join(__dirname, '../build'), header))

1. 이미지가 자주 안바뀌는 리소스들(로고 등)은 max-age를 길게 줘서 다운로드 받지 않게만듦

HTML  no-cache 
JS    public, max-age=31536000  (hash 붙여야함) max-age 1년임
CSS   public, max-age=31536000  (hash 붙여야함)
IMG   public, max-age=31536000  (hash 붙여아함)


- html은 메타에 no-cache해서 변경되었을 때만 다운로드함 
- js css는 변경시, 빌드시 마다 해시를 걸거나 ...함 (리액트는 빌드시 해시 붙음)

  중요..! 순서를 보면 html에서 js와 css를 호출하는데 
  html/main.a.js/main.a.css 있다고 치고 html 변경 시 서버에서 새로 받는데 
  js와 css는 변경도 안되었는데 캐시된 a를 사용안하고 b를 새로 받아버림.. 
  때문에 html만 no-cache로 변경시마다 받고.. js css는 max-age(캐시)를 7일 30일 등으로 설정함
  (리액트에서 빌드 시에도 js css image가 변경되지 않으면 해시도 변경안됨.. 그래서 캐시된걸 받음) 

- image는 자주 변경되는 이미지일 경우 max-age를 짧게 주거나, js css처럼 해시를 달고 max-age를 길게 줌




------------- 설명 
 
 response header에 cache-control

# 캐시: 데이터나 값을 미리 복사해 놓는 임시 장소나 그런 동작
        브라우저 알고리즘에 의해 아래 두 가지로 적절하게 저장함 



# 메모리 캐시: 메모리(RAM)에 저장   
   - 메모리 캐시는 브라우저를 껐다 켜면 사라져있음. 브라우저가 사용하는 메모리를 날렸기 때문 
     메모리에선 날리고 파일로 가지고 있어서 다시 브라우저 켜보면 디스크캐시만 남음



# 디스크 캐시: file로 데이터 저장 후 가져와서 사용 
  - 브라우저 껐다 켜면 메모리 캐시 날라가있고 디스크캐시만 뜸



# 캐시 설정하기 
서버에 http request 보낼 때 cache-control에 설정하여 요청

- client: 요청해더에 캐시요청
- server: 캐시요청오면 설정해서 응답


# Cache-Control:
1. no-cache - 캐시를 사용할건데 사용 전에 서버에 검사 후, 사용걸정 
2. no-stroe - 캐시 사용 안함 
3. public   - 모든 환경에서 캐시 사용 가능 
4. private  - 브라우저 환경에서만 캐시 사용, 외부(캐시서버) 캐시 서버에서는 사용 불가 
              (예로 로그인 후 캐시데이터들은 남들과 공유되면 안되니깐 이 옵션을 씀)
5. max-age  - 캐시의 유효기간 60초
            
이외에 ETag, expires 등 있음


# 중요!! 
- no-cache === max-age=0 이어도 캐시를 삭제하는게 아니라 가지고 있다가 reqeust 할 때 클라이언트에서 이 사진에 캐시가 만료가 되었는데 계속 사용해도 돼 ? 라고 서버에 물어봄. 서버에서 수정안됐으니 사용해라고 ok나면 사용하고 수정됐다고 no라면 서버에서 파일 다운로드.. 

- 메인에서 서브페이지 css를 받았을 때 용량이 더 작게 받아지는게 이런 경우임
해당 페이지에 no-cache가 있어서? 테스트해봤을 때 서브페이지 드가면 작은 파일 받아짐 

(네트워크탭에서 304 낫 모디파이드 라고 되어있으면 수정이 안되어 캐시되어있는 파일 썼다는 의미) 




# ETag
- 네트워크 탭 응답해더에 ETag값으로 해시가 있음
1. 클라이언트 리소스 이미지에 ETag : a 가 있으면 
2. 서버에도 리소스 이미지로 ETag : a 가 있음 
3. 클라이언트가 이거 사용해도 돼 ? 하면서 ETag를 보내줌 
4. 서버는 서버에 있는 ETag를 비교해서 같으면 ETag를 보내주고 아니면 변경된 이미지를 보내줌







# meta tag 
<meta http-equiv="Cache-Control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
페이지를 cache에서 가져오지 않게 하며 항상 서버에 접속해서 페이지를 가져옵니다.
그러므로 방문자의 브라우저가 항상 cache를 읽도록 해 놓아도 이것을 무시하고 페이지를 갱신합니다.
자주 고치는 페이지에서는 이것을 사용하는 것이 항상 방문자에게 바뀐 내용을 보여 줄 수가 있습니다. 
하지만 페이지 출력 속도는 매번 페이지를 가져오므로 cache를 사용할 수 없어서 시간이 많이 걸린다는 점입니다.



출처: https://webclub.tistory.com/354 [Web Club]



-----------확인 필요
https://www.next-t.co.kr/blog/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94-SEO-%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%ACSEO-%EB%A9%94%ED%83%80%ED%83%9C%EA%B7%B8-metatags-expires-%EC%86%8D%EC%84%B1

<META HTTP-EQUIV=”Expires” CONTENT=”Mon, 06 Jan 1990 00:00:01 GMT”>
<META HTTP-EQUIV=”Expires” CONTENT=”-1″>
<META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
<META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    
– Expires : 본 문서가 content에 지정된 시간부터 유효하지 않음(캐시만료)을 알려주는 기능을 합니다.
– content 항목이 -1이면 조건부 캐쉬만료를 의미합니다.
– Mon, 06 Jan 1990 00:00:01 GMT : 만료날짜를 그리니치 시간으로 적습니다.
– Pragma : content 항목인 “no-cache” 명령어를 전달합니다. 즉, 캐시 기능을 하지말라는 뜻입니다.
– Cache-Control : 캐시를 제어하기 위한 기능입니다. content에 ‘no-cache’라고 적혀있기 때문에 cache를 하지 않습니다.
– Pragma와 Chache-Control의 문제점 : 인터넷 익스플러어 5.0 혹은 HTTP1.0에서는 여러가지 경우에 따라 동작하지 않을 수 있다고 합니다. 또한 웹서버의 제어에 따라 동작하지 않을 수 있습니다.
                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                </div>
              </section>
               <!-- performence -->
                       
                <!-- React -->
                <section class="conts">
                    <h2>React</h2>

                    <div class="depth_2">
                        <strong>React</strong>
                   
                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span>document</span>.body</button></dt>
                            <dd>
                                현재 문서의 body 또는 frameset 노드를 반환 adsadasdasdasdasdasdasdplalsjdlkajdlkajskda
                        </dd>
                        </dl>
                        <div class="code_wrap">
                        <pre>
                            <code class="javascript">
asd
                            </code>
                        </pre>
                        </div>
                    </div>
                    <!-- item -->
                </div>
              </section>
               <!-- //React -->

              <!-- Vue -->
              <section class="conts">
                <h2>Vue</h2>

                <div class="depth_2">
                    <strong>Vue Vue</strong>
               
                <!-- item -->
                <div class="item_wrap">
                    <dl class="item">
                        <dt><button><span>document</span>.body</button></dt>
                        <dd>
                            현재 문서의 body 또는 frameset 노드를 반환
                    </dd>
                    </dl>
                    <div class="code_wrap">
                    <pre>
                        <code class="javascript">
asd
                        </code>
                    </pre>
                    </div>
                </div>
                <!-- //item -->
            </div>
          </section>
          <!-- Vue -->


         

              


            </div>
        </main>
        <footer>
            <div class="global_wrap">
                <ul class="info">
                    asdasdsa
                </ul>
            </div>
        </footer>
    </div>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>