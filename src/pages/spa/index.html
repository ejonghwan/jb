<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">

    <title>Document</title>
</head>

<body>

    <div class="wrap">
        <header>
            <nav class="global_wrap sub">
                <ul class="line"></ul>
            </nav>
        </header>
        <main>
            <div class="global_wrap">

                <!-- performence -->
                <section class="conts">
                    <h2>Performence</h2>
                    <p>아직안본거(최적화) https://uzihoon.com/post/ef453fd0-ab14-11ea-98ac-61734eebc216</p>
                    <div class="depth_2">
                        <strong>리소스 관리</strong>

                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>성능</button></dt>
                                <dd>
                                    로딩성능 | 렌더링 성능
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
성능최적화에는 아래 두 가지로 나뉨  

# 로딩성능 
: 필요한 자원들을 미리 로드하거나 지연로드 
- 이미지 최적화 
- code split (코드분할)
- 리소스 텍스트 압축
- 컴포넌트 레이지 로딩 
- 컴포넌트 프리로딩 
- 이미지 프리로딩 


# 렌더링 성능 
: 필요한 자원들을 화면에 렌더링 
- bottleneck 코드 최적화
- reflow, repaint 최적화



`performance 탭 선.. 
요청연결준비 | 요청 | 다운로드 | 메인스레드 처리 `

                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>이미지</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
// 구글에서 배포한 이미지 최적화 앱
squoosh.app 



# cdn 이미지는 파라미터로 이미지 사이즈 조절하기 
(없다면 여기서 생성 https://imgix.com/)


# 이미지 사이즈 너무 큰거넣지 않기..레티나 대응해서 2~3배 사이즈 


# picture, webp 쓰기 
&lt;picture&gt;
    &lt;source srcSet={main_items} type="image/webp" /&gt;
    &lt;img  data-src={main_items} ref={imgRef_1} /&gt;
&lt;/picture&gt;



# intersection observer API 사용하기 

import { Fragment } from 'react'
import { useEffect, useRef } from 'react'


const Img = ({ webpSrc, imageSrc, alt, className }) => {

    const imgRef = useRef(null) 

    useEffect(() => {
        const options = {}
        const callback = (entries, observer) => {
            entries.forEach(entry => {
                if(entry.isIntersecting) {

                    const target = entry.target;
                    const previousSibling = target.previousSibling;

                    console.log('is inter', entry.target.dataset.src, previousSibling);
                    
                    target.src = target.dataset.src;
                    previousSibling.srcset = previousSibling.dataset.srcset;

                    observer.unobserve(target)
                }
            })
        }
        const observer = new IntersectionObserver(callback, options)
        observer.observe(imgRef.current)

    }, [])

    return (
        &lt;Fragment&gt;
            &lt;picture&gt;
                &lt;source data-srcset={webpSrc} type="image/webp" /&gt;
                &lt;img data-src={imageSrc} ref={imgRef} alt={alt} className={className} /&gt;
            &lt;/picture&gt;
        &lt;/Fragment&gt;
    )
    
}

export default Img;


                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>비디오</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# webm 압축해서 사용 
변환프로그램으로 webm으로 변환
주의점은 화질 많이 떨어지니 영상이 주가 아닌 사이트에 사용 

webm은 브라우저 호환이 별로 안좋으니 &lt;video&gt;&lt;/video&gt;태그로 분기 

https://www.media.io/ko/video-compressor.html



# 예제
import Video_webm from './video.webm'
import Video from './video.mp4'

&lt;video
    autoPlay
    loop
    muted
&gt;
    &lt;source src={Video_webm} type="video/webm" /&gt;
    &lt;source src={Video} type="video/mp4" /&gt;
&lt;/video&gt;

https://developer.mozilla.org/ko/docs/Web/HTML/Element/Video



# 그 외 동영상 화질저하 가려보기
- 동영상 루프 시간 조금 줄이기 
- 동영상 앞에 패턴주기 
- css blur 사용하기
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>폰트</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
FOUT (IE, 엣지) 방식 : 시스템폰트 였다가 웹폰트가 늦게 먹어서 움찔거림
FOIT (크롬) 방식 : 웹폰트가 다운로드 다 받아져야 폰트자체가 생겨남 


해결방법(구글에서는 preload와 optional 권장)


# 폰트 적용 시점 컨트롤

font-display: 속성 이용
auto 
- 브라우저 기본동작

block 
- FOIT (timeout = 3s...3초까진 기다렸다가 그래도 안나오면 시스템폰트 적용)

swap 
- FOUT (기본폰트 적용 이후 웹폰트)

fallback 
- FOIT (timeout = 0.1s)... 0.1초만에 기본폰트를 보여주고 
    3초 이후에도 웹폰트를 다운로드 못했을 시 기본폰트를 쭉 보여주고 웹폰트는 캐시.. 
    다음엔 바로 캐시 웹폰트로보여줌

optional 
- FOIT(timeout = 0.1s)... fallback이랑 비슷하지만 네트워크 상태에 따라 
    기본폰트로 유지할지 웹폰트로 적용할지 결정, 이후 캐시



# 폰트 사이즈 줄이기   
(EOT > TTF/OTF > WOFF > WOFF2) 용량 낮은순
https://transfonter.org/ (폰트변환)


# 웹폰트 포멧 사용
@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
        url('./assets/fonts/fontname.woff2') format('woff2'), //이거 지원안하면 아래꺼 적용
        url('./assets/fonts/fontname.woff') format('woff'),
        url('./assets/fonts/fontname.ttf') format('truetype');
    font-display: block;
    unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 
}


# local 폰트 사용 (위에꺼처럼)
src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
만약 FOIT 방식으로 적용하고 움찔하는걸 없애려면 시스템폰트와 웹폰트가 비슷한걸 쓰고 방식을 FOIT로 됨 


# Subset 사용 (특정문자 몇개만  사용 할 때)
만약 2글자만 웹폰트를 사용한다면 필요한 2글자만 자를 수 있음 
(1) https://transfonter.org/  접속 
(2) 하단 Subset 옵션(특정 폰트) 설정하거나 Charactoers(특정 문자)에 넣고싶은 문자만 넣고 Convert 
(3) Convert 된 subset 폰트파일 css에 적용

- 단점은 다른곳에서 폰트적용을 했을 때 쓰지않아도 다운로드함. 이 단점을 없애려고 unicode range 적용
unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 


# Unicode Range 적용 (위에꺼 단점 대응)
unicode-range: u+0041,u+0042,u+0043,u+0044,u+0045,u+0046,u+0054 // A에 대한 폰트가 있을 때만 폰트파일 다운로드 

Array.prototype.map.call('ABCDEFT', c => 'u+' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4)).join(',') //유니코드 뽑아내는 코드 u+0041,u+0042,u+0043,u+0044,u+0045,u+0046,u+0054


# data-uri로 변환 (웹팩 이미지 메모리저장하는거랑 비슷한 방식)
(1) https://transfonter.org/  접속 
(2) 하단 Subset 옵션(특정 폰트) 설정하거나 Charactoers(특정 문자)에 넣고싶은 문자만 넣고 
(3) 상단 base64 encode  온!! 하고 Convert


3번 Subset과 용량은 비슷하지만 네트워크 요청시간을 줄이고 css불러올떄 같이불러옴  

@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
            url('data:app~~~asasfasdas~') format('woff2'), //이거 지원안하면 아래꺼 적용
            url('data:app~~~asasfasdas~') format('woff'),
            url('data:app~~~asasfasdas~') format('truetype');
    font-display: block;
    unicode-range: u+0041; // A에 대한 폰트가 있을 때만 폰트파일 다운로드 
}
                                
                    

# 폰트 프리로드 
- 보통은 css를 읽으면서 @font-face를 읽을 때 폰트가 필요해! 하고 다운로드하지만 
    프리로드는 그 전에 다운로드 하는 기법

1. HTML 에서 사전로드를 하고 
&lt;link rel="preload" href="주소나 경로.woff2" as="font" type="font/woff2" crossorigin /&gt;

2. @font-face 에서 사용.. 1번에서 사전 로드했으니 css에서 아래 소스를 만나도 로드하지않음
@font-face {
    font-family: fontname;
    src: local('fontname'), //시스템에 있으면 다운로드 받지않고 ...로컬폰트 사용
            url('./assets/fonts/fontname.woff2') format('woff2'), //이거 지원안하면 아래꺼 적용
            url('./assets/fonts/fontname.woff') format('woff'),
            url('./assets/fonts/fontname.ttf') format('truetype');
    font-display: block;
    }


!! 여기서 질문?  이거 질문올림
@font-face가 들어있는 css 자체를 preload로 사전로드하면 폰트도 사전로드 될까 ?  
                                



# font preload를 CRA 사용시 문제점 
빌드할 때마다 preload의 href를 변경해줘야하는데 
웹팩을 커스텀  해주면 해결 
https://www.npmjs.com/package/react-app-rewired?activeTab=dependents


1. 다운로드 
npm i -D react-app-rewired

2. 스크립츠 수정
package.json
"scripts": {
    -   "start": "react-scripts start",
    +   "start": "react-app-rewired start",


3. 루트경로에 아래 파일 추가 하고 내용추가
// config-overrides.js
module.exports = function override(config, env) {
    //do stuff with the webpack config...
    return config;
  }


4. 웹팩 플로그인 모듈 설치 
npm i -D preload-webpack-plugin 

...이거 설치안됨 

5. 설정파일 수정 
// config-overrides.js

import preloadWebpackPlugin = require('preload-webpack-plugin ')
module.exports = function override(config, env) {
    
    config.plugins.push(new preloadWebpackPlugin({
        rel: 'preload',
        as: 'font',
        include: 'allAssets', 
        fileWhitelist: [/(.woff2?)/i]
    }))

    return config;
  }


                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>텍스트 압축 <span>서버 | 빌드</span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
서버에서 압축해줌 -> 클라이언트에서 압축해제
무분별하게 압축하면 성능이 오히려 떨어지고 2kb 이상만 하는게 좋음

응답받은 헤더에 Content-Encoding: gzip 항목... (gzip으로 압축되어있는 파일)




웹상 압축방식은 크게 두가지 (gzip이 조금 더 좋음) 
1. GZIP 
2. Deflate (LZ77)






Compress(압축) + Minify(경량화?) 둘다 적용하는게 베스트


# Compress(압축) - 서버
네트워크 전송 시, 텍스트 데이터 자체를 압축하는 작업
쉽게 생각해서 zip으로 압축하듯이 압축한다고 생각하시면 됩니다.
일반적인 텍스트 파일(html, js, css 등)들은 압축을 통해 사이즈를 줄일 수 있습니다.
웹에서 사용하는 압축방식은 gzip입니다.
텍스트의 패턴에 따라 많게는 1/10, 적게는 1/5까지 사이즈가 줄어듭니다.
이렇게 정리할 수 있습니다.
Minify와 Uglify는 Build 타임에 적용이 되며, Compress는 네트워크 상에서 전송할 때 압축이 진행됩니다.
따라서 어떤게 좋다 나쁘다라고 할 수 없고 다른 작업들입니다. 모두 적용하는게 일반적으로는 효율적입니다.




# Minify(경량화?) - 빌드시 
실제 코드 실행에 불필요한 공백, 주석 등을 제거하는 작업
let test1 = 123;
const test2 = 234; 

--->    let test=123;const b=234;
공백과 개행을 모두 제거했지만 코드 실행에는 아무 문제 없습니다.



#Uglify(난독화): 코드의 변수명이나 함수명등을 알아보기 힘들게 바꾸는 작업
let veryImportantValue = 123;

---> let a = 123;
보안성 강화 + 긴 변수명 또는 함수명을 짦게 바꿔줘서 최적화 효과도 있음






-------------------------------------------------------------
유동균님 답변 

1. 

우선, Compress(압축)과 Minify(경량화?)를 구부하셔야 합니다. 둘은 다릅니다. 
말씀해주신 플러그인은 Minify 플러그인입니다.
조금 더 세분화해서 예를 들어보면,

Minify: 실제 코드 실행에 불필요한 공백, 주석 등을 제거하는 작업
let test1 = 123;
const test2 = 234; 

--->    let test=123;const b=234;
공백과 개행을 모두 제거했지만 코드 실행에는 아무 문제 없습니다.
Uglify(난독화): 코드의 변수명이나 함수명등을 알아보기 힘들게 바꾸는 작업
let veryImportantValue = 123;

---> let a = 123;
보안성 강화 + 긴 변수명 또는 함수명을 짦게 바꿔줘서 최적화 효과도 있음



Compress: 네트워크 전송 시, 텍스트 데이터 자체를 압축하는 작업
쉽게 생각해서 zip으로 압축하듯이 압축한다고 생각하시면 됩니다.
일반적인 텍스트 파일(html, js, css 등)들은 압축을 통해 사이즈를 줄일 수 있습니다.
웹에서 사용하는 압축방식은 gzip입니다.
텍스트의 패턴에 따라 많게는 1/10, 적게는 1/5까지 사이즈가 줄어듭니다.
이렇게 정리할 수 있습니다.
Minify와 Uglify는 Build 타임에 적용이 되며, Compress는 네트워크 상에서 전송할 때 압축이 진행됩니다.
따라서 어떤게 좋다 나쁘다라고 할 수 없고 다른 작업들입니다. 모두 적용하는게 일반적으로는 효율적입니다.

2.

네, 맞습니다.
위에 정리해뒀듯, Minify와 Uglify는 코드 실행에 전혀 영향을 주지 않습니다. 단지 사람이 보기 힘들어 졌을 뿐입니다.

3.

1번에서 언급했듯 일반적으로 모두 적용하는 것이 효율적입니다.

4. 

음... 이건 그 분이 잘못 알고 계신겁니다.
텍스트 압축(gzip) 시간은 서비스 시간에 거의 영향을 주지 않습니다.

강의에서도 언급했던거 같은데요, 대략 2KB를 기준으로 그 이하 사이즈인 파일은 압축은 안하는 것이 더 낫습니다. 반대로 그 이상의 사이즈 파일은 압축을 하는 것이 좋다는 것이되는 거죠.
(보통 이 분기는 압축을 적용하는 곳에서 해줍니다.)

그런데 서비스 코드 중에 2KB를 안 넘는 것이 과연 얼마나 될까요?
거의 없죠.. 즉, 웬만하면 압축을 하는게 좋다는 겁니다.

이 gzip을 적용하는 작업은 작업 리소스 대비 효율이 굉장히 좋습니다.
꼭 하시길 바랍니다. 코드가 500KB라면 압축 후, 거의 100~50KB가 될겁니다.

 

답변이 도움되셨길 바라며, 강의에 관심을 가져주셔서 감사합니다. :)
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->

                    </div>




                    <div class="depth_2">
                        <strong>코드 관리</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>클린코드<span></span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
클린 코드란 원하는걸 빠르게 찾을 수 있는 코드


ex) 두개를 섞어서 잘 사용 
1. 선언적 프로그래밍
세부기능은 함수안에 숨겨두고 넘겨주는 형태로.. 실행 단계에서만 보고 파악가능한 코드 
&lt;Popup 
    onsubmit={질문전송}
    onSuccess={홈으로 이동}
/&gt;

ex2) map, reduce 등 세부로직은 map함수 안에 추상화되어있고 우리는 이용만 하면 된다 
- 선언적 프로그래밍 안은 어쩃든 명령적으로 되어있긴함


2. 명령적 프로그래밍 
   - 세세하게 모든걸 설명함 
&lt;Popup&gt; 
    세부로직 
&lt;/Popup&gt;


# 응집도 
- 같은 목적의 코드(당장 몰라도 되는 디테일)는 뭉쳐두기 
  (하지만 커스텀 훅처럼 그냥 뭉쳐두기만 하면 안됨.. 버튼을 눌렀을때 어떤 기능인지 등 파악불가)


# 단일책임 
- 하나의 일을 하는 뚜렷한 이름의 함수를 만들자 

ex) 폼에서 약관체크 후 질문 제출하는 함수라면 2번으로 작성해야함 
1. 질문제출 
2. 약관체크 후 질문제출 
하지만 두 기능을 함수로 쪼개는게 좋음  (약관체크 / 질문제출) 


ex2) 

before
&lt;button 
    onClick={async () =&gt; {
        log('재출 버튼 클릭')
        await openConfirm();
    }}
/&gt;

after 
&lt;LogClick message="제출 버튼 클릭"&gt;
    &lt;button onClick={openConfirm} /&gt;
&lt;/LogClick&gt;



# 추상화
- 핵심개념 추출 

선언적 프로그래밍
세부기능은 함수안에 숨겨두고 넘겨주는 형태로.. 실행 단계에서만 보고 파악가능한 코드 
&lt;Popup 
    onsubmit={질문전송}
    onSuccess={홈으로 이동}
/&gt;

- 추상화 단계를 비슷하게 정리 
모두 컴포넌트로 하거나 
모두 풀거나


# 비동기 비지니스 로직의 분리 
- 성공, 실패를 분리해서 작성 (error 로직은 외부에 위임)

ex) async await 



                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->

                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>병목현상<span> bottleneck</span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# 병목현상 (bottleneck) 이란?   

`차로가 4차선에서 2차선으로 줄어들 때 생기는 교통체증 같이 
프로그래밍에서 생기는 정체현상

많은 양의 데이터를 순식간에 보냈을 때 메모리가 이를 제대로 소화하지 못해 성능이 떨어지는 현상. 
주로 용량이 적은 주변기기를 사용할 때 많이 발생. 
즉 담을 수 있는 데이터의 양은 적으나 한꺼번에 많은 양의 데이터가 유입 됨으로써 
컴퓨터가 느려지는 현상


때문에 js에선 가비지컬렉터(GC) 가 중간중간 제거를 해줌

https://github.com/ejonghwan/performance_apply 
aticle 컴포넌트안에 병목현상이 생기는 함수 `



# 예제 코드
/*
 * 파라미터로 넘어온 문자열에서 일부 특수문자를 제거하는 함수
 * (Markdown으로 된 문자열의 특수문자를 제거하기 위함)
*/
function removeSpecialCharacter(str) {
    const removeCharacters = ['#', '_', '*', '~', '&', ';', '!', '[', ']', '`', '>', '\n', '=', '-']
    let _str = str
    let i = 0,
      j = 0
  
    for (i = 0; i &lt; removeCharacters.length; i++) {
      j = 0
      while (j &lt; _str.length) {
        if (_str[j] === removeCharacters[i]) {
          _str = _str.substring(0, j).concat(_str.substring(j + 1))
          continue
        }
        j++
      }
    }
  
    return _str
  }

 //jsx 
 &lt;div className={'Article__summary__desc'}&gt;{removeSpecialCharacter(props.content)}&lt;/div&gt;


# 문제점
`위 코드의 문제점.. 
 인자로 넘어온 마크다운 문자열중 특수문자를 제거하기 위해 
 두번의 반복문을 돌고 있음 
 
 때문에 퍼포먼스 탭에서 반복문을 두번씩 돌다가 메모리가 넘치면 GC가 제거하고 
 다시 돌리고를 반복해서 병목현상이 발생
`


# 해결방법
1. .replace 함수와 정규식 사용
2. 마크다운의 특수문자를 지워주는 라이브러리 사용
3. 작업하는 양 줄이기 (전체 말고 필요한 부분만 계산)



//let _str = str.substring(0, 300); //모든 문자열이 아닌 0~ 300자 까지만 검사 
//_str = _str.replace(/[\#\_\*\~\&\;\!\[\]\`\>\n\=\-]/g, '') //내장객체와 정규표현식 사용 



                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>code splitting & lazy loading<span></span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="javascript">
# code splitting : 코드 분할 ..큰 파일을 필요한부분만 쓸 수 있게 .. 
# lazy loading : 나중에 필요한건 나중에 로딩
- 모듈별로
- 페이지별로
- 위 두가지 섞어서

핵심은 "불필요한 코드와 중복되는 코드" 없이 
"적절한 사이즈의 코드"가 
"적절한 타이밍에 로드"될 수 있도록 


//code splitting은 웹팩이 해주는 것임. 웹팩 설정  (cra는 설정 다 되어있음)
//https://webpack.js.org/guides/code-splitting/#root


//https://ko.reactjs.org/docs/code-splitting.html
//Route-based code splitting



`
!! 예제 문제점
현재 번들파일이 용량이 커서 다운로드 시간이 오래걸림
다운로드 시간이 오래걸리면 다운로드 후 실행하기 떄문에 그만큼 지연됨 
`


`1. 분석 툴 (https://www.npmjs.com/package/webpack-bundle-analyzer)`
npm i webpack-bundle-analyzer 

`2. cra를 사용한다면 직접 플로그인 넣으려면 웹팩을 리젝하거나 커스텀lib 써야함
 lib -> cra-bundle-analyzer
 https://www.npmjs.com/package/cra-bundle-analyzer
`
npm i cra-bundle-analyzer
npx cra-bundle-analyzer



`3. cra-bundle-analyzer 실행해보면 번들파일에서 
어떤게 제일 많이 먹고 있는지 블럭으로 보여줌... 

1. chunk.js 제외하고 가장 많이 먹고 있는게 refractor
2. pakacge-lock.json 에서 refractor 검색해보면 
3. react-syntax-highlighter 에서 사용하는 하위 종속된 모듈인것 확인
4. 그렇다면 상세페이지에서만 필요한거니 상제페이지에서만 다운로드하게끔 코드 스플리팅!
`


//splitting code 
`cra는 웹팩설정 안해줘도 되지만 처음부터 설정한다면 code splitting 설정을 따로 해줘야함..웹팩이 해주는거라`

import React, { Suspense, lazy } from 'react'
import { Switch, Route } from 'react-router-dom'

const Component1 = lazy(() =&gt; import('./page/component1/index'))
const Component2 = lazy(() =&gt; import('./page/component1/index'))

&lt;Suspence fallback={&lt;div&gt;loading...&lt;div&gt;}&gt;
    &lt;Switch&gt;
        &lt;Route path="/" component={Component1} exact /&gt;
        &lt;Route path="/about/:id" component={Component2} exact /&gt;
    &lt;/Switch&gt;
&lt;/Suspence&gt;



//Component2 
import { Link } from 'react-router-dom'
&lt;Link to={`/view/${item.id}`}&gt;
    &lt;Article {...item} /&gt;
&lt;/Link&gt;



코드 적용결과(npx cra-bundle-analyzer) 
refractor 코드와 react-dom 코드가 분리되어있음

때문에 
리스트 페이지에서는 필요한 모듈만을 불러오고 
뷰 페이지에서는 두개를 더 불러옴


                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->

                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>reflow repaint</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# 브라우저 렌더링 간단하게 
1. DOM 생성 
2. CSSOM 생성
3. DOM + CSSOM = render tree 생성 
4. layout (위치 크기 계산해서 배치)
5. paint (색칠)
6. composite (레이어별로 layout와 paint가 작업된 레이어들을 합성)


# 리플로가 발생하는 경우 
엘리먼트의 위치나 크기가 변경했을 경우, 화면이 리사이즈 되었을 경우 
js > style > layout > paint > composite

# 페인트부터 발생하는 경우 
엘리먼트 수치가 아닌 컬러 등이 변경 되었을 경우 
js > style > paint > composite   (layout 단계 건너띔)

# 합성 단계만 발생하는 경우 (베스트) 
합성단계만 일으키는 css 속성들 사용했을 경우 
js > style > composite   



# 주의
reflow가 일어나는 css를 사용하면 렌더링할 때마다 1~ 6까지의 단계가 반복됨 ... (1,2,3,4,5,6 단계) 

- 리플로우를 자주 발생하는 소스의 퍼포먼스탭에 프레임을 보면 
  화면이 그려지는 각각 라인에 걸쳐있는 composite를 볼 수 있는데 
  라인에 걸쳐 있다면 화면엔 이전 프레임의 화면이 보여질거고 
  1 프레임이 누락되었기 때문에 60fps의 모니터를 사용시 59프레임이 되어버림... 
  그래서 뚜둑 끊기는거 (프레임 드랍)

- 퍼포먼스 탭에서 제일 상단에 있는 녹색 그래프가 프레임수를 나타내고(오른쪽에 FPS라고 써져있음) 
  60fps일 때 들쑥날쑥 하다면 애니메이션이 일어나면서 프레임드랍이 일어난거임

- 퍼포먼스 탭에서 상단에 보라색(레이아웃)과 녹색(컴포짙)이 많다는건 메인스레드가 많이 처리했다는 뜻 



# 해결
1. composite만 일어나는 css를 사용하는게 가장 베스트 
2. repaint부터 일어나는 css 사용  ...(1,2,3,5,6 단계)
2. GPU를 사용하는 opacity, transform 사용하기... (1,2,3,6 단계)
   (이건 좀 더 찾아봐야함.. opacity가 어떤 레이어에 있냐에 따라 reflow발생)
   (GPU를 사용하면 메인스레드가 작업하지 않기에 성능이 향상됨)



/*  기존 코드
    width: ${({width}) => width}%;
    transition: width 1.5s ease;
*/

/*  개선 코드
    width: 100%;
    transform: scaleX(${(props) => props.width / 100});
    transform-origin: 0;
    transition: transform 1.5s ease;
*/






GPU에 관련된 답글 
안녕하세요 불멸의너구리좌님,

GPU를 사용하는 상황에서 데이터 통신에 대한 부하가 걸리지는 않는지 질문을 주셨는데요.

브라우저가 GPU에 작업을 위임할 때, 흔히 우리가 생각하는 네트워크 통신처럼 시간이 걸는게 아니라 굉장히 빠른 프로세스 간의 통신이 이뤄집니다. 
또한, 크롬 브라우저에서는 이미 GPU 프로세스를 포함한 여러 역할을 담당하는 프로세스들이 동작하고 있기 때문에 
별도의 오버헤드 없이 해당 프로세스들 끼리 데이터를 주고 받을 수 있게 됩니다.

즉, CPU에서 처리함으로써 떨어지는 성능에 비하면 거의 무의미한 수준의 비용이기 때문에 오히려 빨라지는 것입니다.

참고하실 수 있도록 도움되는 링크를 알려드리겠습니다.
- https://dev.opera.com/articles/ko/css-will-change-property/
- https://d2.naver.com/helloworld/2922312
- https://developers.google.com/web/updates/2018/09/inside-browser-part3#raster_and_composite_off_of_the_main_thread

강의에 관심을 가져주셔서 감사합니다. :)


                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>preload <span>component</span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">

# 이미지 슬라이드 팝업을 레이지로드 했을 때

import React, { useState, Suspense, lazy } from 'react'
const ImageModal = lazy(() => import('./components/ImageModal'))


&lt;Suspense fallback={null}&gt;
&nbsp;&nbsp;&nbsp;{showModal ? &lt;ImageModal closeModal={() =&gt; { setShowModal(false) }} /&gt; : null}
&lt;/Suspense&gt;



# 문제점
code splitting이 잘 되어 나중에 요청이 되지만 
문제는 느리다 ... 

왜냐면 클릭했을 때 ImageModal 컴포넌트에 있는 모듈 등등을 불러오기 때문에... 



# 해결방법 
이럴 때 preload를 해주면 된다. 크게 두가지 방법으로,. 

1. 버튼에 마우스 오버를 했을 때 
2. 화면로드가 다 끝난 후

코드 스플리팅했던 슬라이드에 사용된 image css module 등을 사전로드 하게 되면 
미리 로드준비를 해놓고 캐시에 저장해놔서 특정시점(나는 마우스오버에 검) 을 만나면 캐시해둔 
리소스를 받기 떄문에 빠르다



import React, { useEffect, lazy, Suspense } from 'react'

1. 마우스오버 시 프리로드 
const handleMouseenter = () => import('./')
const ImageModal = lazy(() => import('./'))
&lt;button onClick={imageModal} onMouseEnter={handleMouseenter}&gt;click&lt;/button&gt;

2. 받을게 많다면 마운트 후 시점에
useEffect(() => {
    // import한 함수를 변수에 안담아두면 함수실행하고 사용안한다고 에러뜸 
    const component = import('./')
}, [])
const ImageModal = lazy(() => import('./'))
&lt;button onClick={imageModal} &gt;click&lt;/button&gt;




부가 ------
// 만약 임포트할게 많다면 팩토리패턴으로 함수 
const lazyWithPreload = (importFunction) => {
    const Component = React.lazy(importFunction)
    console.log(Component)
    Component.preload = importFunction;
    return Component
}

const LazyImageModal = lazyWithPreload(() => import('./components/ImageModal'))

useEffect(() => {
    LazyImageModal.preload()
}, [])


                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>preload <span>image</span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
// 기본적으로 image에 src속성이 들어가는 순간 비동기적으로 이미지 로드함
const img = new Image()
img.src = './'


# 마운트 후 시점에 이미지 사전로드 
useEffect(() => {
    const img = new Image()
    img.src = './'
}, [])

`하지만 이렇게 하면 다시 img.src 했을 때 또 로드됨... 미리 로드했기 떄문에 캐시가 걸려있는 상태` 
`네트워크 탭에서 해당 파일보면 cache-control 항목이 걸려있음`

`중요한건 가장크고 중요한 이미지만 사전로드하는 게 중요함... 모두 사전로드하면 오히려 느려짐`

                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>cache<span></span></button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# 결론
서버에서 캐시를 리소스마다 다르게 설정하여 최적화 
ex) 
const header = {
    setHeaders: (res, path) => {
        if(path.endsWith('.html')) {
            // html은 변경 시 마다 새로받음
            res.setHeader('Cache-Control', 'no-cache') 
        } else if(path.endsWith('.js') || path.endsWith('.css') || path.endsWith('.webp') || path.endsWith('.jpg')) {
            // hash를 하면 길게줌 (빌드 시에도 변경이 없으면 해시값이 안변함...개쩌네;;)
            res.setHeader('Cache-Control', 'public, max-age=315360000')
        } else {
            // 그 외 파일은 캐시하지않음
            res.setHeader('Cache-Control', 'no-store')
        }
    }
}
app.use(express.static(path.join(__dirname, '../build'), header))

1. 이미지가 자주 안바뀌는 리소스들(로고 등)은 max-age를 길게 줘서 다운로드 받지 않게만듦

HTML  no-cache 
JS    public, max-age=31536000  (hash 붙여야함) max-age 1년임
CSS   public, max-age=31536000  (hash 붙여야함)
IMG   public, max-age=31536000  (hash 붙여아함)


- html은 메타에 no-cache해서 변경되었을 때만 다운로드함 
- js css는 변경시, 빌드시 마다 해시를 걸거나 ...함 (리액트는 빌드시 해시 붙음)

  중요..! 순서를 보면 html에서 js와 css를 호출하는데 
  html/main.a.js/main.a.css 있다고 치고 html 변경 시 서버에서 새로 받는데 
  js와 css는 변경도 안되었는데 캐시된 a를 사용안하고 b를 새로 받아버림.. 
  때문에 html만 no-cache로 변경시마다 받고.. js css는 max-age(캐시)를 7일 30일 등으로 설정함
  (리액트에서 빌드 시에도 js css image가 변경되지 않으면 해시도 변경안됨.. 그래서 캐시된걸 받음) 

- image는 자주 변경되는 이미지일 경우 max-age를 짧게 주거나, js css처럼 해시를 달고 max-age를 길게 줌




------------- 설명 
 
 response header에 cache-control

# 캐시: 데이터나 값을 미리 복사해 놓는 임시 장소나 그런 동작
        브라우저 알고리즘에 의해 아래 두 가지로 적절하게 저장함 



# 메모리 캐시: 메모리(RAM)에 저장   
   - 메모리 캐시는 브라우저를 껐다 켜면 사라져있음. 브라우저가 사용하는 메모리를 날렸기 때문 
     메모리에선 날리고 파일로 가지고 있어서 다시 브라우저 켜보면 디스크캐시만 남음



# 디스크 캐시: file로 데이터 저장 후 가져와서 사용 
  - 브라우저 껐다 켜면 메모리 캐시 날라가있고 디스크캐시만 뜸



# 캐시 설정하기 
서버에 http request 보낼 때 cache-control에 설정하여 요청

- client: 요청해더에 캐시요청
- server: 캐시요청오면 설정해서 응답


# Cache-Control:
1. no-cache - 캐시를 사용할건데 사용 전에 서버에 검사 후, 사용걸정 
2. no-stroe - 캐시 사용 안함 
3. public   - 모든 환경에서 캐시 사용 가능 
4. private  - 브라우저 환경에서만 캐시 사용, 외부(캐시서버) 캐시 서버에서는 사용 불가 
              (예로 로그인 후 캐시데이터들은 남들과 공유되면 안되니깐 이 옵션을 씀)
5. max-age  - 캐시의 유효기간 60초
            
이외에 ETag, expires 등 있음


# 중요!! 
- no-cache === max-age=0 이어도 캐시를 삭제하는게 아니라 가지고 있다가 reqeust 할 때 클라이언트에서 이 사진에 캐시가 만료가 되었는데 계속 사용해도 돼 ? 라고 서버에 물어봄. 서버에서 수정안됐으니 사용해라고 ok나면 사용하고 수정됐다고 no라면 서버에서 파일 다운로드.. 

- 메인에서 서브페이지 css를 받았을 때 용량이 더 작게 받아지는게 이런 경우임
해당 페이지에 no-cache가 있어서? 테스트해봤을 때 서브페이지 드가면 작은 파일 받아짐 

(네트워크탭에서 304 낫 모디파이드 라고 되어있으면 수정이 안되어 캐시되어있는 파일 썼다는 의미) 




# ETag
- 네트워크 탭 응답해더에 ETag값으로 해시가 있음
1. 클라이언트 리소스 이미지에 ETag : a 가 있으면 
2. 서버에도 리소스 이미지로 ETag : a 가 있음 
3. 클라이언트가 이거 사용해도 돼 ? 하면서 ETag를 보내줌 
4. 서버는 서버에 있는 ETag를 비교해서 같으면 ETag를 보내주고 아니면 변경된 이미지를 보내줌







# meta tag 
<meta http-equiv="Cache-Control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
페이지를 cache에서 가져오지 않게 하며 항상 서버에 접속해서 페이지를 가져옵니다.
그러므로 방문자의 브라우저가 항상 cache를 읽도록 해 놓아도 이것을 무시하고 페이지를 갱신합니다.
자주 고치는 페이지에서는 이것을 사용하는 것이 항상 방문자에게 바뀐 내용을 보여 줄 수가 있습니다. 
하지만 페이지 출력 속도는 매번 페이지를 가져오므로 cache를 사용할 수 없어서 시간이 많이 걸린다는 점입니다.



출처: https://webclub.tistory.com/354 [Web Club]



-----------확인 필요
https://www.next-t.co.kr/blog/%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%B5%9C%EC%A0%81%ED%99%94-SEO-%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%ACSEO-%EB%A9%94%ED%83%80%ED%83%9C%EA%B7%B8-metatags-expires-%EC%86%8D%EC%84%B1

<META HTTP-EQUIV=”Expires” CONTENT=”Mon, 06 Jan 1990 00:00:01 GMT”>
<META HTTP-EQUIV=”Expires” CONTENT=”-1″>
<META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
<META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    
– Expires : 본 문서가 content에 지정된 시간부터 유효하지 않음(캐시만료)을 알려주는 기능을 합니다.
– content 항목이 -1이면 조건부 캐쉬만료를 의미합니다.
– Mon, 06 Jan 1990 00:00:01 GMT : 만료날짜를 그리니치 시간으로 적습니다.
– Pragma : content 항목인 “no-cache” 명령어를 전달합니다. 즉, 캐시 기능을 하지말라는 뜻입니다.
– Cache-Control : 캐시를 제어하기 위한 기능입니다. content에 ‘no-cache’라고 적혀있기 때문에 cache를 하지 않습니다.
– Pragma와 Chache-Control의 문제점 : 인터넷 익스플러어 5.0 혹은 HTTP1.0에서는 여러가지 경우에 따라 동작하지 않을 수 있다고 합니다. 또한 웹서버의 제어에 따라 동작하지 않을 수 있습니다.
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>unused css</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# 커버리지탭 
사용하지 않는 css 줄이기 


# purgecss module 
- class 이름을 모두 추출해서 html에서 사용하지 않는 css는 제거해주는 모듈

npm i -D purgecss

// scripts
"purge": "purgecss --css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js/*.js --config ./purgecss.config.js"

--css: 줄일 파일  --output: 어디로 내보낼건지(위 예제는 같은 경로 덮쓰) --content: 어떤 파일들에 있는 className이랑 비교할건지  --config: 설정파일실행

빌드 후 npm run purge를 하면 줄어든 css 가 나옴... 



# purgecss 문제점 
aa:mg 이런 클래스가 있을 때 : 이걸 구분자로 구분함...;;;

해결방법은 configuration 
https://purgecss.com/configuration.html


루트폴더에 purgecss.config.js 생성
module.exports = {
    content: ['index.html'], //cli에서 작성안하면 여기서 할수 있음
    css: ['style.css'],
    defaultExtractor: (content) => content.match(/className/g) || []
    defaultExtractor: (content) => content.match(/[\w\:\-]+/g) || []
    //아까 비교할 --content 이걸 여기에서 비교해서 배열로 리턴
  }




https://www.npmjs.com/package/purgecss

                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>memoization</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
# 병목함수에 memoization 적용 

`문제점 
예제를 퍼포먼스탭에서 돌려보면 getAverageColorOfImage()가 실행시간이 길다  
매번 이미지를 다운로드하고 그 컬러값의 평균값을 계산하여 bg에 깔기 때문인데.. 
`

`해결
객체에 한번 들어왔던 src들을 저장하여 다음에 또 클릭 시 getAverageColorOfImage함수 로직을 
타지않고 객체에 저장된걸 바로 적용하게끔..
`

</code>

<code class="javascript">
ex code)
const cache = {} // memoization 로직 추가


export function getAverageColorOfImage(imgElement) {

  // memoization 로직 추가
  if(cache.hasOwnProperty(imgElement.src)) {
    return cache[imgElement.src]
  }


  const canvas = document.createElement('canvas');
  const context = canvas.getContext && canvas.getContext('2d');
  const averageColor = {
    r: 0,
    g: 0,
    b: 0,
  };

  if (!context) {
    return averageColor;
  }

  const width = (canvas.width =
    imgElement.naturalWidth || imgElement.offsetWidth || imgElement.width);
  const height = (canvas.height =
    imgElement.naturalHeight || imgElement.offsetHeight || imgElement.height);

  context.drawImage(imgElement, 0, 0);

  const imageData = context.getImageData(0, 0, width, height).data;
  const length = imageData.length;

  for (let i = 0; i &lt; length; i += 4) {
    averageColor.r += imageData[i];
    averageColor.g += imageData[i + 1];
    averageColor.b += imageData[i + 2];
  }

  const count = length / 4;
  averageColor.r = ~~(averageColor.r / count); 
  averageColor.g = ~~(averageColor.g / count);
  averageColor.b = ~~(averageColor.b / count);


  // 여기서 한번 들어왔던 값들을 적용
  // console.log(imgElement)
  cache[imgElement.src] = imgElement 


  return averageColor;
}
</code>
<code class="javascript">
모듈로 뺄 때  -------------------------------------------------------------

function memoization(fn) {
    const cache = {}
    return function(...args) { 
        //args는 배열로 오는데 ..1개 이상의 것은 변경될 수 있기에 방어코드
        //이런 로직은 순수함수여야함... 
        if(args.length !== 1) {
            return fn(...args)
        } 

        if(cache.hasOwnProperty(args)) {
            return cache[args]
        }

        const result = fn(...args)
        cache[args] = result

        return result
    }
}


` 같은 함수
memoization(getAverageColorOfImage)(img)  ===  getAverageColorOfImage(img)
`
</code>
<code class="javascript">
ex code 2)
export function getAverageColorOfImage = memoization(function(imgElement) {

  const canvas = document.createElement('canvas');
  const context = canvas.getContext && canvas.getContext('2d');
  const averageColor = {
    r: 0,
    g: 0,
    b: 0,
  };

  if (!context) {
    return averageColor;
  }

  const width = (canvas.width =
    imgElement.naturalWidth || imgElement.offsetWidth || imgElement.width);
  const height = (canvas.height =
    imgElement.naturalHeight || imgElement.offsetHeight || imgElement.height);

  context.drawImage(imgElement, 0, 0);

  const imageData = context.getImageData(0, 0, width, height).data;
  const length = imageData.length;

  for (let i = 0; i &lt; length; i += 4) {
    averageColor.r += imageData[i];
    averageColor.g += imageData[i + 1];
    averageColor.b += imageData[i + 2];
  }

  const count = length / 4;
  averageColor.r = ~~(averageColor.r / count); // ~~ => convert to int
  averageColor.g = ~~(averageColor.g / count);
  averageColor.b = ~~(averageColor.b / count);

  return averageColor;
})



# 주의점 
이 기법에 단점은 메모리가 든다는 점... 
input값이 달라지는 것들은 적절하지않음 
input값이 항상 같고 output도 같은 것들, 혹은 계산 로직이 너무 방대한 것에 한해 적용

                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>throttle</button></dt>
                                <dd>
                                    주기적으로 실행
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
                                
function throttle(cb, wait) {
    var waiting = true;
    return function(args) {
        if(waiting) {
            cb(args);
            waiting = false;

            setTimeout(function() {
                // console.log('hoho')
                waiting = true
            }, wait)
        } 
    }
}
                            </code>
<code class="markdown">
raf로 쓰로틀링
function throttleUsingRaf(cb) {
    var rAfTimeout = null;
  
    return function () {
      if (rAfTimeout) {
        window.cancelAnimationFrame(rAfTimeout);
      }
      rAfTimeout = window.requestAnimationFrame(function () {
        cb();
      })
    }
  }
  function onScroll() {
    // code ...
  }
  document.addEventListener('scroll', throttleUsingRaf(onScroll));
</code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                           <!-- item -->
                           <div class="item_wrap">
                            <dl class="item">
                                <dt><button>debounce</button></dt>
                                <dd>
                                    특정 시간동안 맨처음 혹은 마지막 한번만 실행
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="markdown">
function debounce(cb, wait) {
    var timeout;
    return function(args) {

        console.log(timeout)
        clearTimeout(timeout); //한번이면 바로 클리어

        timeout = setTimeout(function() {
            cb(args);
        }, wait);
    }
}
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                    </div>
                </section>
                <!-- performence -->

                <!-- React -->
                <section class="conts">
                    <h2>React</h2>

                    <div class="depth_2">
                        <strong>Hooks</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useState</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">
// 상태값 관리

import React, { useState } from 'react'

const Counter = () => {
    const [n, setN] = useState(0)
 

    // 함수에 state를 바로 사용할 경우 
    const inc = () => {
      setN(n + 1)
    }
  
    const dec = () => {
      setN(n - 1)
    }

    // prev값을 인자로 받아서 사용할 경우 
    const [n, setN] = useState(0)
 

    const inc = () => {
      setN(n => n + 1)
    }
  
    const dec = () => {
      setN(n => n - 1)
    }
  

    return (
      <div>
        <h1>{n}</h1>
        <button onClick={inc}>inc</button>
        <button onClick={dec}>dec</button>
      </div>
    );
  }
  
  export default Counter;


<!-- 이거 아직 안함 해야됨 퍼퓰 정리도 해야됨  퍼퓰 뭐하려고했었지 ? 아 객체안에 있는거 접근해서 퍼퓰하는거 project rank-->

  주의 
  1. onClick={onIncrease()}  형태라면 바로 실행에
  2. closure 때문에 hook들은 컴포넌트 함수 바로 아래있어야함.
  3. 커스텀 훅들은 use로 시작해야함.
  4. closuer 때문에 submit 이벤트에 e.preventDefault 안먹는 현상... 이건 아직도 모르겠네 대체방법 

    이거 디바운스 적용하다가 난거... 결론은 로대쉬꺼 말고 커스텀된 util.js에 있는 debounce를 가져와서 적용했는데 
    const fn = debounce(300, (e) => { 실행로직 })
    이 형태에서 e 객체에 있는 preventDefault가 안먹어서 분리했음. (콘솔엔 찍혔음)

    // 분리
    const dd = _debounce(() => {
        return console.log(1111)
    })

    const fn = (e) => {
        e.preventDefault();
        console.log(e)
        dd();
    }
 







https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useEffect</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">








https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useRef</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

ref 정리하기 
https://www.daleseo.com/react-forward-ref/ 
https://as-you-say.tistory.com/216
https://mingule.tistory.com/61


명령 / 선언 
https://boxfoxs.tistory.com/430


https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useCallback</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">
https://velog.io/@hjkdw95/debounce-%ED%95%A8%EC%88%98%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-useCallback-useMemo


디바운스 리액트적용한거 나중에 정리
https://intrepidgeeks.com/tutorial/useimplement-debonse-in-react


디바운스 리액트에 적용된거 usecallback 사용함 얘는 
https://dev.to/reflexgravity/use-lodash-debouce-inside-a-functional-component-in-react-4g5j


https://velog.io/@raverana96/react-react-hook-form%EC%97%90%EC%84%9C-debounce-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0

https://velog.io/@say_ye/JS-%EB%94%94%EB%B0%94%EC%9A%B4%EC%8A%A4-%EC%93%B0%EB%A1%9C%ED%8B%80-Debounce-Throttle-with-lodash








https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useMemo</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">








https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useContext</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="javascript">
` 
  컨텍스트 등록... 
  하나의 값이 변경되면 모두 리렌더링이 되기 때문에 콘텍스트마다의 분리가 중요
`

// 간단 정리
// 1. 컨텍스트 만들기  createContext()
// 2. 공급자 만들기 - 공급자 함수(hoc) UserContext.Provider
// 3. reducer 연결 useReducer가 (state, dispatch) 리턴해줌  - useReducer(reducer, initialstate)
// 4. UserContext.Provider에 prop으로 내려주기
// 5. 사용할 곳에 Provider감싸주기

// 사용할떈 createContext 들어있는 변수 호출해서 사용 
// const { state, dispatch } = useContext(ImageContext)



ex1) useContext + useReducer로 Redux처럼 사용하기 

` 1. 필요한 컨텍스트 작성 `
// context/ImageContext.js  
import React, {useReducer, useContext, createContext} from 'react';
import { reducer, initialState } from './reducers/index.js'

export const ImageContext = createContext(null)

export const ImageContextProvider = ({ children }) =&gt; {

    const [ state, dispatch ] = useReducer(reducer, initialState)
    return (
        &lt;ImageContext.Provider value= state, dispatch &gt;
            {children}
        &lt;/ImageContext.Provider&gt;
    )
}

</code>
<code class="javascript">
` 2. 관리할 리듀서 작성  `
// reducers/index.js 
export const initialState = {
    test: true,
}

export const reducer (state = initialState, action) =&gt; {
    switch(action.type) {
        case "TEST_REQUEST": 
            return {
                ...state,
                test: !state.test, 
            }

        default: 
            return {
                ...state
            }
    }
}

</code>
<code class="javascript">
` 3. 앱에 Provider 추가  `
//app.js 
import Context_test from './components/Context_test.js'
import { ImageContextProvider } from './context/ImageContextProvider.js'


const App = () =&gt; {
    return (
       &lt;ImageContextProvider&gt;
           &lt;Context_test /&gt;
       &lt;/ImageContextProvider&gt;
    ) 
}

</code>
<code class="javascript">
` 4. 실제 사용할 컴포넌트에 useContext하기  `
//Context_test.js 
import React, { useContext } from 'react';
import { ImageContext } from './context/ImageContextProvider.js'


const Context_test = () =&gt; {

    const { state, dispatch } = useContext(ImageContext)
    //state - 리듀서의 initialState 
    //dispatch - 리듀서 디스패치 함수 

    const handleClick = e =&gt; {
        dispatch({ type: 'TEST_REQUEST' })
    }

    return (
        &lt;div&gt;
             {state.test ? (&lt;span&gt;false&lt;/span&gt;) : (&lt;span&gt;true&lt;/span&gt;)}
            &lt;button onClick={handleClick}&gt;chage state&lt;/button&gt;
        &lt;/div&gt;
    )
}

https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useReducer</button></dt>
                                <dd>
                                    -
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="javascript">








https://ko.reactjs.org/docs/hooks-reference.html#usecontext
                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>useTransition</button></dt>
                                <dd>
                                    startTransition
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="javascript">

18 버전 이상





                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                           <!-- item -->
                           <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>Suspense</button></dt>
                                <dd>
                                    Suspense and SSR
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                            <code class="javascript">
18 버전 이상
테코톡: 설명 좀 대충함 
https://www.youtube.com/watch?v=focpJqfSu4k

유툽: 자세한 설명
https://www.youtube.com/watch?v=8q7OQSPLF4k 

# CSR
1. Load JS (빈화면)
2. Fetch Data (빈화면)
3. Render Components (빈화면)
4. Interactive (화면과 상호작용 동시에 완료)


# SSR 
1. Fetch Data (빈화면)
2. Render as HTML (브라우저가 화면 그림)
3. Load JS (js 읽음)
4. Hydrate (완료)

(1) 브라우저가 서버에 페이지를 요청하면 데이터를 내려주고  
(2) 리액트 컴포넌트를 HTML로 렌더링함 (인터렉티브하지않음) 
(3) JS를 로드 (모든 로직을 브라우저 HTML과 연결)
(4) 3. 연결하는 과정을 Hydrate 라고함.. 컴포넌트를 렌더링하고 이벤트 핸들러를 연결하는 과정

기존 SSR의 문제점. 
1. 모든 data fetch가 끝나야 어떤 것이라도 보여줄 수 있다. 
2. 모든 JS 코드를 로딩하기 전에는 Hydration 단계로 넘어갈 수 없다
3. 앱이 상호작용할 수 있는 상태가 되려면 앱 전체 Hydration이 완료되어야했다. 



## Suspense 이용

기존에는 앱 전체를 묶어야했다면 Suspense를 이용한다면 컴포넌트 별로 Hydrate
아래 3개의 컴포넌트를 Suspense로 묶어 개별로 진행

NavBar Component: 
1. Fetch data
2. render as HTML 
3. Load JS
4. Hydrate 

Posts Component:
위 4단계 동일 

Comments Component:
위 4단계 동일 



Layout 
   NavBar 
   SideBar 
   Post 
   Suspense fallback={<Spinner />} 
      Comments 
   Suspense


* 위 구조일 때 코멘트 컴포넌트가 그려지기 전, 스피너가 도는 동안 NavBar, SideBar, Post를 먼저 그림. 
** 서버에서 렌더링이 완료되면 코먼트 컴포넌트를 그림

----------------------------------------

코멘트에 대한 JS코드가 로드 될 때까지 클라이언트에서 Hydrate를 시작 할 수 없는 문제점 해결법?
과거: SSR에서 lazy와 suspense 사용불가 

18버전부터는 코멘트가 로드 되기 전 앱에 코멘트를 Hydrate 가능 
import { lazy } from 'react'

const Comments = lazy(() => import("./Comments.js"))
//...

Suspense fallback=spinner
   Comments




                            </code>
                        </pre>
                            </div>
                        </div>
                        <!-- item -->
                    </div>

                    <div class="depth_2">
                        <strong>Library</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>react-router-dom <span>v6 기준</span></button></dt>
                                <dd>
                                    router
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">
react-router (아래 두개 포함)
react-router-dom (웹은 얘만 받아서씀)
react-router-native
BrowserRouter
Route
Routes
Link



//참고한 블로그 및 공식 
//https://kyung-a.tistory.com/36                         
//https://reactrouter.com/docs/en/v6/getting-started/installation
                        </code>

<code class="markdown">
# 1. react-router-dom import  

import { BrowserRouter, Route, Routes, Link } from 'react-router-dom'


/*
BrowserRouter - HTML5의 history API 사용 (req, res 등에 적합)
HashRouter - URL의 hash를 사용 (static한 파일에 적합)
Route - 요청받은 pathname 컴포넌트를 렌더링
Routes - Route들의 충돌 방지 (path 일치하지 않을 시 맨 아래 path없는 라우트 실행)
Link - 링크 생성
*/



</code>
<code class="markdown">
# 2. 선언  

import { BrowserRouter, Route, Routes, Link } from 'react-router-dom'

`App.js`
&lt;BrowserRouter&gt;
    &lt;Component /&gt;
&lt;/BrowserRouter&gt;


`Route.js`
&lt;Routes&gt;
    &lt;Route path="" element={&lt;Component /&gt;}&gt;
    &lt;Route path="" element={&lt;Component /&gt;}&gt;
    &lt;Route path="" element={&lt;Component /&gt;}&gt;
&lt;/Routes&gt;


`page`
&lt;Link to=""&gt;&lt;/Link&gt;
&lt;Link to=""&gt;&lt;/Link&gt;
&lt;Link to=""&gt;&lt;/Link&gt;

</code>

<code class="markdown">

# query string 가져올때 쓰기 

react-router-dom v6 이상 쓰시는 분들은 useSearchParams 를 사용

import { useSearchParams } from 'react-router-dom';

const [searchParams] = useSearchParams();
const detail = searchParams.get('detail') === 'true';


----------------------------------------------------------

# 샘플

import {useSearchParams} from 'react-router-dom';

export default function App() {
  const [searchParams, setSearchParams] = useSearchParams();

  const removeQueryParams = () => {
    const param = searchParams.get('q');

    if (param) {
      // 👇️ delete each query param
      searchParams.delete('q');

      // 👇️ update state after
      setSearchParams(searchParams);
    }
  };

  const handleChange = event => {
    setSearchParams({q: event.target.value});
  };

  console.log(searchParams.get('q'));

  return (
    &lt;div&gt;
      &lt;button onClick={removeQueryParams}&gt;Remove query param&lt;/button&gt;

      &lt;input id="search" autoComplete="off" onChange={handleChange} /&gt;
    &lt;/div&gt;
  );
}




</code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                </section>
                <!-- //React -->



                <!-- Vue -->
                <section class="conts">
                    <h2>Vue</h2>

                    <!-- LifeCycle-->
                    <div class="depth_2">
                        <strong>LifeCycle</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onBeforeMount</button></dt>
                                <dd>
                                   돔이 마운트 되기 바로 전 
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onBeforeMount(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onMounted <span>* 자주씀</span></button></dt>
                                <dd>
                                   돔이 마운트 된 후
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onMounted(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onBeforeUpdate</button></dt>
                                <dd>
                                   데이터가 업데이트 되기 바로 전
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onBeforeUpdate(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onUpdated <span>* 자주씀</span></button></dt>
                                <dd>
                                   데이터가 업데이트 될 때
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onUpdated(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->

                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onBeforeUnmount</button></dt>
                                <dd>
                                   언마운트 되기 바로 전
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onBeforeUnmount(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onUnmounted <span>* 자주씀</span></button></dt>
                                <dd>
                                   언마운트 된 후
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

function onUnmounted(callback: () => void): void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->

                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onErrorCaptured</button></dt>
                                <dd>
                                    자식 컴포에서 전파된 에러가 캡쳐되었을 때
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

자식 컴포넌트에서 전파된 에러가 캡쳐되었을 때 호출될 콜백을 등록

function onErrorCaptured(callback: ErrorCapturedHook): void

type ErrorCapturedHook = (
    err: unknown,
    instance: ComponentPublicInstance | null,
    info: string
) => boolean | void

https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onRenderTriggered</button><span>dev only</span></dt>
                                <dd>
                                    컴포넌트의 렌더 이펙트가 반응형 의존성에 의해 다시 실행되도록 트리거된 경우
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

컴포넌트의 렌더 이펙트가 반응형 의존성에 의해 다시 실행되도록 트리거된 경우, 호출될 디버그 콜백을 등록합니다.
이 훅은 개발 모드 전용이며, 서버 사이드 렌더링 중에 호출되지 않습니다.


function onRenderTriggered(callback: DebuggerHook): void

type DebuggerHook = (e: DebuggerEvent) => void

type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map&lt;any, any&gt; | Set&lt;any&gt;
}


https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onRenderTracked</button><span>dev only</span></dt>
                                <dd>
                                    컴포의 렌더 이펙트에 의해 반응형 의존성이 추적됐을 때
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

컴포넌트의 렌더 이펙트에 의해 반응형 의존성이 추적됐을 때, 호출될 디버그 콜백을 등록합니다.
이 훅은 개발 모드 전용이며, 서버 사이드 렌더링 중에 호출되지 않습니다.



function onRenderTracked(callback: DebuggerHook): void

type DebuggerHook = (e: DebuggerEvent) => void

type DebuggerEvent = {
  effect: ReactiveEffect
  target: object
  type: TrackOpTypes /* 'get' | 'has' | 'iterate' */
  key: any
}


https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onActivated</button><span></span></dt>
                                <dd>
                                    KeepAlive로 캐시된 컴포 인스턴스가 DOM 트리의 일부로 삽입된 후
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

KeepAlive로 캐시된 컴포넌트 인스턴스가 DOM 트리의 일부로 삽입된 후 호출될 콜백을 등록합니다.
이 훅은 서버 사이드 렌더링 중에 호출되지 않습니다.


function onActivated(callback: () => void): void


https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                         <!-- item -->
                         <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onDeactivated</button><span></span></dt>
                                <dd>
                                    KeepAlive로 캐시된 컴포 인스가 DOM 트리에서 제거된 후
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

KeepAlive로 캐시된 컴포넌트 인스턴스가 DOM 트리의 일부로 삽입된 후 호출될 콜백을 등록합니다.
이 훅은 서버 사이드 렌더링 중에 호출되지 않습니다.


function onDeactivated(callback: () => void): void


https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                         <!-- item -->
                         <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>function </span>onServerPrefetch</button><span>SSR 전용</span></dt>
                                <dd>
                                    컴포 인스가 서버에서 렌더링 되기 전에 완료(resolve)되어야 하는 비동기 함수를 등록
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

KeepAlive로 캐시된 컴포넌트 인스턴스가 DOM 트리의 일부로 삽입된 후 호출될 콜백을 등록합니다.
이 훅은 서버 사이드 렌더링 중에 호출되지 않습니다.


function onServerPrefetch(callback: () => Promise&lt;any&gt;): void



ex)
import { ref, onServerPrefetch, onMounted } from 'vue'

const data = ref(null)

onServerPrefetch(async () => {
  // 서버에서 미리 데이터를 가져오는 것은
  // 클라이언트에서 데이터를 요청하는 것보다 빠름.
  // 최초 데이터 요청 결과로 컴포넌트의 일부가 렌더링 됨.
  data.value = await fetchOnServer(/* ... */)
})

onMounted(async () => {
  if (!data.value) {
    // 마운트 시 데이터가 null일 경우,
    // 컴포넌트가 클라이언트에서 동적으로 렌더링되도록
    // 클라이언트 측에서 가져오기를 실행해야 함.
    data.value = await fetchOnClient(/* ... */)
  }
})




https://ko.vuejs.org/guide/essentials/lifecycle

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //LifeCycle -->

                    <!-- 선언적 렌더링 -->
                    <div class="depth_2">
                        <strong>선언적 렌더링</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>{{ value }}</button></dt>
                                <dd>
                                   dom에 변수 선언 법(이중 보간법)
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

div {{ renderHTML }}

export default {
    data() {
        return {
            renderHTML: '이건 텍스트'
        }
    }
}

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-html<span>=""</span></button></dt>
                                <dd>
                                   변수에 담긴 html 태그를 렌더링
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

하지만 출처가 불명확한 데이터를 사용 시 XSS 공격에 취약할 수 있음. 

h1 v-html="renderHTML"

export default {
    data() {
        return {
            renderHTML: div 디브태그 안 텍스트 /div
        }
    }
}


                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //선언적 렌더링 -->

                    <!-- class | style 바인딩 -->
                    <div class="depth_2">
                        <strong>class | style 바인딩</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-bind:class<span>="{ active: val, }"</span></button></dt>
                                <dd>
                                   class 바인딩
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

태그에 특정 클래스를 추가 삭제하기 위한 기능. 
isActive 변수가 true일때만 active가 붙음.


h1 v-bind:class="{ active: isActive }"
h1 :class="{ active: isActive }" //단축형

button @click="change"

export default {
    data() {
        return {
            isActive: false
        }
    },
    methods: {
        change() {
            this.isActive = !this.isActive
        }
    }
    
}
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-bind:style<span>="{ fontSize: val, }"</span></button></dt>
                                <dd>
                                   style 바인딩
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">




h1 style="color: red; font-size: 24px" //일반적
h1 :style="{ color: h1Color, fontSize: h2Font + 'px' }" //바인딩

button @click="change"

export default {
    data() {
        return {
            h1Color: red,
            h2Font: 48
        }
    }
    
    
}
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-bind:attr<span>="val"</span></button></dt>
                                <dd>
                                   속성 바인딩
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

// 기본적으로 속성들을 바인딩 하는 기능임. 타이틀 data속성 등을 바인딩 할 수 있음.
h1 :title="inputValue" //바인딩

export default {
    data() {
        return {
            inputValue: 'zz',
        }
    }
    
    
}
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //class | style 바인딩 -->


                     <!-- 조건부 렌더링 -->
                     <div class="depth_2">
                        <strong>조건부 렌더링</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-if<span>="조건"</span></button></dt>
                                <dd>
                                   조건x 시 렌더링 자체가 안됨. 전환 비용이 많이듦
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

주의. v-if="여기"  여기 안에 있는 조건이 참일 때만 돔이 보여짐.
그리고 v-if는 초기 렌더링이 되지 않지만 조건이 맞을 때 렌더링 되기 때문에 전환 비용이 많이든다. 
만약.. 자주 변경되는 경우 v-show를 사용하는 것이 좋다.

ex1)
h1 v-if="isVisible" class="red"
h1 v-if="isVisible === true" class="blue"
h1 v-else class="black"

isVisible이 true일땐 red, blue 보여지고.. false일땐 black가 보여짐. 


export default {
    data() {
        return {
            isVisible: false
        }
    },
}



ex2)  1보다 작을땐 레드만.. 아닐땐 블루가 보임
div v-if="count > 1" class="red"
div v-else class="blue"

button @click="count++"
button @click="count--"

export default {
    data() {
        return {
            isVisible: false,
            count: 0,
        }
    }
}



                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-else</button></dt>
                                <dd>
                                    v-if와 같이 사용.. true가 아닐 시 v-else쪽 실행..
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">



                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                          <!-- item -->
                          <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-else-if<span>="조건"</span></button></dt>
                                <dd>
                                    v-else-if
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">



                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-show<span>="val"</span></button></dt>
                                <dd>
                                    렌더링은 됨. display: none처리. 초기렌더링 비용이 많이듦
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

초기 렌더링 비용은 많이 들지만 자주 변경될 시 스타일만 변경되기 떄문에 전환 비용이 적게 든다. 
자주 변경되는 ui에 적합함. 

div v-show="isActive" class="red" // display:none
div v-show="!isActive" class="blue" // 초기에 false라 이거만 보임. 

div v-if="isActive" class="black" // 렌더링 자체가 안됨

export default {
    data() {
        return {
            isVisible: false,
        }
    }
}



                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //조건부 렌더링 -->

                     <!-- 리스트 렌더링 -->
                     <div class="depth_2">
                        <strong>리스트 렌더링</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span></span>v-for<span>="item in items"</span></button></dt>
                                <dd>
                                   반복
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

- 순회순서는 해당 객체를 Object.keys() 호출한 결과에 기반
- 고유 키값이 필요

ex1) 
const items = ref([ {msg: 'hoho'}, {msg: 'haha'} ])

li v-for="(item, index) in items" :key="item.msg"
    {{ item.msg }}


ex2) 

li v-for="(user, index) in dd" :key="user.id"
    {{ user.name }}
export default {
    data() {
        return {
            dd: [ { name: 'a' }, { name: 'b' }, { name: 'c' } ],
        }
    }
}
                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //리스트 렌더링 -->



                     <!-- 이벤트 핸들러 -->
                     <div class="depth_2">
                        <strong>이벤트 핸들러</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>@click<span>="함수명 or 기능"</span></button></dt>
                                <dd>
                                   인라인 or 함수
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">
asd
// v-on | @  둘중 하나 씀

@click
@input
@change
...


// ex1) 인라인 핸들러 
const count = ref(0)

button @click="count++"
    {{ count }}



// ex2) 메서드 핸들러
const name = ref('vue.js')

function greet(e) {
    alert(`안녕 ${name.value}`);
    if(e) e.target.tagName;
};

button @click="greet"

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //이벤트 핸들러 -->

                      <!-- 컴퓨티드 -->
                      <div class="depth_2">
                        <strong>Computed</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>computed<span></span></button></dt>
                                <dd>
                                   동일한 로직을 반복적으로 활용하면 캐싱처리되어 한번만 실행함.
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

// 컴포지션 
const menu = [
    { icon: 'Dashboard', label: 'Dashboard' },
    { icon: 'Index', label: 'Index' },
    { icon: 'Calender', label: 'Calender' },
    { icon: 'Jobs', label: 'Jobs' },
    { icon: 'Reference', label: 'Reference' },
    { icon: 'Document', label: 'Document' },
    { icon: 'CareerSite', label: 'CareerSite' },
    { icon: 'Employee', label: 'Employee' },
    { icon: 'Structure', label: 'Structure' },
    { icon: 'Settings', label: 'Settings' },
]
// 콜백에 리턴은 필수
const topMenu = computed(() => {
    return menu.slice(0, 3)
})




ex1) 그냥 메서드로 실행 시 
세번을 실행하면 3번 모두 실행됨.

h1 {{ handleComputed() }}
h1 {{ handleComputed() }}
h1 {{ handleComputed() }}

export default {
    data() {
        return {
            name: 'computed 속성 테스트입니다.'
        }
    },

    methods: {
        handleComputed() {
            console.log('메서드 실행')
            return this.name.split('').reverse().join('')
        }
    }
}


ex1) 컴퓨티드 사용 시 
같은 로직이라면 1번만 실행되어 1번 실행함.

h1 {{ handleComputed }} // 주의 실행할 때 함수 모양이지만 데이터 취급
h1 {{ handleComputed }}
h1 {{ handleComputed }}

export default {
    setup() {
        return {}
    },
 
    data() {
        return {
            name: 'computed 속성 테스트입니다.'
        }
    },

    computed: {
        handleComputed() {
            console.log('컴퓨티드 실행')
            return this.name.split('').reverse().join('')
        }
    }, 
}



                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //컴퓨티드 -->

                    <!-- watch -->
                    <div class="depth_2">
                        <strong>Watch</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>Watch<span></span></button></dt>
                                <dd>
                                   어떤 데이터를 감시하다가 변경됐을 때 감지하여 로직실행
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

// 변수와 같은 이름으로 와치 객체에 실행함수를 넣으면 
// 해당 변수가 변경되었을 때 감지하여 함수를 실행함



//ex1) 컴포지션 
input type="text" :value="foo"  @input="foo = $event.target.value" 
{{ foo }}

import { ref, watch } from 'vue'

const foo = ref('')

watch (foo, (newValue) => {
  console.log(`foo값: ${newValue}`)
})


//ex1-1) props 객체 감지 
// 부모에서 해당 컴포로 내려준 데이터를 defineProps로 받으면서 watch로 감지
import { ref, watch } from 'vue'

const props = defineProps({
  termData: {
    cycleNumber: 3,
    cycleName: '개월',
  },
})

watch (
  () => props.termData,
  (termData) => {
    if (termData) {
      console.log(`${termData.cycleNumber} ${termData.cycleName}`) 
    }
  }
)




//ex2) 옵션즈 
h1{{ massage }} {{ watchMessage }}
button @click="handleMsgChage" 메시지 변경



export default {
    data() {
        return {
            message: 'hi',
            watchMessage: ''
        }
    },


    watch: {
        message() { // 변수와 똑같은 명칭. message 변수가 변경될 때 이 함수도 실행
            alert('메시지 watch 감지!!')
            this.watchMessage = '와치와치'
        }
    },

    // 데이터 뿐만 아니라 computed로 계산된 형태의 데이터도 watch로 감지
    // 게시판에서 한 컬럼을 선택하였을 때, 고유한 id값이 바뀜을 감지하고 
    // 이때, 그 id 값에 따른 상세 데이터를 호출할 때, 주로 사용한다 
    id() {
        // id가 변경될 때 상세데이터를 호출하는 api 함수 실행
    },

    methods: {
        handleMsgChage() {
            console.log('메시지변경')
            this.message = '변경된 메시지'
        }
    } 
    
}


                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //watch -->

                     <!-- props emit -->
                     <div class="depth_2">
                        <strong>Props | Emits</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>props: {}<span> | </span>defindProps</button></dt>
                                <dd>
                                    위 &gt; 아래로 넘겨줌 
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

// 사용방법
옵션즈 props: {}
컴포지션 defindProps

prop 받은 데이터의 타입 설정
prop 받은 데이터는 변경 불가


// 다시정리 
// ## 부모컴포
&lt;Evt :firstName="first" :lastName="last" :info="obj"/&gt;


import { reactive, ref } from 'vue';
import Evt from './Evt.vue';

interface Info {
  address: String;
  age: Number;
}

const first = ref&lt;string&gt;('lee')
const last = ref&lt;string&gt;('jonghwan')
const obj = reactive&lt;Info&gt;({ 
  address: 'busan',
  age: 30
 })



// ## 자식컴포 
{{ firstName }}
{{ lastName }}
{{ info.address }}
{{ info.age }}


import { toRefs } from "vue"

interface Obj {
    firstName: String;
    lastName: String;
    info: Info;
}

interface Info {
    address: String;
    age: Number;
}

const props = defineProps&lt;Obj&gt;()
const {firstName, lastName, info} = toRefs(props)















// ############################## 부모 컴포

// 템플릿 
&lt;Evt v-bind:prop1="hoho" :prop2="hoho2" :prop3="obj"/&gt;


//스크립트 
import { ref, reactive, onBeforeMount, onMounted, onUpdated, onUnmounted } from 'vue';
import Evt from './Evt.vue';

interface Obj {
  id: number,
  name: string, 
}

const hoho = ref&lt;string&gt;('부모컴에서 만든 데이터')
const hoho2 = ref&lt;number&gt;(3333)
const obj = reactive&lt;Obj&gt;({  // 객체 배열은 reactive 권장
  id: 1,
  name: "jong"
})



// ############################## 자식 컴포
//템플릿
{{ prop1 }}
{{ prop2 }}
{{ prop3.id }}
{{ prop3.name }}

// toRefs 전 
// {{ props.prop1 }} 
// {{ props.prop2 }} 
// {{ props.prop3.id }} 
// {{ props.prop3.name }} 


//스크립트 
setup lang="ts"

import { toRefs } from "vue"

interface Obj {
  id: number,
  name: string, 
}

interface Props {
    prop1: String,
    prop2: Number,
    prop3: Obj
}

// toRefs 사용하면 구조분해할당 가능해서 템플릿 부분에  props.prop1 이렇게 적지 않아도됨
const props = defineProps&lt;Props&gt;()
const { prop1, prop2, prop3 } = toRefs(props)




                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>this.$emits<span> | </span>defineEmits(name, data)</button></dt>
                                <dd>
                                    아래 &gt; 위로 넘겨줌
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

// 사용방법
옵션즈 this.$emits
컴포지션 defineEmits(evtname, data)


// 다시 정리 
// 부모 컴포 

&lt;h3>부모컴포&lt;/h3&gt;
&lt;Evt @send-evt="fn"/&gt;

&lt;div v-for="(item, idx) in childData" :key="idx"&gt;
  {{ item }}
  {{ item?.address }}
  {{ item?.age }}
&lt;/div&gt;
// 데이터안에 객체와 일반 문자가 같이 섞여있을떄는 어떡함?

{{ childData[0] }}
{{ childData[1] }}
{{ childData[2].address }}
{{ childData[2].age }}


// script
import { ref } from 'vue'
import Evt from './Evt.vue'


const childData = ref();
const fn = (infos: string):void =&gt; {
  console.log('infos?', infos)
  childData.value = infos;
}




// 자식 컴포 
&lt;h1&gt;자식컴포&lt;/h1&gt;
&lt;button type="button" @click="loadEmit"&gt;click&lt;/button&gt;


// script
import { reactive, ref, onMounted } from "vue";

interface Info {
    address: String;
    age: number;
}

// number와 Number가 타입이 다름. ++을 시켰을 때 Number는 증가가 안됨


const firstName = ref&lt;string&gt;('lee')
const lastName = ref&lt;string&gt;('jonghwan')
const info = reactive&lt;Info&gt;({
    address: 'busan',
    age: 30
})


const emit = defineEmits([ 'send-evt' ])
const loadEmit = () =&gt; {
    emit('send-evt', [firstName.value, lastName.value, { address: info.address, age: info.age }]);
    console.log('info?', info.age)
    info.age++
}

onMounted(() =&gt; {
    loadEmit()
})








// ############################################################################################

// ################ 부모 컴포

&lt;Evt @send-evt="parentEvt" /&gt;


import Evt from './Evt.vue';

const parentEvt = (evt: string) =&gt; {
  console.log(evt)
}



// ################ 자식 컴포

&lt;button @click="evt"&gt;부모로 보내기&lt;/button&gt;


import { ref } from 'vue';

const data = ref&lt;string&gt;('자식 컴포 데이터')

const emit = defineEmits([ 'send-evt' ])
const evt = ():void =&gt; {
    emit('send-evt', data.value);
}

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                    </div>
                    <!-- //props emit -->


                    <!-- v-model -->
                    <div class="depth_2">
                        <strong>v-model</strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button>v-model<span>="val"</span></button></dt>
                                <dd>
                                    데이터 일치.. useState기능비슷? 
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

1. 양방향 데이터 바인딩 (메모리에 담긴 데이터와 html에 보여지는 데이터, 두개의 소스를 일치)
v-model은 Props와 Emits의 기능이 동시에 진행된다는 개념

2. input의 기능에 따라 
v-model은 input 태그의 input value의 값과 연관지어 많이 사용. 
input의 변경을 감지하여 DOM에 뿌려진 곳이 같이 변경되게끔


// ex1) 컴포지션 
input type="text" :value="firstName" v-model="firstName"
input type="text" :value="lastName" v-model="lastName"
{{ firstName }}

//script 
const firstName = defineModel('firstName')
const lastName = defineModel('lastName')

//## 주의점은 한글 입력시 표시가 인풋창에서 다른곳 찍어야 반영됨. 표시만.. 
//## 해결방법

input type="text" :value="firstName" @input="firstName = $event.target.value"
{{ firstName }}




//ex2) 옵션즈
input type="text" v-model="inputValue"
{{ inputValue }}


export default {
    data() {
        return {
            inputValue: ''
        }
    }
}

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                     
                    </div>
                    <!-- //v-model -->


                    <br /><br />

                    <!-- nuxt -->
                    <div class="depth_2">
                        <strong></strong>
                        <!-- item -->
                        <div class="item_wrap">
                            <dl class="item">
                                <dt><button><span>nuxt</span></button></dt>
                                <dd>
                                    nuxt
                                </dd>
                            </dl>
                            <div class="code_wrap">
                                <pre>
                        <code class="javascript">

1. 라우팅은 pages 폴더안에 만들면 자동 라우팅. 
1-1. 폴더 만들면 폴더까지가 라우팅. 폴더 안 index.vue가 루트경로..index는 생략. lcoalhost.~/newforder/ 

&lt;NuxtPage /&gt; 라고 컴포넌트를 불러오면 pages 폴더안 라우팅 페이지가 담김


2. layout 폴더기능은  &lt;NuxtPage /&gt; 밖으로 감싸줌. 

// layouts - default.vue 
header
&lt;slot /&gt; //슬롯은 넉스트 레이아웃안쪽 돔이 담기는 곳
footer 


// app.vue
&lt;NuxtLayout /&gt;
    &lt;NuxtPage /&gt;
&lt;NuxtLayout /&gt;


// 레이아웃 바꾸고 싶다면 
definePageMeta({
    layout: '파일명'
})



3. .env 
vite면 앞에 VITE_NAME = 'name'
불러올땐 import.meta.env.VITE_NAME

                        </code>
                    </pre>
                            </div>
                        </div>
                        <!-- //item -->
                     
                    </div>
                    <!-- //nuxt -->


                    
                    <br /><br />

                    <!-- item -->
                    <div class="item_wrap">
                        <dl class="item">
                            <dt><button><span>vue </span>.vue</button></dt>
                            <dd>
                                vue git pages에 배포하기 참고 
                            </dd>
                        </dl>
                        <div class="code_wrap">
                            <pre>
                    <code class="javascript">
vue git pages에 배포하기 참고 
https://velog.io/@lire_eruel/Github%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90-Svelte-Vite-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0
                    </code>
                </pre>
                        </div>
                    </div>
                    <!-- //item -->
                </section>
                <!-- Vue -->







            </div>
        </main>
        <footer>
            <div class="global_wrap">
                <ul class="info"></ul>
            </div>
        </footer>
    </div>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>