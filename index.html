<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
   
    <title>Document</title>
</head>
<body>
    <div class="wrap line">
        <header>
            <nav class="global_wrap main">
                <ul class="line">
                    <!-- <li>
                        <h1>
                            <a href="./index.html" class="on">Jongdbook</a>
                        </h1>
                    </li>
                    <li>
                        <a href="./src/pages/html/index.html">HTML</a>
                    </li>
                    <li>
                        <a href="./src/pages/html/accessibility.html">Accessibility</a>
                    </li>
                    <li>
                        <a href="./src/pages/html/standards.html">Standards</a>
                    </li>
                    <li>
                        <a href="./src/pages/css/index.html">CSS</a>
                    </li>
                    <li>
                        <a href="./src/pages/js/index.html">JS</a>
                    </li> -->
                </ul>
            </nav>
        </header>
        <main>
            <div class="global_wrap">
                
<section class="conts">

    <h2>간단 정리</h2>
    <div class="depth_2">
        <strong>호호</strong>
        
            <!-- item -->
            <div class="item_wrap">
            <dl class="item">
                <dt><button><span>DOM</span> 기본</button></dt>
                <dd>
                    상속, nodeList, innerHTML, insertAdjacentHTML 
                </dd>
            </dl>
            <div class="code_wrap">
                <pre>
<code class="markdown">

# dom은 node에서 상속 
var el = document.querySelector('li')
el.__proto__  // HTMLLIElement
el.__proto__.__proto__  // HTMLElement
el.__proto__.__proto__.__proto__  // Element
el.__proto__.__proto__.__proto__.__proto__  // Node 
el.__proto__.__proto__.__proto__.__proto__.__proto__  // EventTarget   
el.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__  // Object   


-------------------------------------------


# Array Like Object 
1. [HTMLCollection] : getElementsByClassName() / getElementsByTagName()
2. [NodeList] : document.querySelectorAll() 


# [HTMLCollection]
Live - 변경시 바로 [HTMLCollection] node에 적용되기 때문에 반복문 쓸 때 주의해야됨 

ex)  홀수만 변경됨
var el = document.getElementsByClassName('aside_btn')
for(var i = 0; i &lt; el.length; i++) {
console.log(el)
console.log(el[i])
el[i].className = 'hoho' // 여기서 변경한걸 el에 저장된 콜렉션에 바로 등록하기 때문에 적용이 제대로 되지않음
}


# [NodeList] 
non-Live - 변경 사항이 NodeList에 바로 반영되지 않음

ex)  모두 정상 변경
var el = document.querySelectorAll('aside_btn')
for(var i = 0; i &lt; el.length; i++) {
console.log(el)
console.log(el[i])
el[i].className = 'hoho' // 여기서 변경한걸 el에 저장된 콜렉션에 바로 등록하기 때문에 적용이 제대로 되지않음
}


-------------------------------------------


# dom search  -  HTMLElement 상속

- Node로 찾아줌  -  띄어쓰기or공백도 #textNode로 찾아주니 주의 
parentNode  
firstChild    
lastChild
previousSibling
nextSibling


- 체크
nodeValue
nodeName
nodeType


- 복수
hasChildNodes()  -  자식 노드가 있는지 불린값 반환
childNodes   -  nodeList   
children   -  HTMLCollection


- Element로 찾아줌 
firstElementChild 
lastElementChild  
previousElementSibling 
nextElementSibling



- 속성
className
classList
id
hasAttribute(attribute)
getAttribute(attribute)
setAttribute(attribute, value)
removeAttribute(attribute)



- 조작
textContent
innerText
innerHTML


- 돔조작
createElement(tagName)  -  HTMLElement를 상속
createTextNode(text)
appendChild(Node)
removeChild(Node)



insertAdjacentHTML(position, string)
‘beforebegin’
p
‘afterbegin’
foo 
‘beforeend’
p
‘afterend’


# 장단점 

1. innerHTML 
- DOM 조작 방식에 비해 빠르고 간편하다.
- 간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.
- 콘텐츠를 취득할 수 있다.

- XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 
사용자 이름 등)를 추가할 때 주의하여야 한다.
- 해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 이것은 비효율적이다.



2. createElement
- 특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다.

- innerHTML보다 느리고 더 많은 코드가 필요하다.



3. insertAdjacentHTML()
- 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.
- 삽입되는 위치를 선정할 수 있다.

- XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 
사용자 이름 등)를 추가할 때 주의하여야 한다.


4. 결론
innerHTML과 insertAdjacentHTML()은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 
따라서 untrusted data의 경우, 주의하여야 한다. 
텍스트를 추가 또는 변경시에는 textContent, 새로운 요소의 추가 또는 삭제시에는 DOM 조작 방식을 사용하도록 한다.




# css 조작
window.getComputedStyle





<span class="seg"><a href="https://poiemaweb.com/js-dom" target="_blank">https://poiemaweb.com/js-dom</a></span>
<span class="seg"><a href="https://dkje.github.io/2020/08/18/createDomElement/" target="_blank">https://dkje.github.io/2020/08/18/createDomElement/</a></span>



</code>
</pre>
            </div>
        </div>
        <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
            <dl class="item">
                <dt><button><span>DOM</span> 성능 / 보안</button></dt>
                <dd>dom조작<span>&lt;</span> innerHTML <span>&lt;</span> insertAdjacentHTML<br />dom조작<span>&gt;</span> innerHTML <span>&gt;=</span> insertAdjacentHTML</dd>
            </dl>
            <div class="code_wrap">
                <pre>
<code class="markdown">

장단점 

# innerHTML 
- DOM 조작 방식에 비해 빠르고 간편하다.
- 간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.
- 콘텐츠를 취득할 수 있다.

- XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 
사용자 이름 등)를 추가할 때 주의하여야 한다.
- 해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 이것은 비효율적이다.


# createElement
- 특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다.

- innerHTML보다 느리고 더 많은 코드가 필요하다.


# insertAdjacentHTML()
- 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.
- 삽입되는 위치를 선정할 수 있다.

- XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 
사용자 이름 등)를 추가할 때 주의하여야 한다.


결론
innerHTML과 insertAdjacentHTML()은 
크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다. 
따라서 untrusted data의 경우, 주의하여야 한다. 
텍스트를 추가 또는 변경시에는 textContent, 
새로운 요소의 추가 또는 삭제시에는 DOM 조작 방식을 사용하도록 한다.


</code>
</pre>
            </div>
        </div>
        <!-- //item -->
            <!-- item -->
            <div class="item_wrap">
            <dl class="item">
                <dt><button><span>DOM</span> document load</button></dt>
                <dd>로딩 시점, 타이밍, preload, prepatch, lazyload</dd>
            </dl>
            <div class="code_wrap">

                <pre>
<code class="markdown">
# preload
기본적으로 사용될 리소스들 중에 먼저 불러와야하는 것들이 있다면 preload를 써서 HTML parse할때 다운받게함
preload로 다운받은 리소스들은 ()실행문을 만나면 다운로드하지않고 바로 실행할 수 있으니 빠름.  
(무조건 화면이 빠르게 보이고 기능이 작동할 수 있게.  FP - LCP까지의 시간 단축이 핵심)

1. font:   &lt;link rel="preload" href="../fonts/BMDoHyeon.woff2" type="font/woff2" as="font" crossorigin /&gt;
덜컥거림을 방지하기 위해 preload하면 미리 다운받았기 때문에 font-face url()을 만나면 다운받은걸로 바로 적용됨
subset을 쓰면 전체 폰트파일에서 필요한 것만 미리 가져올수도 있음.

ex)
@font-face {
    font-family: 'BMDoHyeon';
    src: local('BMDoHyeon'),
        url('../fonts/BMDoHyeon.woff2') format('woff2'),
        url('../fonts/BMDoHyeon.woff') format('woff'),
        url('../fonts/BMDOHYEON_ttf.ttf') format('truetype');
    /* font-display: swap; */
}


2. image: &lt;link rel="preload" as="image" href="./images/img.jpg" &gt;
첫화면에 필요한 이미지를 preload 하게되면 img src 태그를 만나기전에 미리 다운받기 떄문에 태그를 만난 순간 바로 적용 


3. css:  
&lt;link rel="stylesheet" href="./css/media_test.css" media="print" onload="this.media='all'"&gt;
&lt;link rel="preload" as="style" href="./css/reset.css" &gt;
첫화면 혹은 메인에 필요한 css를 preload 하게되면 link style 보다 더 먼저 다운되었기에 빠르게 적용됨 
(preload보다 더 빠른건 head에 style 인라인 넣는 방법)

ex1) 
모바일로 접속했을 때 html parse 하면서 mobile.css 파일만 받음. 
html parse가 끝나는 시점에 나머지 pc.css, tablet.css 다운받고 처리.
&lt;link rel="stylesheet" href="./css/reset.css" media="all"&gt;
&lt;link rel="stylesheet" href="./css/pc.css" media="all and (min-width: 1000px) and (max-width: 4000px)"&gt;
&lt;link rel="stylesheet" href="./css/tablet.css" media="all and (min-width: 481px) and (max-width: 1000px)"&gt;
&lt;link rel="stylesheet" href="./css/mobile.css" media="all and (min-width: 0px) and (max-width: 480px)"&gt;

q? 필요한 디바이스꺼만 받고 나머지 print 설정 후  this.media로 조절하고 싶은데 방법ㅇ ㅣ없나 ..?  스크립트 없이 

</code>
</pre>

<pre>
    <code class="markdown">
# lazyload
당장 로드될 때 필요없는 리소스들은 나중에 불러오게 함 
필요한 리소스만 불러온 후 나머지 소스들은 화면이 먼저 불러와진 후 천천히 다운로드 

1. image (이미지 최적화에서 자세히 설명)
img loading="lazy" 를 쓰거나 new IntersectionObserver로 제어. 
(img src=""는 만나는 순간 다운받기 떄문에, data-src="" 에서 src로 넣는 방법)

2. css 
    - media="print"로 한 후 onload evt 후 속성바꿔도 됨   
    &lt;link rel="stylesheet" href="./css/media_test.css" media="print" onload="this.media='all'"&gt; 

    - onload 후 js로 head 삽입 (위 방법이 더 깔끔한듯) 
    head.innerHTML += `&lt;link rel="stylesheet" href="./css/media_query_test.css" /&gt;`

    두 방법 모두 퍼포먼스탭에서 onload event 후 리소스를 다운받음.


    </code>
    </pre>
    <pre>
    <code class="markdown">
결론: 
    1) prefetch: prefetch cache. main-81점, sub-89점  
    2) link onload lazy: memory cache. main-85점, sub-91점



# prefetch
나중에 접속 할 페이지의 리소스(html, style, script)를 다운로드함 
(예를 들어 메인페이지에 들어갔을 때 서브페이지 자원들을 미리 로드할 수 있음)
lazy랑 비슷한 개념이지만 로드시점이 조금 다름. 


# test 1) prefetch 없이 일반적인 다운로드 (용량 큰 css파일 두개)
&lt;link rel="stylesheet" href="common.css"&gt;
&lt;link rel="stylesheet" href="dx-com.css"&gt;
결과 
- 퍼포먼스 점수: 74 (LCP 2.7s) 
- 로드시점: 순서대로


------------------------------------------------------


# test 2) prefetch로 다운로드 (bg에서 다운로드 후 메모리 캐시저장)
&lt;link rel="prefetch" href="common.css" as="style"&gt;
&lt;link rel="prefetch" href="dx-com.css" as="style"&gt;
결과 
- 퍼포먼스 점수: 98
- 로드시점: 중간 html에 img 태그가 있어도 무조건 후순위 다운로드함. (html 파싱 안막음)
            근데 onload 후가 아니라 html parse 이후. 요청시작함

*본창에서 다운로드 138kb           142ms
    서브페이지에선 prefetch cache     14ms
    서브페이지 새로고침 시 disk cache  0ms
    브라우저 종료후 키면 memory cache  0ms


------------------------------------------------------


# test 3) link media로 조절
&lt;link rel="stylesheet" href="common.css" media="print" onload="this.media='all'"&gt;
&lt;link rel="stylesheet" href="dx-com.css" media="print" onload="this.media='all'"&gt;
결과 
- 퍼포먼스 점수: 100
- 로드시점: 중간 html에 img 태그가 있어도 무조건 후순위 다운로드함. 
            근데 onload 후가 아니라 html parse 이후. 요청시작함
            (rel에 prefetch 들어가면 무한로드함)

?q 근데 왜 다운로드 시점이 html parse 이후인지 ..?


*메인에서 onload 후 all로 바꾸면 서브페이지에선 memory cache
    성능상 지장 전혀 없고 prefetch 보단 이거 쓰는게 나을듯


------------------------------------------------------


# test 4) script로 문자열 붙여보기

window.onload = () =&gt; {
    document.head.innerHTML += "
        &lt;link rel="stylesheet" href="common.css"&gt;
        &lt;link rel="stylesheet" href="dx-com.css"&gt;
    "
}

결과
- 퍼포먼스 점수: 100
- 로드시점: 예상대로 onload event 이후 요청


???----------------------
중요... 이거 서브페이지 가면 disk cache일땐 두번 로드함; 
disk cache 인데 처음꺼 35ms 두번쨰꺼 10ms

새로고침하면 memory cache로 바뀌면서 한번만 다운로드하는데 
디스크캐시일땐 캐시값이 달라서 두번다운로드 하는듯..
???---------------------- 
위에 내용 캐시 싹다 삭제하고 크롬끄고 다시하니깐 메모리캐시로 저장되고 두번 다운도 안함.. 
서브페이지에선 맨처음
두번 저장되던건 크롬을 안끄고 다시 접속했을 시 기존 캐시랑 다른 disk cache라서 두번인거같은 느낌


</code>
</pre>

<pre>
    <code class="markdown">

# preconnect
접속할 url의 TCP 통신의 기초작업을 미리 설정
..리소스를 많이 먹기 떄문에 과도하게 사용 노


</code>
</pre>

<pre>
    <code class="markdown">

# Load Event
1. DOMContentLoaded 
- 문서가 로드 됐을 때

2. onload 
- css js image font 등 리소스들이 모두 로드되었을 때

3. unload 
- 사용자가 페이지를 떠날 때 사용자의 데이터나 정보 통계를 전송하고자 할 때

4. beforeunload
- 사용자가 페이지를 떠날 때 저장하지 않은 내용을 확인 시켜줄 목적으로 사용


*** 중요 
style은 DOM이 파싱하는걸 막지 않아서 DCL가 style을 기다리지 않지만  
script 바로 위에 있는 style은 style이 모두 로드될떄까지 아래 script를 안읽음 
&lt;link type="text/css" rel="stylesheet" href="style.css"&gt;
&lt;script&gt;
// 이 스크립트는 위 스타일시트가 로드될 때까지 실행되지 않습니다.
alert(getComputedStyle(document.body).marginTop);
&lt;/script&gt;



*Frist Paint부터 LargeContentPaint 까지의 시간을 단축하는게 핵심
|     |
# 시점  FP > CFP > DCL > L > LCP
1. html down 후 파싱 
2. head 리소스 다운로드 (사전로드한게 있다면 먼저) (style Tag가 있다면 먼저 동시에 CSSOM)
3. DOM 다 그려지면 readyState: interactive + DOMContentLoaded가
4. Load evt + readyState: complete


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


# readyState 속성
loading - 문서를 불러오는 중일 때
interactive - 문서가 완전히 불러와졌을 때. DOMContentLoaded가 실행되기 바로 직전에 해당 값으로 변경됩니다.
complete - 문서를 비롯한 이미지 등의 리소스들도 모두 불러와졌을 때. window.onload가 실행되기 바로 직전에 해당 값으로 변경됩니다



js info ex)
&lt;script&gt;
log('초기 readyState:' + document.readyState);

document.addEventListener('readystatechange', () =&gt; log('readyState:' + document.readyState));
document.addEventListener('DOMContentLoaded', () =&gt; log('DOMContentLoaded'));

window.onload = () =&gt; log('window onload');
&lt;/script&gt;

&lt;iframe src="iframe.html" onload="log('iframe onload')"&gt;&lt;/iframe&gt;

&lt;img src="http://en.js.cx/clipart/train.gif" id="img"&gt;
&lt;script&gt;
img.onload = () =&gt; log('img onload');
&lt;/script&gt;


실행 결과)
1. [1] initial readyState:loading
2. [2] readyState:interactive    (DCL보다 더 빠른 시점)
3. [2] DOMContentLoaded
4. [3] iframe onload
5. [4] img onload                (img onload 후 complate)
6. [4] readyState:complete
7. [4] window onload





js info 
https://ko.javascript.info/onload-ondomcontentloaded#ref-188

async defer
https://ko.javascript.info/script-async-defer

document.readyState ex)
https://plnkr.co/edit/sX1w7BGpMxfCERwq?p=preview&preview


개발자도구 팁 
https://developer.chrome.com/docs/devtools/

성능 분석 팁 
https://blog.shiren.dev/2016-11-15-%ED%81%AC%EB%A1%AC%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84%EA%B5%AC%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%84%B1%EB%8A%A5%EC%B8%A1%EC%A0%95/


</code>
</pre>
            </div>
        </div>
        <!-- //item -->
        <!-- item -->
            <div class="item_wrap">
            <dl class="item">
                <dt><button><span>최적화</span> Image</button></dt>
                <dd>성능빠른 방법</dd>
            </dl>
            <div class="code_wrap">
                <pre>
<code class="markdown">

# 반응형에서 이미지 (m: 360x360 120kb, pc: 120x120 20kb) 12장으로 테스트 

1. 3배수 이미지 하나를 그대로 썼을 때 (lazy 적용x)
-FCP: 0.2  -SI: 0.2  -LCP: 1.1  -TtI: 0.2  -TBT: 0  -CLS: 0.2(성능나빠짐) 

1-1. 3배수 이미지 하나를 그대로 썼을 때 (js lazy 적용o)
-FCP: 0.2  -SI: 0.2  -LCP: 0.2 -TtI: 0.2  -TBT: 0  -CLS: 0.2

2. pc/m 이미지를 나누고 media query사용. loading="lazy" 적용
-FCP: 0.2  -SI: 0.2  -LCP: 0.5  -TtI: 0.2  -TBT: 0  -CLS: 0

3. pc/m 이미지를 나누고 media query사용. IntersectionObserver 적용  (가장 빠름)
-FCP: 0.2  -SI: 0.2  -LCP: 0.3  -TtI: 0.2  -TBT: 0  -CLS: 0

3번 code)
const obTarget = document.querySelectorAll('ele')
const inter = new IntersectionObserver(ent =&gt; ob(ent))
const ob = ents =&gt; {
    if(document.body.clientWidth &lt;= 600) { //600 이하 브라우저 
        //ents는 옵저버하고 있는 엘리먼트를 담은 객체
        ents.forEach(ent =&gt; {
            if(ent.classList.contains('mobile') && ent.isIntersecting) {
                ent.target.src = ent.target.dataset.src
            }
        })
    }
}

obTarget.forEach(item =&gt; inter.observe(item))


4. bg로 넣었을 때 css media query 사용.
media query는 조건에 맞지 않으면 그냥 지나가버림. 
분기처리만 잘 되어있다면 m으로 접근시 pc안에 있는 url()은 다운로드하지 않음.



3번이 가장 빠르고 이미지 렌더링도 가장 빨랐음. 
그럼 반응형할땐 이미지를 두개로 관리하고 new IntersectionObserver로 lazy 관리를 해야하나 ? 
아니면 큰 이미지만 그렇게 하면 될까 ..



# image preload 
- 리소스를 html 파싱 후에 받는게 아니라 파싱하면서 미리 다운로드 받아둠
- 라이트하우스 돌려보면 html parse 하는 구간에서 다운로드 시작 (preload 안걸면 모두 파싱 후 DCL 부터 받음 ) 



</code>
</pre>
            </div>
        </div>
        <!-- //item -->
        <!-- item -->
        <div class="item_wrap">
            <dl class="item">
                <dt><button><span>JS</span> Class</button></dt>
                <dd>class 정리</dd>
            </dl>
            <div class="code_wrap">
                <pre>
<code class="javascript">



</code>
</pre>
            </div>
        </div>
        <!-- //item -->

        <!-- item -->
        <div class="item_wrap">
            <dl class="item">
                <dt><button><span>js</span> evaluation</button></dt>
                <dd>함수형 프로그래밍, 지연 평가</dd>
            </dl>
            <div class="code_wrap">
                <pre>
<code class="javascript">

내일정리

</code>
</pre>
            </div>
        </div>
        <!-- //item -->



    </div>
</section>
                 

              


            </div>
        </main>
        <footer>
            <div class="global_wrap">
               asdasdas
            </div>
        </footer>
    </div>




    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/atom-one-dark.min.css">
    
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</body>
</html>